problem_number,index,category,problem_type,problem,solution_prompt,solution,test_input,expected,actual,status,pass,exception
1,0,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    # Calculate the sum of a and b
    result = a + b
    
    # Return the calculated sum
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Sum of positive numbers
print(""Test Case 1: "", funcImp(3, 5))  # Expected output: 8

# Test case 2: Sum involving zero
print(""Test Case 2: "", funcImp(0, 7))  # Expected output: 7

# Test case 3: Sum of negative numbers
print(""Test Case 3: "", funcImp(-4, -6))  # Expected output: -10

# Test case 4: Sum of a positive and a negative number
print(""Test Case 4: "", funcImp(10, -3))  # Expected output: 7

# Test case 5: Edge case with large numbers
print(""Test Case 5: "", funcImp(1000000, -999999)) # Expected output: 1

```","(3, 5)",8,8,PASS,TRUE,
1,1,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    # Calculate the sum of a and b
    result = a + b
    
    # Return the calculated sum
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Sum of positive numbers
print(""Test Case 1: "", funcImp(3, 5))  # Expected output: 8

# Test case 2: Sum involving zero
print(""Test Case 2: "", funcImp(0, 7))  # Expected output: 7

# Test case 3: Sum of negative numbers
print(""Test Case 3: "", funcImp(-4, -6))  # Expected output: -10

# Test case 4: Sum of a positive and a negative number
print(""Test Case 4: "", funcImp(10, -3))  # Expected output: 7

# Test case 5: Edge case with large numbers
print(""Test Case 5: "", funcImp(1000000, -999999)) # Expected output: 1

```","(0, 7)",7,7,PASS,TRUE,
1,2,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    # Calculate the sum of a and b
    result = a + b
    
    # Return the calculated sum
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Sum of positive numbers
print(""Test Case 1: "", funcImp(3, 5))  # Expected output: 8

# Test case 2: Sum involving zero
print(""Test Case 2: "", funcImp(0, 7))  # Expected output: 7

# Test case 3: Sum of negative numbers
print(""Test Case 3: "", funcImp(-4, -6))  # Expected output: -10

# Test case 4: Sum of a positive and a negative number
print(""Test Case 4: "", funcImp(10, -3))  # Expected output: 7

# Test case 5: Edge case with large numbers
print(""Test Case 5: "", funcImp(1000000, -999999)) # Expected output: 1

```","(-4, -6)",-10,-10,PASS,TRUE,
1,3,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    # Calculate the sum of a and b
    result = a + b
    
    # Return the calculated sum
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Sum of positive numbers
print(""Test Case 1: "", funcImp(3, 5))  # Expected output: 8

# Test case 2: Sum involving zero
print(""Test Case 2: "", funcImp(0, 7))  # Expected output: 7

# Test case 3: Sum of negative numbers
print(""Test Case 3: "", funcImp(-4, -6))  # Expected output: -10

# Test case 4: Sum of a positive and a negative number
print(""Test Case 4: "", funcImp(10, -3))  # Expected output: 7

# Test case 5: Edge case with large numbers
print(""Test Case 5: "", funcImp(1000000, -999999)) # Expected output: 1

```","(10, -3)",7,7,PASS,TRUE,
1,4,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    # Calculate the sum of a and b
    result = a + b
    
    # Return the calculated sum
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Sum of positive numbers
print(""Test Case 1: "", funcImp(3, 5))  # Expected output: 8

# Test case 2: Sum involving zero
print(""Test Case 2: "", funcImp(0, 7))  # Expected output: 7

# Test case 3: Sum of negative numbers
print(""Test Case 3: "", funcImp(-4, -6))  # Expected output: -10

# Test case 4: Sum of a positive and a negative number
print(""Test Case 4: "", funcImp(10, -3))  # Expected output: 7

# Test case 5: Edge case with large numbers
print(""Test Case 5: "", funcImp(1000000, -999999)) # Expected output: 1

```","(1000000, -999999)",1,1,PASS,TRUE,
2,0,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a: float, b: float) -> float:
    """"""
    Returns the sum of two floating-point numbers.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of a and b.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive numbers
    result = funcImp(3.5, 2.5)
    print(f""Test case 1 - Expected: 6.0, Got: {result}"")

    # Test case 2: Negative numbers
    result = funcImp(-1.5, -2.5)
    print(f""Test case 2 - Expected: -4.0, Got: {result}"")

    # Test case 3: Mixed positive and negative
    result = funcImp(10.0, -3.0)
    print(f""Test case 3 - Expected: 7.0, Got: {result}"")

    # Test case 4: Zero addition
    result = funcImp(0.0, 5.5)
    print(f""Test case 4 - Expected: 5.5, Got: {result}"")

    # Test case 5: Both zeros
    result = funcImp(0.0, 0.0)
    print(f""Test case 5 - Expected: 0.0, Got: {result}"")

# Run all test cases
run_tests()
```","3.5, 2.5",6,6,PASS,TRUE,
2,1,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a: float, b: float) -> float:
    """"""
    Returns the sum of two floating-point numbers.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of a and b.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive numbers
    result = funcImp(3.5, 2.5)
    print(f""Test case 1 - Expected: 6.0, Got: {result}"")

    # Test case 2: Negative numbers
    result = funcImp(-1.5, -2.5)
    print(f""Test case 2 - Expected: -4.0, Got: {result}"")

    # Test case 3: Mixed positive and negative
    result = funcImp(10.0, -3.0)
    print(f""Test case 3 - Expected: 7.0, Got: {result}"")

    # Test case 4: Zero addition
    result = funcImp(0.0, 5.5)
    print(f""Test case 4 - Expected: 5.5, Got: {result}"")

    # Test case 5: Both zeros
    result = funcImp(0.0, 0.0)
    print(f""Test case 5 - Expected: 0.0, Got: {result}"")

# Run all test cases
run_tests()
```","-1.5, -2.5",-4,-4,PASS,TRUE,
2,2,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a: float, b: float) -> float:
    """"""
    Returns the sum of two floating-point numbers.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of a and b.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive numbers
    result = funcImp(3.5, 2.5)
    print(f""Test case 1 - Expected: 6.0, Got: {result}"")

    # Test case 2: Negative numbers
    result = funcImp(-1.5, -2.5)
    print(f""Test case 2 - Expected: -4.0, Got: {result}"")

    # Test case 3: Mixed positive and negative
    result = funcImp(10.0, -3.0)
    print(f""Test case 3 - Expected: 7.0, Got: {result}"")

    # Test case 4: Zero addition
    result = funcImp(0.0, 5.5)
    print(f""Test case 4 - Expected: 5.5, Got: {result}"")

    # Test case 5: Both zeros
    result = funcImp(0.0, 0.0)
    print(f""Test case 5 - Expected: 0.0, Got: {result}"")

# Run all test cases
run_tests()
```","10.0, -3.0",7,7,PASS,TRUE,
2,3,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a: float, b: float) -> float:
    """"""
    Returns the sum of two floating-point numbers.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of a and b.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive numbers
    result = funcImp(3.5, 2.5)
    print(f""Test case 1 - Expected: 6.0, Got: {result}"")

    # Test case 2: Negative numbers
    result = funcImp(-1.5, -2.5)
    print(f""Test case 2 - Expected: -4.0, Got: {result}"")

    # Test case 3: Mixed positive and negative
    result = funcImp(10.0, -3.0)
    print(f""Test case 3 - Expected: 7.0, Got: {result}"")

    # Test case 4: Zero addition
    result = funcImp(0.0, 5.5)
    print(f""Test case 4 - Expected: 5.5, Got: {result}"")

    # Test case 5: Both zeros
    result = funcImp(0.0, 0.0)
    print(f""Test case 5 - Expected: 0.0, Got: {result}"")

# Run all test cases
run_tests()
```","0.0, 5.5",5.5,5.5,PASS,TRUE,
2,4,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a: float, b: float) -> float:
    """"""
    Returns the sum of two floating-point numbers.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of a and b.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive numbers
    result = funcImp(3.5, 2.5)
    print(f""Test case 1 - Expected: 6.0, Got: {result}"")

    # Test case 2: Negative numbers
    result = funcImp(-1.5, -2.5)
    print(f""Test case 2 - Expected: -4.0, Got: {result}"")

    # Test case 3: Mixed positive and negative
    result = funcImp(10.0, -3.0)
    print(f""Test case 3 - Expected: 7.0, Got: {result}"")

    # Test case 4: Zero addition
    result = funcImp(0.0, 5.5)
    print(f""Test case 4 - Expected: 5.5, Got: {result}"")

    # Test case 5: Both zeros
    result = funcImp(0.0, 0.0)
    print(f""Test case 5 - Expected: 0.0, Got: {result}"")

# Run all test cases
run_tests()
```","0.0, 0.0",0,0,PASS,TRUE,
3,0,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('123', '456')",579,579,PASS,TRUE,
3,1,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('-100', '-200')",-300,-300,PASS,TRUE,
3,2,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('150', '-50')",100,100,PASS,TRUE,
3,3,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('0', '0')",0,0,PASS,TRUE,
3,4,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('999999999', '111111111')",1111111110,1111111110,PASS,TRUE,
3,5,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('abc', '123')",,,PASS,TRUE,Invalid input for num_str1: 'abc' is not a valid integer.
3,6,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('123', 'xyz')",,,PASS,TRUE,Invalid input for num_str2: 'xyz' is not a valid integer.
3,7,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('', '123')",,,PASS,TRUE,Invalid input for num_str1: '' is not a valid integer.
3,8,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings representing numeric values,
    converts them to integers, and returns their sum.
    
    Parameters:
    - num_str1: A string representing a numeric value.
    - num_str2: A string representing a numeric value.
    
    Returns:
    - The sum of the two numbers as an integer.
    
    Raises:
    - ValueError: If either input string cannot be converted to an integer.
    """"""
    
    # Convert the first string to an integer
    try:
        num1 = int(num_str1)
    except ValueError:
        raise ValueError(f""Invalid input for num_str1: '{num_str1}' is not a valid integer."")
    
    # Convert the second string to an integer
    try:
        num2 = int(num_str2)
    except ValueError:
        raise ValueError(f""Invalid input for num_str2: '{num_str2}' is not a valid integer."")
    
    # Return the sum of both integers
    return num1 + num2

# Test cases to verify the functionality of funcImp

# Test case 1: Normal positive numbers
print(funcImp(""123"", ""456""))  # Expected output: 579

# Test case 2: Negative numbers
print(funcImp(""-100"", ""-200""))  # Expected output: -300

# Test case 3: Mixed positive and negative numbers
print(funcImp(""150"", ""-50""))  # Expected output: 100

# Test case 4: Zero values
print(funcImp(""0"", ""0""))  # Expected output: 0

# Test case 5: Large numbers
print(funcImp(""999999999"", ""111111111""))  # Expected output: 1111111110

# Edge cases with invalid inputs should raise exceptions:

try:
    print(funcImp(""abc"", ""123""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str1

try:
    print(funcImp(""123"", ""xyz""))
except ValueError as e:
    print(e)  # Expected output: Error message indicating invalid input for num_str2

try:
    print(funcImp("""", ""123""))
except ValueError as e:
     print(e)   # Expected output : Error message indicating invalid input for empty string in num_str1 

try:
     print(funcImp(""123"",""""))
except ValueError as e :
     print(e)   #Expected Output : Error message indicating invalid input for empty string in num_str2 
```","('123', '')",,,PASS,TRUE,Invalid input for num_str2: '' is not a valid integer.
4,0,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(binary1, binary2):
    """"""
    This function takes two strings representing binary numbers,
    adds them together, and returns their sum as a binary string.
    
    :param binary1: A string representing a binary number (e.g., ""101"")
    :param binary2: A string representing another binary number (e.g., ""110"")
    :return: A string representing their sum in binary form
    """"""
    # Convert both binaries to integers
    num1 = int(binary1, 2)
    num2 = int(binary2, 2)
    
    # Sum the integers
    total = num1 + num2
    
    # Convert back to a binary string and remove '0b' prefix
    return bin(total)[2:]

# Test cases for funcImp
test_cases = [
    (""101"", ""110""),   # Expected output is ""1011""
    (""0"", ""0""),       # Expected output is ""0""
    (""111"", ""111""),   # Expected output is ""1110""
    (""1001"", ""10""),   # Expected output is ""1011""
]

# Execute test cases
for i, (binary1, binary2) in enumerate(test_cases):
    result = funcImp(binary1, binary2)
    print(f""Test Case {i+1}: {binary1} + {binary2} = {result}"")
```","101, 110",1011,1011,PASS,TRUE,
4,1,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(binary1, binary2):
    """"""
    This function takes two strings representing binary numbers,
    adds them together, and returns their sum as a binary string.
    
    :param binary1: A string representing a binary number (e.g., ""101"")
    :param binary2: A string representing another binary number (e.g., ""110"")
    :return: A string representing their sum in binary form
    """"""
    # Convert both binaries to integers
    num1 = int(binary1, 2)
    num2 = int(binary2, 2)
    
    # Sum the integers
    total = num1 + num2
    
    # Convert back to a binary string and remove '0b' prefix
    return bin(total)[2:]

# Test cases for funcImp
test_cases = [
    (""101"", ""110""),   # Expected output is ""1011""
    (""0"", ""0""),       # Expected output is ""0""
    (""111"", ""111""),   # Expected output is ""1110""
    (""1001"", ""10""),   # Expected output is ""1011""
]

# Execute test cases
for i, (binary1, binary2) in enumerate(test_cases):
    result = funcImp(binary1, binary2)
    print(f""Test Case {i+1}: {binary1} + {binary2} = {result}"")
```","0, 0",0,0,PASS,TRUE,
4,2,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(binary1, binary2):
    """"""
    This function takes two strings representing binary numbers,
    adds them together, and returns their sum as a binary string.
    
    :param binary1: A string representing a binary number (e.g., ""101"")
    :param binary2: A string representing another binary number (e.g., ""110"")
    :return: A string representing their sum in binary form
    """"""
    # Convert both binaries to integers
    num1 = int(binary1, 2)
    num2 = int(binary2, 2)
    
    # Sum the integers
    total = num1 + num2
    
    # Convert back to a binary string and remove '0b' prefix
    return bin(total)[2:]

# Test cases for funcImp
test_cases = [
    (""101"", ""110""),   # Expected output is ""1011""
    (""0"", ""0""),       # Expected output is ""0""
    (""111"", ""111""),   # Expected output is ""1110""
    (""1001"", ""10""),   # Expected output is ""1011""
]

# Execute test cases
for i, (binary1, binary2) in enumerate(test_cases):
    result = funcImp(binary1, binary2)
    print(f""Test Case {i+1}: {binary1} + {binary2} = {result}"")
```","111, 111",1110,1110,PASS,TRUE,
4,3,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(binary1, binary2):
    """"""
    This function takes two strings representing binary numbers,
    adds them together, and returns their sum as a binary string.
    
    :param binary1: A string representing a binary number (e.g., ""101"")
    :param binary2: A string representing another binary number (e.g., ""110"")
    :return: A string representing their sum in binary form
    """"""
    # Convert both binaries to integers
    num1 = int(binary1, 2)
    num2 = int(binary2, 2)
    
    # Sum the integers
    total = num1 + num2
    
    # Convert back to a binary string and remove '0b' prefix
    return bin(total)[2:]

# Test cases for funcImp
test_cases = [
    (""101"", ""110""),   # Expected output is ""1011""
    (""0"", ""0""),       # Expected output is ""0""
    (""111"", ""111""),   # Expected output is ""1110""
    (""1001"", ""10""),   # Expected output is ""1011""
]

# Execute test cases
for i, (binary1, binary2) in enumerate(test_cases):
    result = funcImp(binary1, binary2)
    print(f""Test Case {i+1}: {binary1} + {binary2} = {result}"")
```","1001, 10",1011,1011,PASS,TRUE,
5,0,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive),"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive)'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates and returns the sum of all odd numbers
    between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end inclusive.
    """"""
    
    # Initialize sum
    total_sum = 0
    
    # Iterate over each number in range from start to end inclusive
    for num in range(start, end + 1):
        # Check if current number is odd
        if num % 2 != 0:
            total_sum += num
    
    return total_sum

# Test cases to verify correctness
print(funcImp(1, 10))   # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(10, 20))  # Expected output: 75 (11 + 13 + 15 + 17 + 19)
print(funcImp(-5, 5))   # Expected output: -5 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(0, 0))    # Expected output: 0 (no odd numbers)
print(funcImp(7, 7))    # Expected output: 7 (only one number which is odd)

# Edge case where start > end
print(funcImp(10, -10)) # Expected output should be handled gracefully; typically would be zero since no valid range.
```","(1, 10)",25,25,PASS,TRUE,
5,1,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive),"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive)'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates and returns the sum of all odd numbers
    between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end inclusive.
    """"""
    
    # Initialize sum
    total_sum = 0
    
    # Iterate over each number in range from start to end inclusive
    for num in range(start, end + 1):
        # Check if current number is odd
        if num % 2 != 0:
            total_sum += num
    
    return total_sum

# Test cases to verify correctness
print(funcImp(1, 10))   # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(10, 20))  # Expected output: 75 (11 + 13 + 15 + 17 + 19)
print(funcImp(-5, 5))   # Expected output: -5 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(0, 0))    # Expected output: 0 (no odd numbers)
print(funcImp(7, 7))    # Expected output: 7 (only one number which is odd)

# Edge case where start > end
print(funcImp(10, -10)) # Expected output should be handled gracefully; typically would be zero since no valid range.
```","(10, 20)",75,75,PASS,TRUE,
5,2,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive),"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive)'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates and returns the sum of all odd numbers
    between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end inclusive.
    """"""
    
    # Initialize sum
    total_sum = 0
    
    # Iterate over each number in range from start to end inclusive
    for num in range(start, end + 1):
        # Check if current number is odd
        if num % 2 != 0:
            total_sum += num
    
    return total_sum

# Test cases to verify correctness
print(funcImp(1, 10))   # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(10, 20))  # Expected output: 75 (11 + 13 + 15 + 17 + 19)
print(funcImp(-5, 5))   # Expected output: -5 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(0, 0))    # Expected output: 0 (no odd numbers)
print(funcImp(7, 7))    # Expected output: 7 (only one number which is odd)

# Edge case where start > end
print(funcImp(10, -10)) # Expected output should be handled gracefully; typically would be zero since no valid range.
```","(-5, 5)",-5,0,FAIL,FALSE,
5,3,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive),"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive)'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates and returns the sum of all odd numbers
    between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end inclusive.
    """"""
    
    # Initialize sum
    total_sum = 0
    
    # Iterate over each number in range from start to end inclusive
    for num in range(start, end + 1):
        # Check if current number is odd
        if num % 2 != 0:
            total_sum += num
    
    return total_sum

# Test cases to verify correctness
print(funcImp(1, 10))   # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(10, 20))  # Expected output: 75 (11 + 13 + 15 + 17 + 19)
print(funcImp(-5, 5))   # Expected output: -5 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(0, 0))    # Expected output: 0 (no odd numbers)
print(funcImp(7, 7))    # Expected output: 7 (only one number which is odd)

# Edge case where start > end
print(funcImp(10, -10)) # Expected output should be handled gracefully; typically would be zero since no valid range.
```","(0, 0)",0,0,PASS,TRUE,
5,4,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive),"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive)'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates and returns the sum of all odd numbers
    between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end inclusive.
    """"""
    
    # Initialize sum
    total_sum = 0
    
    # Iterate over each number in range from start to end inclusive
    for num in range(start, end + 1):
        # Check if current number is odd
        if num % 2 != 0:
            total_sum += num
    
    return total_sum

# Test cases to verify correctness
print(funcImp(1, 10))   # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(10, 20))  # Expected output: 75 (11 + 13 + 15 + 17 + 19)
print(funcImp(-5, 5))   # Expected output: -5 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(0, 0))    # Expected output: 0 (no odd numbers)
print(funcImp(7, 7))    # Expected output: 7 (only one number which is odd)

# Edge case where start > end
print(funcImp(10, -10)) # Expected output should be handled gracefully; typically would be zero since no valid range.
```","(7, 7)",7,7,PASS,TRUE,
5,5,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive),"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive)'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates and returns the sum of all odd numbers
    between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end inclusive.
    """"""
    
    # Initialize sum
    total_sum = 0
    
    # Iterate over each number in range from start to end inclusive
    for num in range(start, end + 1):
        # Check if current number is odd
        if num % 2 != 0:
            total_sum += num
    
    return total_sum

# Test cases to verify correctness
print(funcImp(1, 10))   # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(10, 20))  # Expected output: 75 (11 + 13 + 15 + 17 + 19)
print(funcImp(-5, 5))   # Expected output: -5 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(0, 0))    # Expected output: 0 (no odd numbers)
print(funcImp(7, 7))    # Expected output: 7 (only one number which is odd)

# Edge case where start > end
print(funcImp(10, -10)) # Expected output should be handled gracefully; typically would be zero since no valid range.
```","(10, -10)",0,0,PASS,TRUE,
6,0,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers in the specified range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is a prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate over each number in the inclusive range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            sum_of_primes += num
    
    return sum_of_primes

# Test cases to verify correctness
print(funcImp(10, 20))   # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60
print(funcImp(1, 10))    # Expected output: Sum of primes between [1,10] -> [2,3,5,7] = 17
print(funcImp(-10, -1))   # Expected output: No primes in negative range -> should be 0
print(funcImp(22, 29))   # Expected output: Sum of primes between [22,29] -> [23,29] = 52
print(funcImp(30,30))     # Expected output: Single non-prime number -> should be 0

```","10, 20",60,60,PASS,TRUE,
6,1,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers in the specified range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is a prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate over each number in the inclusive range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            sum_of_primes += num
    
    return sum_of_primes

# Test cases to verify correctness
print(funcImp(10, 20))   # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60
print(funcImp(1, 10))    # Expected output: Sum of primes between [1,10] -> [2,3,5,7] = 17
print(funcImp(-10, -1))   # Expected output: No primes in negative range -> should be 0
print(funcImp(22, 29))   # Expected output: Sum of primes between [22,29] -> [23,29] = 52
print(funcImp(30,30))     # Expected output: Single non-prime number -> should be 0

```","1, 10",17,17,PASS,TRUE,
6,2,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers in the specified range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is a prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate over each number in the inclusive range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            sum_of_primes += num
    
    return sum_of_primes

# Test cases to verify correctness
print(funcImp(10, 20))   # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60
print(funcImp(1, 10))    # Expected output: Sum of primes between [1,10] -> [2,3,5,7] = 17
print(funcImp(-10, -1))   # Expected output: No primes in negative range -> should be 0
print(funcImp(22, 29))   # Expected output: Sum of primes between [22,29] -> [23,29] = 52
print(funcImp(30,30))     # Expected output: Single non-prime number -> should be 0

```","-10, -1",0,0,PASS,TRUE,
6,3,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers in the specified range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is a prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate over each number in the inclusive range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            sum_of_primes += num
    
    return sum_of_primes

# Test cases to verify correctness
print(funcImp(10, 20))   # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60
print(funcImp(1, 10))    # Expected output: Sum of primes between [1,10] -> [2,3,5,7] = 17
print(funcImp(-10, -1))   # Expected output: No primes in negative range -> should be 0
print(funcImp(22, 29))   # Expected output: Sum of primes between [22,29] -> [23,29] = 52
print(funcImp(30,30))     # Expected output: Single non-prime number -> should be 0

```","22, 29",52,52,PASS,TRUE,
6,4,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers in the specified range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is a prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate over each number in the inclusive range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            sum_of_primes += num
    
    return sum_of_primes

# Test cases to verify correctness
print(funcImp(10, 20))   # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60
print(funcImp(1, 10))    # Expected output: Sum of primes between [1,10] -> [2,3,5,7] = 17
print(funcImp(-10, -1))   # Expected output: No primes in negative range -> should be 0
print(funcImp(22, 29))   # Expected output: Sum of primes between [22,29] -> [23,29] = 52
print(funcImp(30,30))     # Expected output: Single non-prime number -> should be 0

```","30, 30",0,0,PASS,TRUE,
7,0,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.
    
    Parameters:
    numbers (list): A list of numerical values (int or float).
    
    Returns:
    float: The average of the numbers in the list. If the list is empty, returns 0.
    """"""
    if not numbers:  # Check if the list is empty
        return 0
    
    total = 0
    count = 0
    
    # Iterate over each number in the list to calculate total and count
    for number in numbers:
        total += number
        count += 1
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: A normal case with positive integers
numbers1 = [10, 20, 30, 40]
print(f""Test Case 1 - Expected: {sum(numbers1)/len(numbers1)}, Got: {funcImp(numbers1)}"")

# Test case 2: A case with negative integers
numbers2 = [-10, -20, -30]
print(f""Test Case 2 - Expected: {sum(numbers2)/len(numbers2)}, Got: {funcImp(numbers2)}"")

# Test case 3: A mix of positive and negative floats
numbers3 = [5.5, -3.5, 4.0]
print(f""Test Case 3 - Expected: {sum(numbers3)/len(numbers3)}, Got: {funcImp(numbers3)}"")

# Test case 4: An empty list should return an average of zero
numbers4 = []
print(f""Test Case 4 - Expected: {0}, Got: {funcImp(numbers4)}"")

# Test case 5: A single element in the list should return that element as average
numbers5 = [42]
print(f""Test Case 5 - Expected: {42}, Got: {funcImp(numbers5)}"")
```","[10, 20, 30, 40]",25,25,PASS,TRUE,
7,1,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.
    
    Parameters:
    numbers (list): A list of numerical values (int or float).
    
    Returns:
    float: The average of the numbers in the list. If the list is empty, returns 0.
    """"""
    if not numbers:  # Check if the list is empty
        return 0
    
    total = 0
    count = 0
    
    # Iterate over each number in the list to calculate total and count
    for number in numbers:
        total += number
        count += 1
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: A normal case with positive integers
numbers1 = [10, 20, 30, 40]
print(f""Test Case 1 - Expected: {sum(numbers1)/len(numbers1)}, Got: {funcImp(numbers1)}"")

# Test case 2: A case with negative integers
numbers2 = [-10, -20, -30]
print(f""Test Case 2 - Expected: {sum(numbers2)/len(numbers2)}, Got: {funcImp(numbers2)}"")

# Test case 3: A mix of positive and negative floats
numbers3 = [5.5, -3.5, 4.0]
print(f""Test Case 3 - Expected: {sum(numbers3)/len(numbers3)}, Got: {funcImp(numbers3)}"")

# Test case 4: An empty list should return an average of zero
numbers4 = []
print(f""Test Case 4 - Expected: {0}, Got: {funcImp(numbers4)}"")

# Test case 5: A single element in the list should return that element as average
numbers5 = [42]
print(f""Test Case 5 - Expected: {42}, Got: {funcImp(numbers5)}"")
```","[-10, -20, -30]",-20,-20,PASS,TRUE,
7,2,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.
    
    Parameters:
    numbers (list): A list of numerical values (int or float).
    
    Returns:
    float: The average of the numbers in the list. If the list is empty, returns 0.
    """"""
    if not numbers:  # Check if the list is empty
        return 0
    
    total = 0
    count = 0
    
    # Iterate over each number in the list to calculate total and count
    for number in numbers:
        total += number
        count += 1
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: A normal case with positive integers
numbers1 = [10, 20, 30, 40]
print(f""Test Case 1 - Expected: {sum(numbers1)/len(numbers1)}, Got: {funcImp(numbers1)}"")

# Test case 2: A case with negative integers
numbers2 = [-10, -20, -30]
print(f""Test Case 2 - Expected: {sum(numbers2)/len(numbers2)}, Got: {funcImp(numbers2)}"")

# Test case 3: A mix of positive and negative floats
numbers3 = [5.5, -3.5, 4.0]
print(f""Test Case 3 - Expected: {sum(numbers3)/len(numbers3)}, Got: {funcImp(numbers3)}"")

# Test case 4: An empty list should return an average of zero
numbers4 = []
print(f""Test Case 4 - Expected: {0}, Got: {funcImp(numbers4)}"")

# Test case 5: A single element in the list should return that element as average
numbers5 = [42]
print(f""Test Case 5 - Expected: {42}, Got: {funcImp(numbers5)}"")
```","[5.5, -3.5, 4.0]",2,2,PASS,TRUE,
7,3,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.
    
    Parameters:
    numbers (list): A list of numerical values (int or float).
    
    Returns:
    float: The average of the numbers in the list. If the list is empty, returns 0.
    """"""
    if not numbers:  # Check if the list is empty
        return 0
    
    total = 0
    count = 0
    
    # Iterate over each number in the list to calculate total and count
    for number in numbers:
        total += number
        count += 1
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: A normal case with positive integers
numbers1 = [10, 20, 30, 40]
print(f""Test Case 1 - Expected: {sum(numbers1)/len(numbers1)}, Got: {funcImp(numbers1)}"")

# Test case 2: A case with negative integers
numbers2 = [-10, -20, -30]
print(f""Test Case 2 - Expected: {sum(numbers2)/len(numbers2)}, Got: {funcImp(numbers2)}"")

# Test case 3: A mix of positive and negative floats
numbers3 = [5.5, -3.5, 4.0]
print(f""Test Case 3 - Expected: {sum(numbers3)/len(numbers3)}, Got: {funcImp(numbers3)}"")

# Test case 4: An empty list should return an average of zero
numbers4 = []
print(f""Test Case 4 - Expected: {0}, Got: {funcImp(numbers4)}"")

# Test case 5: A single element in the list should return that element as average
numbers5 = [42]
print(f""Test Case 5 - Expected: {42}, Got: {funcImp(numbers5)}"")
```",[],0,0,PASS,TRUE,
7,4,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.
    
    Parameters:
    numbers (list): A list of numerical values (int or float).
    
    Returns:
    float: The average of the numbers in the list. If the list is empty, returns 0.
    """"""
    if not numbers:  # Check if the list is empty
        return 0
    
    total = 0
    count = 0
    
    # Iterate over each number in the list to calculate total and count
    for number in numbers:
        total += number
        count += 1
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: A normal case with positive integers
numbers1 = [10, 20, 30, 40]
print(f""Test Case 1 - Expected: {sum(numbers1)/len(numbers1)}, Got: {funcImp(numbers1)}"")

# Test case 2: A case with negative integers
numbers2 = [-10, -20, -30]
print(f""Test Case 2 - Expected: {sum(numbers2)/len(numbers2)}, Got: {funcImp(numbers2)}"")

# Test case 3: A mix of positive and negative floats
numbers3 = [5.5, -3.5, 4.0]
print(f""Test Case 3 - Expected: {sum(numbers3)/len(numbers3)}, Got: {funcImp(numbers3)}"")

# Test case 4: An empty list should return an average of zero
numbers4 = []
print(f""Test Case 4 - Expected: {0}, Got: {funcImp(numbers4)}"")

# Test case 5: A single element in the list should return that element as average
numbers5 = [42]
print(f""Test Case 5 - Expected: {42}, Got: {funcImp(numbers5)}"")
```",[42],42,42,PASS,TRUE,
8,0,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers and returns their average using recursion.
    
    :param numbers: List[int] - A list of integers or floats.
    :return: float - The average of the numbers in the list.
    """"""
    
    # Base case: if the list is empty, return 0 to avoid division by zero
    if len(numbers) == 0:
        return 0
    
    # Recursive helper function to calculate sum
    def recursive_sum(nums, n):
        # Base case for recursion: if n is 0, return 0 (no more elements to add)
        if n == 0:
            return 0
        else:
            # Add last element to sum calculated from rest of the list
            return nums[n-1] + recursive_sum(nums, n-1)
    
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate average by dividing total sum by number of elements
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: Average of positive integers
print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0

# Test case 2: Average with negative numbers included
print(funcImp([-1, -2, -3]))      # Expected output: -2.0

# Test case 3: Average with floating point numbers
print(funcImp([1.5, 2.5, 3.5]))   # Expected output: 2.5

# Test case 4: Single element in the list
print(funcImp([10]))              # Expected output: 10.0

# Test case 5: Empty list should handle gracefully and return zero as per our base condition logic
print(funcImp([]))                # Expected output: 0

# Edge Case test cases can be added here as needed.
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,
8,1,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers and returns their average using recursion.
    
    :param numbers: List[int] - A list of integers or floats.
    :return: float - The average of the numbers in the list.
    """"""
    
    # Base case: if the list is empty, return 0 to avoid division by zero
    if len(numbers) == 0:
        return 0
    
    # Recursive helper function to calculate sum
    def recursive_sum(nums, n):
        # Base case for recursion: if n is 0, return 0 (no more elements to add)
        if n == 0:
            return 0
        else:
            # Add last element to sum calculated from rest of the list
            return nums[n-1] + recursive_sum(nums, n-1)
    
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate average by dividing total sum by number of elements
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: Average of positive integers
print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0

# Test case 2: Average with negative numbers included
print(funcImp([-1, -2, -3]))      # Expected output: -2.0

# Test case 3: Average with floating point numbers
print(funcImp([1.5, 2.5, 3.5]))   # Expected output: 2.5

# Test case 4: Single element in the list
print(funcImp([10]))              # Expected output: 10.0

# Test case 5: Empty list should handle gracefully and return zero as per our base condition logic
print(funcImp([]))                # Expected output: 0

# Edge Case test cases can be added here as needed.
```","[-1, -2, -3]",-2,-2,PASS,TRUE,
8,2,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers and returns their average using recursion.
    
    :param numbers: List[int] - A list of integers or floats.
    :return: float - The average of the numbers in the list.
    """"""
    
    # Base case: if the list is empty, return 0 to avoid division by zero
    if len(numbers) == 0:
        return 0
    
    # Recursive helper function to calculate sum
    def recursive_sum(nums, n):
        # Base case for recursion: if n is 0, return 0 (no more elements to add)
        if n == 0:
            return 0
        else:
            # Add last element to sum calculated from rest of the list
            return nums[n-1] + recursive_sum(nums, n-1)
    
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate average by dividing total sum by number of elements
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: Average of positive integers
print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0

# Test case 2: Average with negative numbers included
print(funcImp([-1, -2, -3]))      # Expected output: -2.0

# Test case 3: Average with floating point numbers
print(funcImp([1.5, 2.5, 3.5]))   # Expected output: 2.5

# Test case 4: Single element in the list
print(funcImp([10]))              # Expected output: 10.0

# Test case 5: Empty list should handle gracefully and return zero as per our base condition logic
print(funcImp([]))                # Expected output: 0

# Edge Case test cases can be added here as needed.
```","[1.5, 2.5, 3.5]",2.5,2.5,PASS,TRUE,
8,3,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers and returns their average using recursion.
    
    :param numbers: List[int] - A list of integers or floats.
    :return: float - The average of the numbers in the list.
    """"""
    
    # Base case: if the list is empty, return 0 to avoid division by zero
    if len(numbers) == 0:
        return 0
    
    # Recursive helper function to calculate sum
    def recursive_sum(nums, n):
        # Base case for recursion: if n is 0, return 0 (no more elements to add)
        if n == 0:
            return 0
        else:
            # Add last element to sum calculated from rest of the list
            return nums[n-1] + recursive_sum(nums, n-1)
    
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate average by dividing total sum by number of elements
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: Average of positive integers
print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0

# Test case 2: Average with negative numbers included
print(funcImp([-1, -2, -3]))      # Expected output: -2.0

# Test case 3: Average with floating point numbers
print(funcImp([1.5, 2.5, 3.5]))   # Expected output: 2.5

# Test case 4: Single element in the list
print(funcImp([10]))              # Expected output: 10.0

# Test case 5: Empty list should handle gracefully and return zero as per our base condition logic
print(funcImp([]))                # Expected output: 0

# Edge Case test cases can be added here as needed.
```",[10],10,10,PASS,TRUE,
8,4,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers and returns their average using recursion.
    
    :param numbers: List[int] - A list of integers or floats.
    :return: float - The average of the numbers in the list.
    """"""
    
    # Base case: if the list is empty, return 0 to avoid division by zero
    if len(numbers) == 0:
        return 0
    
    # Recursive helper function to calculate sum
    def recursive_sum(nums, n):
        # Base case for recursion: if n is 0, return 0 (no more elements to add)
        if n == 0:
            return 0
        else:
            # Add last element to sum calculated from rest of the list
            return nums[n-1] + recursive_sum(nums, n-1)
    
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate average by dividing total sum by number of elements
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify that funcImp works correctly

# Test case 1: Average of positive integers
print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0

# Test case 2: Average with negative numbers included
print(funcImp([-1, -2, -3]))      # Expected output: -2.0

# Test case 3: Average with floating point numbers
print(funcImp([1.5, 2.5, 3.5]))   # Expected output: 2.5

# Test case 4: Single element in the list
print(funcImp([10]))              # Expected output: 10.0

# Test case 5: Empty list should handle gracefully and return zero as per our base condition logic
print(funcImp([]))                # Expected output: 0

# Edge Case test cases can be added here as needed.
```",[],0,0,PASS,TRUE,
9,0,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions.
    
    :param numbers: List of numbers (integers or floats)
    :return: The average value as a float
    """"""
    # Initialize variables to store the sum and count of numbers
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        total_sum += number  # Add each number to total_sum
        count += 1          # Increment count for each number
    
    # If there are no numbers, return None to indicate no average can be calculated
    if count == 0:
        return None
    
    # Calculate and return the average as total_sum divided by count
    return total_sum / count

# Test cases to verify that funcImp works correctly

# Test case 1: A normal list of positive integers
numbers1 = [10, 20, 30, 40, 50]
print(""Test Case 1:"", funcImp(numbers1))  # Expected output: 30.0

# Test case 2: A list with negative and positive integers
numbers2 = [-10, -20, -30, -40, -50]
print(""Test Case 2:"", funcImp(numbers2))  # Expected output: -30.0

# Test case 3: A mixed list with both integers and floats
numbers3 = [1.5, 2.5, -3.5]
print(""Test Case 3:"", funcImp(numbers3))   # Expected output: ~0.1667

# Test case 4: An empty list should return None since there's no average to calculate
numbers4 = []
print(""Test Case 4:"", funcImp(numbers4))   # Expected output: None

# Test case 5: A single element list should return that element itself as an average
numbers5 = [42]
print(""Test Case 5:"", funcImp(numbers5))   # Expected output: 42.0

# Test case 6: A large range of numbers including zeroes 
numbers6 = [0, -1000000, +1000000]
print(""Test Case 6:"", funcImp(numbers6))   # Expected output: ~0.0

```","[10, 20, 30, 40, 50]",30,30,PASS,TRUE,
9,1,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions.
    
    :param numbers: List of numbers (integers or floats)
    :return: The average value as a float
    """"""
    # Initialize variables to store the sum and count of numbers
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        total_sum += number  # Add each number to total_sum
        count += 1          # Increment count for each number
    
    # If there are no numbers, return None to indicate no average can be calculated
    if count == 0:
        return None
    
    # Calculate and return the average as total_sum divided by count
    return total_sum / count

# Test cases to verify that funcImp works correctly

# Test case 1: A normal list of positive integers
numbers1 = [10, 20, 30, 40, 50]
print(""Test Case 1:"", funcImp(numbers1))  # Expected output: 30.0

# Test case 2: A list with negative and positive integers
numbers2 = [-10, -20, -30, -40, -50]
print(""Test Case 2:"", funcImp(numbers2))  # Expected output: -30.0

# Test case 3: A mixed list with both integers and floats
numbers3 = [1.5, 2.5, -3.5]
print(""Test Case 3:"", funcImp(numbers3))   # Expected output: ~0.1667

# Test case 4: An empty list should return None since there's no average to calculate
numbers4 = []
print(""Test Case 4:"", funcImp(numbers4))   # Expected output: None

# Test case 5: A single element list should return that element itself as an average
numbers5 = [42]
print(""Test Case 5:"", funcImp(numbers5))   # Expected output: 42.0

# Test case 6: A large range of numbers including zeroes 
numbers6 = [0, -1000000, +1000000]
print(""Test Case 6:"", funcImp(numbers6))   # Expected output: ~0.0

```","[-10, -20, -30, -40, -50]",-30,-30,PASS,TRUE,
9,2,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions.
    
    :param numbers: List of numbers (integers or floats)
    :return: The average value as a float
    """"""
    # Initialize variables to store the sum and count of numbers
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        total_sum += number  # Add each number to total_sum
        count += 1          # Increment count for each number
    
    # If there are no numbers, return None to indicate no average can be calculated
    if count == 0:
        return None
    
    # Calculate and return the average as total_sum divided by count
    return total_sum / count

# Test cases to verify that funcImp works correctly

# Test case 1: A normal list of positive integers
numbers1 = [10, 20, 30, 40, 50]
print(""Test Case 1:"", funcImp(numbers1))  # Expected output: 30.0

# Test case 2: A list with negative and positive integers
numbers2 = [-10, -20, -30, -40, -50]
print(""Test Case 2:"", funcImp(numbers2))  # Expected output: -30.0

# Test case 3: A mixed list with both integers and floats
numbers3 = [1.5, 2.5, -3.5]
print(""Test Case 3:"", funcImp(numbers3))   # Expected output: ~0.1667

# Test case 4: An empty list should return None since there's no average to calculate
numbers4 = []
print(""Test Case 4:"", funcImp(numbers4))   # Expected output: None

# Test case 5: A single element list should return that element itself as an average
numbers5 = [42]
print(""Test Case 5:"", funcImp(numbers5))   # Expected output: 42.0

# Test case 6: A large range of numbers including zeroes 
numbers6 = [0, -1000000, +1000000]
print(""Test Case 6:"", funcImp(numbers6))   # Expected output: ~0.0

```","[1.5, 2.5, -3.5]",0.166666667,0.166666667,PASS,TRUE,
9,3,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions.
    
    :param numbers: List of numbers (integers or floats)
    :return: The average value as a float
    """"""
    # Initialize variables to store the sum and count of numbers
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        total_sum += number  # Add each number to total_sum
        count += 1          # Increment count for each number
    
    # If there are no numbers, return None to indicate no average can be calculated
    if count == 0:
        return None
    
    # Calculate and return the average as total_sum divided by count
    return total_sum / count

# Test cases to verify that funcImp works correctly

# Test case 1: A normal list of positive integers
numbers1 = [10, 20, 30, 40, 50]
print(""Test Case 1:"", funcImp(numbers1))  # Expected output: 30.0

# Test case 2: A list with negative and positive integers
numbers2 = [-10, -20, -30, -40, -50]
print(""Test Case 2:"", funcImp(numbers2))  # Expected output: -30.0

# Test case 3: A mixed list with both integers and floats
numbers3 = [1.5, 2.5, -3.5]
print(""Test Case 3:"", funcImp(numbers3))   # Expected output: ~0.1667

# Test case 4: An empty list should return None since there's no average to calculate
numbers4 = []
print(""Test Case 4:"", funcImp(numbers4))   # Expected output: None

# Test case 5: A single element list should return that element itself as an average
numbers5 = [42]
print(""Test Case 5:"", funcImp(numbers5))   # Expected output: 42.0

# Test case 6: A large range of numbers including zeroes 
numbers6 = [0, -1000000, +1000000]
print(""Test Case 6:"", funcImp(numbers6))   # Expected output: ~0.0

```",[],None,None,PASS,TRUE,
9,4,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions.
    
    :param numbers: List of numbers (integers or floats)
    :return: The average value as a float
    """"""
    # Initialize variables to store the sum and count of numbers
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        total_sum += number  # Add each number to total_sum
        count += 1          # Increment count for each number
    
    # If there are no numbers, return None to indicate no average can be calculated
    if count == 0:
        return None
    
    # Calculate and return the average as total_sum divided by count
    return total_sum / count

# Test cases to verify that funcImp works correctly

# Test case 1: A normal list of positive integers
numbers1 = [10, 20, 30, 40, 50]
print(""Test Case 1:"", funcImp(numbers1))  # Expected output: 30.0

# Test case 2: A list with negative and positive integers
numbers2 = [-10, -20, -30, -40, -50]
print(""Test Case 2:"", funcImp(numbers2))  # Expected output: -30.0

# Test case 3: A mixed list with both integers and floats
numbers3 = [1.5, 2.5, -3.5]
print(""Test Case 3:"", funcImp(numbers3))   # Expected output: ~0.1667

# Test case 4: An empty list should return None since there's no average to calculate
numbers4 = []
print(""Test Case 4:"", funcImp(numbers4))   # Expected output: None

# Test case 5: A single element list should return that element itself as an average
numbers5 = [42]
print(""Test Case 5:"", funcImp(numbers5))   # Expected output: 42.0

# Test case 6: A large range of numbers including zeroes 
numbers6 = [0, -1000000, +1000000]
print(""Test Case 6:"", funcImp(numbers6))   # Expected output: ~0.0

```",[42],42,42,PASS,TRUE,
9,5,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions.
    
    :param numbers: List of numbers (integers or floats)
    :return: The average value as a float
    """"""
    # Initialize variables to store the sum and count of numbers
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        total_sum += number  # Add each number to total_sum
        count += 1          # Increment count for each number
    
    # If there are no numbers, return None to indicate no average can be calculated
    if count == 0:
        return None
    
    # Calculate and return the average as total_sum divided by count
    return total_sum / count

# Test cases to verify that funcImp works correctly

# Test case 1: A normal list of positive integers
numbers1 = [10, 20, 30, 40, 50]
print(""Test Case 1:"", funcImp(numbers1))  # Expected output: 30.0

# Test case 2: A list with negative and positive integers
numbers2 = [-10, -20, -30, -40, -50]
print(""Test Case 2:"", funcImp(numbers2))  # Expected output: -30.0

# Test case 3: A mixed list with both integers and floats
numbers3 = [1.5, 2.5, -3.5]
print(""Test Case 3:"", funcImp(numbers3))   # Expected output: ~0.1667

# Test case 4: An empty list should return None since there's no average to calculate
numbers4 = []
print(""Test Case 4:"", funcImp(numbers4))   # Expected output: None

# Test case 5: A single element list should return that element itself as an average
numbers5 = [42]
print(""Test Case 5:"", funcImp(numbers5))   # Expected output: 42.0

# Test case 6: A large range of numbers including zeroes 
numbers6 = [0, -1000000, +1000000]
print(""Test Case 6:"", funcImp(numbers6))   # Expected output: ~0.0

```","[0, -1000000, 1000000]",0,0,PASS,TRUE,
10,0,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers, ignoring invalid entries.
    
    Parameters:
    - numbers: A list that may contain numeric and non-numeric values.
    
    Returns:
    - The average of valid numeric entries in the list. If no valid numbers are present,
      return None to indicate that an average cannot be computed.
    """"""
    
    # Filter out non-numeric values
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    # Check if there are any valid numbers
    if not valid_numbers:
        return None  # Return None if no valid numbers are found
    
    # Calculate and return the average
    return sum(valid_numbers) / len(valid_numbers)

# Test cases to verify the correctness of funcImp

# Test case 1: Normal case with integers and floats
print(funcImp([1, 2, 3.5]))  # Expected output: 2.166...

# Test case 2: List with some invalid entries
print(funcImp([1, 'a', 3.5]))  # Expected output: 2.25

# Test case 3: List with all invalid entries
print(funcImp(['a', 'b', 'c']))  # Expected output: None

# Test case 4: Empty list
print(funcImp([]))  # Expected output: None

# Test case 5: List with only one number
print(funcImp([10]))  # Expected output: 10.0

# Test case 6: Mixed types including special characters and strings
print(funcImp([10, 'hello', '@', {}, [], (), True]))  # Expected output should consider True as a number (1), so it would be (10 + 1) / 2 = 5.5

```","[1, 2, 3.5]",2.166666667,2.166666667,PASS,TRUE,
10,1,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers, ignoring invalid entries.
    
    Parameters:
    - numbers: A list that may contain numeric and non-numeric values.
    
    Returns:
    - The average of valid numeric entries in the list. If no valid numbers are present,
      return None to indicate that an average cannot be computed.
    """"""
    
    # Filter out non-numeric values
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    # Check if there are any valid numbers
    if not valid_numbers:
        return None  # Return None if no valid numbers are found
    
    # Calculate and return the average
    return sum(valid_numbers) / len(valid_numbers)

# Test cases to verify the correctness of funcImp

# Test case 1: Normal case with integers and floats
print(funcImp([1, 2, 3.5]))  # Expected output: 2.166...

# Test case 2: List with some invalid entries
print(funcImp([1, 'a', 3.5]))  # Expected output: 2.25

# Test case 3: List with all invalid entries
print(funcImp(['a', 'b', 'c']))  # Expected output: None

# Test case 4: Empty list
print(funcImp([]))  # Expected output: None

# Test case 5: List with only one number
print(funcImp([10]))  # Expected output: 10.0

# Test case 6: Mixed types including special characters and strings
print(funcImp([10, 'hello', '@', {}, [], (), True]))  # Expected output should consider True as a number (1), so it would be (10 + 1) / 2 = 5.5

```","[1, 'a', 3.5]",2.25,2.25,PASS,TRUE,
10,2,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers, ignoring invalid entries.
    
    Parameters:
    - numbers: A list that may contain numeric and non-numeric values.
    
    Returns:
    - The average of valid numeric entries in the list. If no valid numbers are present,
      return None to indicate that an average cannot be computed.
    """"""
    
    # Filter out non-numeric values
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    # Check if there are any valid numbers
    if not valid_numbers:
        return None  # Return None if no valid numbers are found
    
    # Calculate and return the average
    return sum(valid_numbers) / len(valid_numbers)

# Test cases to verify the correctness of funcImp

# Test case 1: Normal case with integers and floats
print(funcImp([1, 2, 3.5]))  # Expected output: 2.166...

# Test case 2: List with some invalid entries
print(funcImp([1, 'a', 3.5]))  # Expected output: 2.25

# Test case 3: List with all invalid entries
print(funcImp(['a', 'b', 'c']))  # Expected output: None

# Test case 4: Empty list
print(funcImp([]))  # Expected output: None

# Test case 5: List with only one number
print(funcImp([10]))  # Expected output: 10.0

# Test case 6: Mixed types including special characters and strings
print(funcImp([10, 'hello', '@', {}, [], (), True]))  # Expected output should consider True as a number (1), so it would be (10 + 1) / 2 = 5.5

```","['a', 'b', 'c']",None,None,PASS,TRUE,
10,3,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers, ignoring invalid entries.
    
    Parameters:
    - numbers: A list that may contain numeric and non-numeric values.
    
    Returns:
    - The average of valid numeric entries in the list. If no valid numbers are present,
      return None to indicate that an average cannot be computed.
    """"""
    
    # Filter out non-numeric values
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    # Check if there are any valid numbers
    if not valid_numbers:
        return None  # Return None if no valid numbers are found
    
    # Calculate and return the average
    return sum(valid_numbers) / len(valid_numbers)

# Test cases to verify the correctness of funcImp

# Test case 1: Normal case with integers and floats
print(funcImp([1, 2, 3.5]))  # Expected output: 2.166...

# Test case 2: List with some invalid entries
print(funcImp([1, 'a', 3.5]))  # Expected output: 2.25

# Test case 3: List with all invalid entries
print(funcImp(['a', 'b', 'c']))  # Expected output: None

# Test case 4: Empty list
print(funcImp([]))  # Expected output: None

# Test case 5: List with only one number
print(funcImp([10]))  # Expected output: 10.0

# Test case 6: Mixed types including special characters and strings
print(funcImp([10, 'hello', '@', {}, [], (), True]))  # Expected output should consider True as a number (1), so it would be (10 + 1) / 2 = 5.5

```",[],None,None,PASS,TRUE,
10,4,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers, ignoring invalid entries.
    
    Parameters:
    - numbers: A list that may contain numeric and non-numeric values.
    
    Returns:
    - The average of valid numeric entries in the list. If no valid numbers are present,
      return None to indicate that an average cannot be computed.
    """"""
    
    # Filter out non-numeric values
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    # Check if there are any valid numbers
    if not valid_numbers:
        return None  # Return None if no valid numbers are found
    
    # Calculate and return the average
    return sum(valid_numbers) / len(valid_numbers)

# Test cases to verify the correctness of funcImp

# Test case 1: Normal case with integers and floats
print(funcImp([1, 2, 3.5]))  # Expected output: 2.166...

# Test case 2: List with some invalid entries
print(funcImp([1, 'a', 3.5]))  # Expected output: 2.25

# Test case 3: List with all invalid entries
print(funcImp(['a', 'b', 'c']))  # Expected output: None

# Test case 4: Empty list
print(funcImp([]))  # Expected output: None

# Test case 5: List with only one number
print(funcImp([10]))  # Expected output: 10.0

# Test case 6: Mixed types including special characters and strings
print(funcImp([10, 'hello', '@', {}, [], (), True]))  # Expected output should consider True as a number (1), so it would be (10 + 1) / 2 = 5.5

```",[10],10,10,PASS,TRUE,
10,5,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers, ignoring invalid entries.
    
    Parameters:
    - numbers: A list that may contain numeric and non-numeric values.
    
    Returns:
    - The average of valid numeric entries in the list. If no valid numbers are present,
      return None to indicate that an average cannot be computed.
    """"""
    
    # Filter out non-numeric values
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    # Check if there are any valid numbers
    if not valid_numbers:
        return None  # Return None if no valid numbers are found
    
    # Calculate and return the average
    return sum(valid_numbers) / len(valid_numbers)

# Test cases to verify the correctness of funcImp

# Test case 1: Normal case with integers and floats
print(funcImp([1, 2, 3.5]))  # Expected output: 2.166...

# Test case 2: List with some invalid entries
print(funcImp([1, 'a', 3.5]))  # Expected output: 2.25

# Test case 3: List with all invalid entries
print(funcImp(['a', 'b', 'c']))  # Expected output: None

# Test case 4: Empty list
print(funcImp([]))  # Expected output: None

# Test case 5: List with only one number
print(funcImp([10]))  # Expected output: 10.0

# Test case 6: Mixed types including special characters and strings
print(funcImp([10, 'hello', '@', {}, [], (), True]))  # Expected output should consider True as a number (1), so it would be (10 + 1) / 2 = 5.5

```","[10, 'hello', '@', {}, [], (), True]",5.5,5.5,PASS,TRUE,
11,0,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.
    
    Parameters:
    - numbers: A list of numerical values.
    - weights: A list of weights corresponding to each number in 'numbers'.
    
    Returns:
    - The weighted average as a float.
    
    Raises:
    - ValueError: If 'numbers' and 'weights' do not have the same length or if any weight is negative.
    """"""
    
    # Check if both lists have the same length
    if len(numbers) != len(weights):
        raise ValueError(""The lists 'numbers' and 'weights' must have the same length."")
    
    # Check for negative weights
    if any(weight < 0 for weight in weights):
        raise ValueError(""Weights cannot be negative."")
    
    # Calculate the sum of products of numbers and their respective weights
    total_weighted_sum = sum(number * weight for number, weight in zip(numbers, weights))
    
    # Calculate the sum of all weights
    total_weight = sum(weights)
    
    # Avoid division by zero by checking if total_weight is zero
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    # Calculate and return the weighted average
    return total_weighted_sum / total_weight

# Test cases to verify that funcImp works correctly

# Test case 1: Simple case with positive integers
numbers1 = [10, 20, 30]
weights1 = [1, 2, 3]
print(funcImp(numbers1, weights1))  # Expected output: (10*1 + 20*2 + 30*3) / (1+2+3) = 23.333...

# Test case 2: All equal numbers with different weights
numbers2 = [5, 5, 5]
weights2 = [1, 4, 5]
print(funcImp(numbers2, weights2))  # Expected output: (5*10) / (10) = 5.0

# Test case 3: Zero weight should not affect result significantly
numbers3 = [100, -50]
weights3 = [0.7, 0.3]
print(funcImp(numbers3, weights3))   # Expected output: (100*0.7 + (-50)*0.3) / (0.7+0.3) = ~55

# Test case 4: Edge case with empty lists
try:
    print(funcImp([], []))           # Should raise an error due to division by zero or invalid input size.
except ValueError as e:
    print(e)

# Test case 5: Edge case with one element having full weight
numbers4 = [42]
weights4 = [1]
print(funcImp(numbers4, weights4))   # Expected output: The number itself i.e., 42

```","([10, 20, 30], [1, 2, 3])",23.33333333,23.33333333,PASS,TRUE,
11,1,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.
    
    Parameters:
    - numbers: A list of numerical values.
    - weights: A list of weights corresponding to each number in 'numbers'.
    
    Returns:
    - The weighted average as a float.
    
    Raises:
    - ValueError: If 'numbers' and 'weights' do not have the same length or if any weight is negative.
    """"""
    
    # Check if both lists have the same length
    if len(numbers) != len(weights):
        raise ValueError(""The lists 'numbers' and 'weights' must have the same length."")
    
    # Check for negative weights
    if any(weight < 0 for weight in weights):
        raise ValueError(""Weights cannot be negative."")
    
    # Calculate the sum of products of numbers and their respective weights
    total_weighted_sum = sum(number * weight for number, weight in zip(numbers, weights))
    
    # Calculate the sum of all weights
    total_weight = sum(weights)
    
    # Avoid division by zero by checking if total_weight is zero
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    # Calculate and return the weighted average
    return total_weighted_sum / total_weight

# Test cases to verify that funcImp works correctly

# Test case 1: Simple case with positive integers
numbers1 = [10, 20, 30]
weights1 = [1, 2, 3]
print(funcImp(numbers1, weights1))  # Expected output: (10*1 + 20*2 + 30*3) / (1+2+3) = 23.333...

# Test case 2: All equal numbers with different weights
numbers2 = [5, 5, 5]
weights2 = [1, 4, 5]
print(funcImp(numbers2, weights2))  # Expected output: (5*10) / (10) = 5.0

# Test case 3: Zero weight should not affect result significantly
numbers3 = [100, -50]
weights3 = [0.7, 0.3]
print(funcImp(numbers3, weights3))   # Expected output: (100*0.7 + (-50)*0.3) / (0.7+0.3) = ~55

# Test case 4: Edge case with empty lists
try:
    print(funcImp([], []))           # Should raise an error due to division by zero or invalid input size.
except ValueError as e:
    print(e)

# Test case 5: Edge case with one element having full weight
numbers4 = [42]
weights4 = [1]
print(funcImp(numbers4, weights4))   # Expected output: The number itself i.e., 42

```","([5, 5, 5], [1, 4, 5])",5,5,PASS,TRUE,
11,2,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.
    
    Parameters:
    - numbers: A list of numerical values.
    - weights: A list of weights corresponding to each number in 'numbers'.
    
    Returns:
    - The weighted average as a float.
    
    Raises:
    - ValueError: If 'numbers' and 'weights' do not have the same length or if any weight is negative.
    """"""
    
    # Check if both lists have the same length
    if len(numbers) != len(weights):
        raise ValueError(""The lists 'numbers' and 'weights' must have the same length."")
    
    # Check for negative weights
    if any(weight < 0 for weight in weights):
        raise ValueError(""Weights cannot be negative."")
    
    # Calculate the sum of products of numbers and their respective weights
    total_weighted_sum = sum(number * weight for number, weight in zip(numbers, weights))
    
    # Calculate the sum of all weights
    total_weight = sum(weights)
    
    # Avoid division by zero by checking if total_weight is zero
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    # Calculate and return the weighted average
    return total_weighted_sum / total_weight

# Test cases to verify that funcImp works correctly

# Test case 1: Simple case with positive integers
numbers1 = [10, 20, 30]
weights1 = [1, 2, 3]
print(funcImp(numbers1, weights1))  # Expected output: (10*1 + 20*2 + 30*3) / (1+2+3) = 23.333...

# Test case 2: All equal numbers with different weights
numbers2 = [5, 5, 5]
weights2 = [1, 4, 5]
print(funcImp(numbers2, weights2))  # Expected output: (5*10) / (10) = 5.0

# Test case 3: Zero weight should not affect result significantly
numbers3 = [100, -50]
weights3 = [0.7, 0.3]
print(funcImp(numbers3, weights3))   # Expected output: (100*0.7 + (-50)*0.3) / (0.7+0.3) = ~55

# Test case 4: Edge case with empty lists
try:
    print(funcImp([], []))           # Should raise an error due to division by zero or invalid input size.
except ValueError as e:
    print(e)

# Test case 5: Edge case with one element having full weight
numbers4 = [42]
weights4 = [1]
print(funcImp(numbers4, weights4))   # Expected output: The number itself i.e., 42

```","([100, -50], [0.7, 0.3])",55,55,PASS,TRUE,
11,3,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.
    
    Parameters:
    - numbers: A list of numerical values.
    - weights: A list of weights corresponding to each number in 'numbers'.
    
    Returns:
    - The weighted average as a float.
    
    Raises:
    - ValueError: If 'numbers' and 'weights' do not have the same length or if any weight is negative.
    """"""
    
    # Check if both lists have the same length
    if len(numbers) != len(weights):
        raise ValueError(""The lists 'numbers' and 'weights' must have the same length."")
    
    # Check for negative weights
    if any(weight < 0 for weight in weights):
        raise ValueError(""Weights cannot be negative."")
    
    # Calculate the sum of products of numbers and their respective weights
    total_weighted_sum = sum(number * weight for number, weight in zip(numbers, weights))
    
    # Calculate the sum of all weights
    total_weight = sum(weights)
    
    # Avoid division by zero by checking if total_weight is zero
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    # Calculate and return the weighted average
    return total_weighted_sum / total_weight

# Test cases to verify that funcImp works correctly

# Test case 1: Simple case with positive integers
numbers1 = [10, 20, 30]
weights1 = [1, 2, 3]
print(funcImp(numbers1, weights1))  # Expected output: (10*1 + 20*2 + 30*3) / (1+2+3) = 23.333...

# Test case 2: All equal numbers with different weights
numbers2 = [5, 5, 5]
weights2 = [1, 4, 5]
print(funcImp(numbers2, weights2))  # Expected output: (5*10) / (10) = 5.0

# Test case 3: Zero weight should not affect result significantly
numbers3 = [100, -50]
weights3 = [0.7, 0.3]
print(funcImp(numbers3, weights3))   # Expected output: (100*0.7 + (-50)*0.3) / (0.7+0.3) = ~55

# Test case 4: Edge case with empty lists
try:
    print(funcImp([], []))           # Should raise an error due to division by zero or invalid input size.
except ValueError as e:
    print(e)

# Test case 5: Edge case with one element having full weight
numbers4 = [42]
weights4 = [1]
print(funcImp(numbers4, weights4))   # Expected output: The number itself i.e., 42

```","([], [])",55,,PASS,TRUE,The sum of weights must not be zero.
11,4,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.
    
    Parameters:
    - numbers: A list of numerical values.
    - weights: A list of weights corresponding to each number in 'numbers'.
    
    Returns:
    - The weighted average as a float.
    
    Raises:
    - ValueError: If 'numbers' and 'weights' do not have the same length or if any weight is negative.
    """"""
    
    # Check if both lists have the same length
    if len(numbers) != len(weights):
        raise ValueError(""The lists 'numbers' and 'weights' must have the same length."")
    
    # Check for negative weights
    if any(weight < 0 for weight in weights):
        raise ValueError(""Weights cannot be negative."")
    
    # Calculate the sum of products of numbers and their respective weights
    total_weighted_sum = sum(number * weight for number, weight in zip(numbers, weights))
    
    # Calculate the sum of all weights
    total_weight = sum(weights)
    
    # Avoid division by zero by checking if total_weight is zero
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    # Calculate and return the weighted average
    return total_weighted_sum / total_weight

# Test cases to verify that funcImp works correctly

# Test case 1: Simple case with positive integers
numbers1 = [10, 20, 30]
weights1 = [1, 2, 3]
print(funcImp(numbers1, weights1))  # Expected output: (10*1 + 20*2 + 30*3) / (1+2+3) = 23.333...

# Test case 2: All equal numbers with different weights
numbers2 = [5, 5, 5]
weights2 = [1, 4, 5]
print(funcImp(numbers2, weights2))  # Expected output: (5*10) / (10) = 5.0

# Test case 3: Zero weight should not affect result significantly
numbers3 = [100, -50]
weights3 = [0.7, 0.3]
print(funcImp(numbers3, weights3))   # Expected output: (100*0.7 + (-50)*0.3) / (0.7+0.3) = ~55

# Test case 4: Edge case with empty lists
try:
    print(funcImp([], []))           # Should raise an error due to division by zero or invalid input size.
except ValueError as e:
    print(e)

# Test case 5: Edge case with one element having full weight
numbers4 = [42]
weights4 = [1]
print(funcImp(numbers4, weights4))   # Expected output: The number itself i.e., 42

```","([42], [1])",42,42,PASS,TRUE,
12,0,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers, finds its median,
    and calculates the average of all numbers greater than or equal to this median.
    
    :param numbers: List[int] - A list of integers
    :return: float - The average of numbers greater than or equal to the median
    """"""
    
    if not numbers:
        raise ValueError(""The input list cannot be empty."")
    
    # Step 1: Sort the list
    sorted_numbers = sorted(numbers)
    
    # Step 2: Find the median
    n = len(sorted_numbers)
    
    if n % 2 == 1:
        # Odd number of elements, take middle one
        median = sorted_numbers[n // 2]
    else:
        # Even number of elements, take average of two middle ones
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    
    # Step 3: Calculate average for values >= median
    greater_or_equal_to_median = [num for num in sorted_numbers if num >= median]
    
    if not greater_or_equal_to_median:
        return None
    
    avg_greater_or_equal_to_median = sum(greater_or_equal_to_median) / len(greater_or_equal_to_median)
    
    return avg_greater_or_equal_to_median

# Test cases to verify our solution

# Test case with an odd number of elements
print(funcImp([3, 5, 7]))          # Median is 5; Average >= Median is (5+7)/2 = 6.0

# Test case with an even number of elements
print(funcImp([10, 20, 30, 40]))   # Median is (20+30)/2=25; Average >= Median is (30+40)/2=35.0

# Test case with negative and positive numbers
print(funcImp([-10, -5, 0, 5, 10])) # Median is 0; Average >= Median is (0+5+10)/3=5.0

# Edge test case with single element
print(funcImp([42]))               # Only one element which is also its own median; Average >= Median is just that element itself i.e.,42

# Edge test case with identical elements 
print(funcImp([4,4,4]))            # All are same so any subset will have same value; Expected output should be same as any element i.e.,4

```","[3, 5, 7]",6,6,PASS,TRUE,
12,1,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers, finds its median,
    and calculates the average of all numbers greater than or equal to this median.
    
    :param numbers: List[int] - A list of integers
    :return: float - The average of numbers greater than or equal to the median
    """"""
    
    if not numbers:
        raise ValueError(""The input list cannot be empty."")
    
    # Step 1: Sort the list
    sorted_numbers = sorted(numbers)
    
    # Step 2: Find the median
    n = len(sorted_numbers)
    
    if n % 2 == 1:
        # Odd number of elements, take middle one
        median = sorted_numbers[n // 2]
    else:
        # Even number of elements, take average of two middle ones
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    
    # Step 3: Calculate average for values >= median
    greater_or_equal_to_median = [num for num in sorted_numbers if num >= median]
    
    if not greater_or_equal_to_median:
        return None
    
    avg_greater_or_equal_to_median = sum(greater_or_equal_to_median) / len(greater_or_equal_to_median)
    
    return avg_greater_or_equal_to_median

# Test cases to verify our solution

# Test case with an odd number of elements
print(funcImp([3, 5, 7]))          # Median is 5; Average >= Median is (5+7)/2 = 6.0

# Test case with an even number of elements
print(funcImp([10, 20, 30, 40]))   # Median is (20+30)/2=25; Average >= Median is (30+40)/2=35.0

# Test case with negative and positive numbers
print(funcImp([-10, -5, 0, 5, 10])) # Median is 0; Average >= Median is (0+5+10)/3=5.0

# Edge test case with single element
print(funcImp([42]))               # Only one element which is also its own median; Average >= Median is just that element itself i.e.,42

# Edge test case with identical elements 
print(funcImp([4,4,4]))            # All are same so any subset will have same value; Expected output should be same as any element i.e.,4

```","[10, 20, 30, 40]",35,35,PASS,TRUE,
12,2,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers, finds its median,
    and calculates the average of all numbers greater than or equal to this median.
    
    :param numbers: List[int] - A list of integers
    :return: float - The average of numbers greater than or equal to the median
    """"""
    
    if not numbers:
        raise ValueError(""The input list cannot be empty."")
    
    # Step 1: Sort the list
    sorted_numbers = sorted(numbers)
    
    # Step 2: Find the median
    n = len(sorted_numbers)
    
    if n % 2 == 1:
        # Odd number of elements, take middle one
        median = sorted_numbers[n // 2]
    else:
        # Even number of elements, take average of two middle ones
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    
    # Step 3: Calculate average for values >= median
    greater_or_equal_to_median = [num for num in sorted_numbers if num >= median]
    
    if not greater_or_equal_to_median:
        return None
    
    avg_greater_or_equal_to_median = sum(greater_or_equal_to_median) / len(greater_or_equal_to_median)
    
    return avg_greater_or_equal_to_median

# Test cases to verify our solution

# Test case with an odd number of elements
print(funcImp([3, 5, 7]))          # Median is 5; Average >= Median is (5+7)/2 = 6.0

# Test case with an even number of elements
print(funcImp([10, 20, 30, 40]))   # Median is (20+30)/2=25; Average >= Median is (30+40)/2=35.0

# Test case with negative and positive numbers
print(funcImp([-10, -5, 0, 5, 10])) # Median is 0; Average >= Median is (0+5+10)/3=5.0

# Edge test case with single element
print(funcImp([42]))               # Only one element which is also its own median; Average >= Median is just that element itself i.e.,42

# Edge test case with identical elements 
print(funcImp([4,4,4]))            # All are same so any subset will have same value; Expected output should be same as any element i.e.,4

```","[-10, -5, 0, 5, 10]",5,5,PASS,TRUE,
12,3,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers, finds its median,
    and calculates the average of all numbers greater than or equal to this median.
    
    :param numbers: List[int] - A list of integers
    :return: float - The average of numbers greater than or equal to the median
    """"""
    
    if not numbers:
        raise ValueError(""The input list cannot be empty."")
    
    # Step 1: Sort the list
    sorted_numbers = sorted(numbers)
    
    # Step 2: Find the median
    n = len(sorted_numbers)
    
    if n % 2 == 1:
        # Odd number of elements, take middle one
        median = sorted_numbers[n // 2]
    else:
        # Even number of elements, take average of two middle ones
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    
    # Step 3: Calculate average for values >= median
    greater_or_equal_to_median = [num for num in sorted_numbers if num >= median]
    
    if not greater_or_equal_to_median:
        return None
    
    avg_greater_or_equal_to_median = sum(greater_or_equal_to_median) / len(greater_or_equal_to_median)
    
    return avg_greater_or_equal_to_median

# Test cases to verify our solution

# Test case with an odd number of elements
print(funcImp([3, 5, 7]))          # Median is 5; Average >= Median is (5+7)/2 = 6.0

# Test case with an even number of elements
print(funcImp([10, 20, 30, 40]))   # Median is (20+30)/2=25; Average >= Median is (30+40)/2=35.0

# Test case with negative and positive numbers
print(funcImp([-10, -5, 0, 5, 10])) # Median is 0; Average >= Median is (0+5+10)/3=5.0

# Edge test case with single element
print(funcImp([42]))               # Only one element which is also its own median; Average >= Median is just that element itself i.e.,42

# Edge test case with identical elements 
print(funcImp([4,4,4]))            # All are same so any subset will have same value; Expected output should be same as any element i.e.,4

```",[42],42,42,PASS,TRUE,
12,4,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers, finds its median,
    and calculates the average of all numbers greater than or equal to this median.
    
    :param numbers: List[int] - A list of integers
    :return: float - The average of numbers greater than or equal to the median
    """"""
    
    if not numbers:
        raise ValueError(""The input list cannot be empty."")
    
    # Step 1: Sort the list
    sorted_numbers = sorted(numbers)
    
    # Step 2: Find the median
    n = len(sorted_numbers)
    
    if n % 2 == 1:
        # Odd number of elements, take middle one
        median = sorted_numbers[n // 2]
    else:
        # Even number of elements, take average of two middle ones
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    
    # Step 3: Calculate average for values >= median
    greater_or_equal_to_median = [num for num in sorted_numbers if num >= median]
    
    if not greater_or_equal_to_median:
        return None
    
    avg_greater_or_equal_to_median = sum(greater_or_equal_to_median) / len(greater_or_equal_to_median)
    
    return avg_greater_or_equal_to_median

# Test cases to verify our solution

# Test case with an odd number of elements
print(funcImp([3, 5, 7]))          # Median is 5; Average >= Median is (5+7)/2 = 6.0

# Test case with an even number of elements
print(funcImp([10, 20, 30, 40]))   # Median is (20+30)/2=25; Average >= Median is (30+40)/2=35.0

# Test case with negative and positive numbers
print(funcImp([-10, -5, 0, 5, 10])) # Median is 0; Average >= Median is (0+5+10)/3=5.0

# Edge test case with single element
print(funcImp([42]))               # Only one element which is also its own median; Average >= Median is just that element itself i.e.,42

# Edge test case with identical elements 
print(funcImp([4,4,4]))            # All are same so any subset will have same value; Expected output should be same as any element i.e.,4

```","[4, 4, 4]",4,4,PASS,TRUE,
13,0,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average over a sliding window for each element in a given list.
    
    :param numbers: List of numbers to calculate moving averages from.
    :param window_size: Size of the sliding window.
    :return: List of moving averages.
    """"""
    if not numbers or window_size <= 0:
        return []
    
    n = len(numbers)
    if window_size > n:
        return []

    # Initialize variables
    moving_averages = []
    current_sum = sum(numbers[:window_size])
    
    # Calculate initial average
    moving_averages.append(current_sum / window_size)
    
    # Slide through the array
    for i in range(window_size, n):
        current_sum += numbers[i] - numbers[i - window_size]
        moving_averages.append(current_sum / window_size)
        
    return moving_averages

# Test cases to verify correctness
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))  # Expected output: [2.0, 3.0, 4.0]
    print(funcImp([10, 20, 30, 40], 2)) # Expected output: [15.0, 25.0, 35.0]
    print(funcImp([1], 1))              # Expected output: [1.0]
    print(funcImp([], 3))               # Expected output: []
    print(funcImp([5, -5], 2))          # Expected output: [0.0]
    
test_funcImp()
```","numbers=[1, 2, 3, 4, 5], window_size=3","[2.0, 3.0, 4.0]","[2.0, 3.0, 4.0]",PASS,TRUE,
13,1,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average over a sliding window for each element in a given list.
    
    :param numbers: List of numbers to calculate moving averages from.
    :param window_size: Size of the sliding window.
    :return: List of moving averages.
    """"""
    if not numbers or window_size <= 0:
        return []
    
    n = len(numbers)
    if window_size > n:
        return []

    # Initialize variables
    moving_averages = []
    current_sum = sum(numbers[:window_size])
    
    # Calculate initial average
    moving_averages.append(current_sum / window_size)
    
    # Slide through the array
    for i in range(window_size, n):
        current_sum += numbers[i] - numbers[i - window_size]
        moving_averages.append(current_sum / window_size)
        
    return moving_averages

# Test cases to verify correctness
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))  # Expected output: [2.0, 3.0, 4.0]
    print(funcImp([10, 20, 30, 40], 2)) # Expected output: [15.0, 25.0, 35.0]
    print(funcImp([1], 1))              # Expected output: [1.0]
    print(funcImp([], 3))               # Expected output: []
    print(funcImp([5, -5], 2))          # Expected output: [0.0]
    
test_funcImp()
```","numbers=[10, 20, 30, 40], window_size=2","[15.0, 25.0, 35.0]","[15.0, 25.0, 35.0]",PASS,TRUE,
13,2,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average over a sliding window for each element in a given list.
    
    :param numbers: List of numbers to calculate moving averages from.
    :param window_size: Size of the sliding window.
    :return: List of moving averages.
    """"""
    if not numbers or window_size <= 0:
        return []
    
    n = len(numbers)
    if window_size > n:
        return []

    # Initialize variables
    moving_averages = []
    current_sum = sum(numbers[:window_size])
    
    # Calculate initial average
    moving_averages.append(current_sum / window_size)
    
    # Slide through the array
    for i in range(window_size, n):
        current_sum += numbers[i] - numbers[i - window_size]
        moving_averages.append(current_sum / window_size)
        
    return moving_averages

# Test cases to verify correctness
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))  # Expected output: [2.0, 3.0, 4.0]
    print(funcImp([10, 20, 30, 40], 2)) # Expected output: [15.0, 25.0, 35.0]
    print(funcImp([1], 1))              # Expected output: [1.0]
    print(funcImp([], 3))               # Expected output: []
    print(funcImp([5, -5], 2))          # Expected output: [0.0]
    
test_funcImp()
```","numbers=[1], window_size=1",[1.0],[1.0],PASS,TRUE,
13,3,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average over a sliding window for each element in a given list.
    
    :param numbers: List of numbers to calculate moving averages from.
    :param window_size: Size of the sliding window.
    :return: List of moving averages.
    """"""
    if not numbers or window_size <= 0:
        return []
    
    n = len(numbers)
    if window_size > n:
        return []

    # Initialize variables
    moving_averages = []
    current_sum = sum(numbers[:window_size])
    
    # Calculate initial average
    moving_averages.append(current_sum / window_size)
    
    # Slide through the array
    for i in range(window_size, n):
        current_sum += numbers[i] - numbers[i - window_size]
        moving_averages.append(current_sum / window_size)
        
    return moving_averages

# Test cases to verify correctness
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))  # Expected output: [2.0, 3.0, 4.0]
    print(funcImp([10, 20, 30, 40], 2)) # Expected output: [15.0, 25.0, 35.0]
    print(funcImp([1], 1))              # Expected output: [1.0]
    print(funcImp([], 3))               # Expected output: []
    print(funcImp([5, -5], 2))          # Expected output: [0.0]
    
test_funcImp()
```","numbers=[], window_size=3",[],[],PASS,TRUE,
13,4,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average over a sliding window for each element in a given list.
    
    :param numbers: List of numbers to calculate moving averages from.
    :param window_size: Size of the sliding window.
    :return: List of moving averages.
    """"""
    if not numbers or window_size <= 0:
        return []
    
    n = len(numbers)
    if window_size > n:
        return []

    # Initialize variables
    moving_averages = []
    current_sum = sum(numbers[:window_size])
    
    # Calculate initial average
    moving_averages.append(current_sum / window_size)
    
    # Slide through the array
    for i in range(window_size, n):
        current_sum += numbers[i] - numbers[i - window_size]
        moving_averages.append(current_sum / window_size)
        
    return moving_averages

# Test cases to verify correctness
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))  # Expected output: [2.0, 3.0, 4.0]
    print(funcImp([10, 20, 30, 40], 2)) # Expected output: [15.0, 25.0, 35.0]
    print(funcImp([1], 1))              # Expected output: [1.0]
    print(funcImp([], 3))               # Expected output: []
    print(funcImp([5, -5], 2))          # Expected output: [0.0]
    
test_funcImp()
```","numbers=[5, -5], window_size=2",[0.0],[0.0],PASS,TRUE,
14,0,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in an array.
    
    Parameters:
    arr (list): A list of numbers (integers or floats).
    
    Returns:
    list: A list containing the running averages up to each position.
    """"""
    if not arr:  # Check if the input array is empty
        return []
    
    running_sum = 0
    running_averages = []
    
    for i, num in enumerate(arr):
        running_sum += num  # Add current number to the running sum
        current_average = running_sum / (i + 1)  # Calculate current average
        running_averages.append(current_average)  # Append to result list
    
    return running_averages

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with positive integers
arr1 = [1, 2, 3, 4]
print(funcImp(arr1))  # Expected output: [1.0, 1.5, 2.0, 2.5]

# Test case 2: Array with negative and positive numbers
arr2 = [-1, -2, -3, -4]
print(funcImp(arr2))  # Expected output: [-1.0, -1.5, -2.0, -2.5]

# Test case 3: Array with a single element
arr3 = [10]
print(funcImp(arr3))  # Expected output: [10.0]

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4))  # Expected output: []

# Test case 5: Array with floating point numbers
arr5 = [1.5, 2.5, -3.0]
print(funcImp(arr5))  # Expected output: [1.5, 2.0, -0.3333333333333333]

# Test case 6: Array with zeros
arr6 = [0, 0, 0]
print(funcImp(arr6))   # Expected output: [0.0, 0.0, 0.0]
```","[1, 2, 3, 4]","[1.0, 1.5, 2.0, 2.5]","[1.0, 1.5, 2.0, 2.5]",PASS,TRUE,
14,1,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in an array.
    
    Parameters:
    arr (list): A list of numbers (integers or floats).
    
    Returns:
    list: A list containing the running averages up to each position.
    """"""
    if not arr:  # Check if the input array is empty
        return []
    
    running_sum = 0
    running_averages = []
    
    for i, num in enumerate(arr):
        running_sum += num  # Add current number to the running sum
        current_average = running_sum / (i + 1)  # Calculate current average
        running_averages.append(current_average)  # Append to result list
    
    return running_averages

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with positive integers
arr1 = [1, 2, 3, 4]
print(funcImp(arr1))  # Expected output: [1.0, 1.5, 2.0, 2.5]

# Test case 2: Array with negative and positive numbers
arr2 = [-1, -2, -3, -4]
print(funcImp(arr2))  # Expected output: [-1.0, -1.5, -2.0, -2.5]

# Test case 3: Array with a single element
arr3 = [10]
print(funcImp(arr3))  # Expected output: [10.0]

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4))  # Expected output: []

# Test case 5: Array with floating point numbers
arr5 = [1.5, 2.5, -3.0]
print(funcImp(arr5))  # Expected output: [1.5, 2.0, -0.3333333333333333]

# Test case 6: Array with zeros
arr6 = [0, 0, 0]
print(funcImp(arr6))   # Expected output: [0.0, 0.0, 0.0]
```","[-1, -2, -3, -4]","[-1.0, -1.5, -2.0, -2.5]","[-1.0, -1.5, -2.0, -2.5]",PASS,TRUE,
14,2,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in an array.
    
    Parameters:
    arr (list): A list of numbers (integers or floats).
    
    Returns:
    list: A list containing the running averages up to each position.
    """"""
    if not arr:  # Check if the input array is empty
        return []
    
    running_sum = 0
    running_averages = []
    
    for i, num in enumerate(arr):
        running_sum += num  # Add current number to the running sum
        current_average = running_sum / (i + 1)  # Calculate current average
        running_averages.append(current_average)  # Append to result list
    
    return running_averages

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with positive integers
arr1 = [1, 2, 3, 4]
print(funcImp(arr1))  # Expected output: [1.0, 1.5, 2.0, 2.5]

# Test case 2: Array with negative and positive numbers
arr2 = [-1, -2, -3, -4]
print(funcImp(arr2))  # Expected output: [-1.0, -1.5, -2.0, -2.5]

# Test case 3: Array with a single element
arr3 = [10]
print(funcImp(arr3))  # Expected output: [10.0]

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4))  # Expected output: []

# Test case 5: Array with floating point numbers
arr5 = [1.5, 2.5, -3.0]
print(funcImp(arr5))  # Expected output: [1.5, 2.0, -0.3333333333333333]

# Test case 6: Array with zeros
arr6 = [0, 0, 0]
print(funcImp(arr6))   # Expected output: [0.0, 0.0, 0.0]
```",[10],[10.0],[10.0],PASS,TRUE,
14,3,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in an array.
    
    Parameters:
    arr (list): A list of numbers (integers or floats).
    
    Returns:
    list: A list containing the running averages up to each position.
    """"""
    if not arr:  # Check if the input array is empty
        return []
    
    running_sum = 0
    running_averages = []
    
    for i, num in enumerate(arr):
        running_sum += num  # Add current number to the running sum
        current_average = running_sum / (i + 1)  # Calculate current average
        running_averages.append(current_average)  # Append to result list
    
    return running_averages

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with positive integers
arr1 = [1, 2, 3, 4]
print(funcImp(arr1))  # Expected output: [1.0, 1.5, 2.0, 2.5]

# Test case 2: Array with negative and positive numbers
arr2 = [-1, -2, -3, -4]
print(funcImp(arr2))  # Expected output: [-1.0, -1.5, -2.0, -2.5]

# Test case 3: Array with a single element
arr3 = [10]
print(funcImp(arr3))  # Expected output: [10.0]

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4))  # Expected output: []

# Test case 5: Array with floating point numbers
arr5 = [1.5, 2.5, -3.0]
print(funcImp(arr5))  # Expected output: [1.5, 2.0, -0.3333333333333333]

# Test case 6: Array with zeros
arr6 = [0, 0, 0]
print(funcImp(arr6))   # Expected output: [0.0, 0.0, 0.0]
```",[],[],[],PASS,TRUE,
14,4,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in an array.
    
    Parameters:
    arr (list): A list of numbers (integers or floats).
    
    Returns:
    list: A list containing the running averages up to each position.
    """"""
    if not arr:  # Check if the input array is empty
        return []
    
    running_sum = 0
    running_averages = []
    
    for i, num in enumerate(arr):
        running_sum += num  # Add current number to the running sum
        current_average = running_sum / (i + 1)  # Calculate current average
        running_averages.append(current_average)  # Append to result list
    
    return running_averages

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with positive integers
arr1 = [1, 2, 3, 4]
print(funcImp(arr1))  # Expected output: [1.0, 1.5, 2.0, 2.5]

# Test case 2: Array with negative and positive numbers
arr2 = [-1, -2, -3, -4]
print(funcImp(arr2))  # Expected output: [-1.0, -1.5, -2.0, -2.5]

# Test case 3: Array with a single element
arr3 = [10]
print(funcImp(arr3))  # Expected output: [10.0]

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4))  # Expected output: []

# Test case 5: Array with floating point numbers
arr5 = [1.5, 2.5, -3.0]
print(funcImp(arr5))  # Expected output: [1.5, 2.0, -0.3333333333333333]

# Test case 6: Array with zeros
arr6 = [0, 0, 0]
print(funcImp(arr6))   # Expected output: [0.0, 0.0, 0.0]
```","[1.5, 2.5, -3.0]","[1.5, 2.0, -0.3333333333333333]","[1.5, 2.0, 0.3333333333333333]",FAIL,FALSE,
14,5,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in an array.
    
    Parameters:
    arr (list): A list of numbers (integers or floats).
    
    Returns:
    list: A list containing the running averages up to each position.
    """"""
    if not arr:  # Check if the input array is empty
        return []
    
    running_sum = 0
    running_averages = []
    
    for i, num in enumerate(arr):
        running_sum += num  # Add current number to the running sum
        current_average = running_sum / (i + 1)  # Calculate current average
        running_averages.append(current_average)  # Append to result list
    
    return running_averages

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with positive integers
arr1 = [1, 2, 3, 4]
print(funcImp(arr1))  # Expected output: [1.0, 1.5, 2.0, 2.5]

# Test case 2: Array with negative and positive numbers
arr2 = [-1, -2, -3, -4]
print(funcImp(arr2))  # Expected output: [-1.0, -1.5, -2.0, -2.5]

# Test case 3: Array with a single element
arr3 = [10]
print(funcImp(arr3))  # Expected output: [10.0]

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4))  # Expected output: []

# Test case 5: Array with floating point numbers
arr5 = [1.5, 2.5, -3.0]
print(funcImp(arr5))  # Expected output: [1.5, 2.0, -0.3333333333333333]

# Test case 6: Array with zeros
arr6 = [0, 0, 0]
print(funcImp(arr6))   # Expected output: [0.0, 0.0, 0.0]
```","[0, 0, 0]","[0.0, 0.0, 0.0]","[0.0, 0.0, 0.0]",PASS,TRUE,
15,0,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",1,FALSE,FALSE,PASS,TRUE,
15,1,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",-10,FALSE,FALSE,PASS,TRUE,
15,2,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",-3,FALSE,FALSE,PASS,TRUE,
15,3,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",-7,FALSE,FALSE,PASS,TRUE,
15,4,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",0,FALSE,FALSE,PASS,TRUE,
15,5,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",1,FALSE,FALSE,PASS,TRUE,
15,6,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",2,TRUE,TRUE,PASS,TRUE,
15,7,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",3,TRUE,TRUE,PASS,TRUE,
15,8,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",4,FALSE,FALSE,PASS,TRUE,
15,9,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",9,FALSE,FALSE,PASS,TRUE,
15,10,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",17,TRUE,TRUE,PASS,TRUE,
15,11,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",19,TRUE,TRUE,PASS,TRUE,
15,12,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",20,FALSE,FALSE,PASS,TRUE,
15,13,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Determine if a given integer n is a prime number.
    
    Parameters:
    n (int): The integer to check for primality.
    
    Returns:
    bool: True if n is a prime number, False otherwise.
    """"""
    # Handle edge cases
    if n <= 1:
        return False
    if n <= 3:
        return True
    
    # Eliminate even numbers greater than 2 and multiples of three
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check for factors from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

# Test cases to verify the correctness of funcImp
test_cases = [1, -10, -3, -7, 
              # Edge cases around small primes
              (0), (1), (2), (3), 
              # Small non-primes
              (4), (9),
              # Larger primes and non-primes
              (17), (19), 
              # Non-prime large numbers with small factors
              (20), 
              # Large known primes for performance testing
              (97)]

# Execute test cases and print results
for num in test_cases:
    print(f""Is {num} a prime? {funcImp(num)}"")
```",97,TRUE,TRUE,PASS,TRUE,
16,0,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given integer n.
    
    Parameters:
    n (int): The integer for which we want to find the next largest prime.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""Helper function to check if a number is prime.""""""
        if num <= 1:
            return False
        if num <= 3:
            return True
        if num % 2 == 0 or num % 3 == 0:
            return False
        i = 5
        while i * i <= num:
            if num % i == 0 or num % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Start checking from n+1 onwards for primes
    candidate = n + 1
    
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify our solution

print(funcImp(10)) # Expected output: 11 (next prime after 10)
print(funcImp(14)) # Expected output: 17 (next prime after 14)
print(funcImp(17)) # Expected output: 19 (next prime after already-prime)
print(funcImp(20)) # Expected output: 23 (next prime after non-prime)
print(funcImp(0)) # Expected output: Smallest possible, which should be at least '2'
```",10,11,11,PASS,TRUE,
16,1,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given integer n.
    
    Parameters:
    n (int): The integer for which we want to find the next largest prime.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""Helper function to check if a number is prime.""""""
        if num <= 1:
            return False
        if num <= 3:
            return True
        if num % 2 == 0 or num % 3 == 0:
            return False
        i = 5
        while i * i <= num:
            if num % i == 0 or num % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Start checking from n+1 onwards for primes
    candidate = n + 1
    
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify our solution

print(funcImp(10)) # Expected output: 11 (next prime after 10)
print(funcImp(14)) # Expected output: 17 (next prime after 14)
print(funcImp(17)) # Expected output: 19 (next prime after already-prime)
print(funcImp(20)) # Expected output: 23 (next prime after non-prime)
print(funcImp(0)) # Expected output: Smallest possible, which should be at least '2'
```",14,17,17,PASS,TRUE,
16,2,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given integer n.
    
    Parameters:
    n (int): The integer for which we want to find the next largest prime.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""Helper function to check if a number is prime.""""""
        if num <= 1:
            return False
        if num <= 3:
            return True
        if num % 2 == 0 or num % 3 == 0:
            return False
        i = 5
        while i * i <= num:
            if num % i == 0 or num % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Start checking from n+1 onwards for primes
    candidate = n + 1
    
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify our solution

print(funcImp(10)) # Expected output: 11 (next prime after 10)
print(funcImp(14)) # Expected output: 17 (next prime after 14)
print(funcImp(17)) # Expected output: 19 (next prime after already-prime)
print(funcImp(20)) # Expected output: 23 (next prime after non-prime)
print(funcImp(0)) # Expected output: Smallest possible, which should be at least '2'
```",17,19,19,PASS,TRUE,
16,3,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given integer n.
    
    Parameters:
    n (int): The integer for which we want to find the next largest prime.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""Helper function to check if a number is prime.""""""
        if num <= 1:
            return False
        if num <= 3:
            return True
        if num % 2 == 0 or num % 3 == 0:
            return False
        i = 5
        while i * i <= num:
            if num % i == 0 or num % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Start checking from n+1 onwards for primes
    candidate = n + 1
    
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify our solution

print(funcImp(10)) # Expected output: 11 (next prime after 10)
print(funcImp(14)) # Expected output: 17 (next prime after 14)
print(funcImp(17)) # Expected output: 19 (next prime after already-prime)
print(funcImp(20)) # Expected output: 23 (next prime after non-prime)
print(funcImp(0)) # Expected output: Smallest possible, which should be at least '2'
```",20,23,23,PASS,TRUE,
16,4,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given integer n.
    
    Parameters:
    n (int): The integer for which we want to find the next largest prime.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""Helper function to check if a number is prime.""""""
        if num <= 1:
            return False
        if num <= 3:
            return True
        if num % 2 == 0 or num % 3 == 0:
            return False
        i = 5
        while i * i <= num:
            if num % i == 0 or num % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Start checking from n+1 onwards for primes
    candidate = n + 1
    
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify our solution

print(funcImp(10)) # Expected output: 11 (next prime after 10)
print(funcImp(14)) # Expected output: 17 (next prime after 14)
print(funcImp(17)) # Expected output: 19 (next prime after already-prime)
print(funcImp(20)) # Expected output: 23 (next prime after non-prime)
print(funcImp(0)) # Expected output: Smallest possible, which should be at least '2'
```",-5,2,2,PASS,TRUE,
17,0,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function finds all prime numbers between 'start' and 'end' (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    List[int]: A list containing all prime numbers between 'start' and 'end'.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # List to store all primes in the given range
    primes = []
    
    # Iterate over each number in the given range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    
    return primes

# Test cases to verify our implementation
print(funcImp(10, 50))   # Expected output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
print(funcImp(1,10))     # Expected output: [2,3,5,7]
print(funcImp(20,30))    # Expected output: [23 ,29]
print(funcImp(50 ,60))   # Expected output: [53 ,59]
```","(10, 50)","[11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","[11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]",PASS,TRUE,
17,1,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function finds all prime numbers between 'start' and 'end' (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    List[int]: A list containing all prime numbers between 'start' and 'end'.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # List to store all primes in the given range
    primes = []
    
    # Iterate over each number in the given range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    
    return primes

# Test cases to verify our implementation
print(funcImp(10, 50))   # Expected output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
print(funcImp(1,10))     # Expected output: [2,3,5,7]
print(funcImp(20,30))    # Expected output: [23 ,29]
print(funcImp(50 ,60))   # Expected output: [53 ,59]
```","(1, 10)","[2, 3, 5, 7]","[2, 3, 5, 7]",PASS,TRUE,
17,2,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function finds all prime numbers between 'start' and 'end' (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    List[int]: A list containing all prime numbers between 'start' and 'end'.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # List to store all primes in the given range
    primes = []
    
    # Iterate over each number in the given range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    
    return primes

# Test cases to verify our implementation
print(funcImp(10, 50))   # Expected output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
print(funcImp(1,10))     # Expected output: [2,3,5,7]
print(funcImp(20,30))    # Expected output: [23 ,29]
print(funcImp(50 ,60))   # Expected output: [53 ,59]
```","(20, 30)","[23, 29]","[23, 29]",PASS,TRUE,
17,3,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function finds all prime numbers between 'start' and 'end' (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    List[int]: A list containing all prime numbers between 'start' and 'end'.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number n is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # List to store all primes in the given range
    primes = []
    
    # Iterate over each number in the given range [start, end]
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    
    return primes

# Test cases to verify our implementation
print(funcImp(10, 50))   # Expected output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
print(funcImp(1,10))     # Expected output: [2,3,5,7]
print(funcImp(20,30))    # Expected output: [23 ,29]
print(funcImp(50 ,60))   # Expected output: [53 ,59]
```","(50, 60)","[53, 59]","[53, 59]",PASS,TRUE,
18,0,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Calculate the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers within the specified range.
    """"""
    
    def is_prime(n):
        """"""Check if a number n is a prime number.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum for primes
    total_sum = 0
    
    # Iterate over each number in the given range
    for num in range(start, end + 1):
        if is_prime(num):
            total_sum += num
    
    return total_sum

# Test cases to verify correctness

# Test case: Range with no primes (e.g., between two non-prime numbers)
print(funcImp(14, 16)) # Expected output: 0

# Test case: Range with some primes (e.g., small known primes)
print(funcImp(10, 20)) # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60

# Test case: Single number which is not prime
print(funcImp(8,8)) # Expected output: 0

# Test case: Single number which is prime
print(funcImp(7,7)) # Expected output: 7

# Edge test case: Large range including many primes 
print(funcImp(1,100)) # Expected output should be calculated manually or using another verified method

```","(14, 16)",0,0,PASS,TRUE,
18,1,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Calculate the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers within the specified range.
    """"""
    
    def is_prime(n):
        """"""Check if a number n is a prime number.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum for primes
    total_sum = 0
    
    # Iterate over each number in the given range
    for num in range(start, end + 1):
        if is_prime(num):
            total_sum += num
    
    return total_sum

# Test cases to verify correctness

# Test case: Range with no primes (e.g., between two non-prime numbers)
print(funcImp(14, 16)) # Expected output: 0

# Test case: Range with some primes (e.g., small known primes)
print(funcImp(10, 20)) # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60

# Test case: Single number which is not prime
print(funcImp(8,8)) # Expected output: 0

# Test case: Single number which is prime
print(funcImp(7,7)) # Expected output: 7

# Edge test case: Large range including many primes 
print(funcImp(1,100)) # Expected output should be calculated manually or using another verified method

```","(10, 20)",60,60,PASS,TRUE,
18,2,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Calculate the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers within the specified range.
    """"""
    
    def is_prime(n):
        """"""Check if a number n is a prime number.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum for primes
    total_sum = 0
    
    # Iterate over each number in the given range
    for num in range(start, end + 1):
        if is_prime(num):
            total_sum += num
    
    return total_sum

# Test cases to verify correctness

# Test case: Range with no primes (e.g., between two non-prime numbers)
print(funcImp(14, 16)) # Expected output: 0

# Test case: Range with some primes (e.g., small known primes)
print(funcImp(10, 20)) # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60

# Test case: Single number which is not prime
print(funcImp(8,8)) # Expected output: 0

# Test case: Single number which is prime
print(funcImp(7,7)) # Expected output: 7

# Edge test case: Large range including many primes 
print(funcImp(1,100)) # Expected output should be calculated manually or using another verified method

```","(8, 8)",0,0,PASS,TRUE,
18,3,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Calculate the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers within the specified range.
    """"""
    
    def is_prime(n):
        """"""Check if a number n is a prime number.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum for primes
    total_sum = 0
    
    # Iterate over each number in the given range
    for num in range(start, end + 1):
        if is_prime(num):
            total_sum += num
    
    return total_sum

# Test cases to verify correctness

# Test case: Range with no primes (e.g., between two non-prime numbers)
print(funcImp(14, 16)) # Expected output: 0

# Test case: Range with some primes (e.g., small known primes)
print(funcImp(10, 20)) # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60

# Test case: Single number which is not prime
print(funcImp(8,8)) # Expected output: 0

# Test case: Single number which is prime
print(funcImp(7,7)) # Expected output: 7

# Edge test case: Large range including many primes 
print(funcImp(1,100)) # Expected output should be calculated manually or using another verified method

```","(7, 7)",7,7,PASS,TRUE,
18,4,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Calculate the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    - start (int): The starting integer of the range.
    - end (int): The ending integer of the range.
    
    Returns:
    - int: The sum of all prime numbers within the specified range.
    """"""
    
    def is_prime(n):
        """"""Check if a number n is a prime number.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum for primes
    total_sum = 0
    
    # Iterate over each number in the given range
    for num in range(start, end + 1):
        if is_prime(num):
            total_sum += num
    
    return total_sum

# Test cases to verify correctness

# Test case: Range with no primes (e.g., between two non-prime numbers)
print(funcImp(14, 16)) # Expected output: 0

# Test case: Range with some primes (e.g., small known primes)
print(funcImp(10, 20)) # Expected output: Sum of primes between [10,20] -> [11,13,17,19] = 60

# Test case: Single number which is not prime
print(funcImp(8,8)) # Expected output: 0

# Test case: Single number which is prime
print(funcImp(7,7)) # Expected output: 7

# Edge test case: Large range including many primes 
print(funcImp(1,100)) # Expected output should be calculated manually or using another verified method

```","(1, 100)",,1060,FAIL,FALSE,
19,0,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor for.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    
    # Initialize the maximum prime factor variable
    max_prime = -1
    
    # Divide out all factors of 2
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    
    # If remaining n is greater than 2, it must be a prime number
    if n > 2:
        max_prime = n
    
    return max_prime

# Test cases to verify that funcImp works correctly
print(funcImp(10))   # Expected output: 5 (prime factors are [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are [3,7])
print(funcImp(13195))# Expected output: 29 (prime factors are [5,7,13,29])
print(funcImp(29))   # Expected output: 29 (since it's already a prime)
```",10,5,5,PASS,TRUE,
19,1,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor for.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    
    # Initialize the maximum prime factor variable
    max_prime = -1
    
    # Divide out all factors of 2
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    
    # If remaining n is greater than 2, it must be a prime number
    if n > 2:
        max_prime = n
    
    return max_prime

# Test cases to verify that funcImp works correctly
print(funcImp(10))   # Expected output: 5 (prime factors are [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are [3,7])
print(funcImp(13195))# Expected output: 29 (prime factors are [5,7,13,29])
print(funcImp(29))   # Expected output: 29 (since it's already a prime)
```",15,5,5,PASS,TRUE,
19,2,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor for.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    
    # Initialize the maximum prime factor variable
    max_prime = -1
    
    # Divide out all factors of 2
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    
    # If remaining n is greater than 2, it must be a prime number
    if n > 2:
        max_prime = n
    
    return max_prime

# Test cases to verify that funcImp works correctly
print(funcImp(10))   # Expected output: 5 (prime factors are [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are [3,7])
print(funcImp(13195))# Expected output: 29 (prime factors are [5,7,13,29])
print(funcImp(29))   # Expected output: 29 (since it's already a prime)
```",21,7,7,PASS,TRUE,
19,3,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor for.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    
    # Initialize the maximum prime factor variable
    max_prime = -1
    
    # Divide out all factors of 2
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    
    # If remaining n is greater than 2, it must be a prime number
    if n > 2:
        max_prime = n
    
    return max_prime

# Test cases to verify that funcImp works correctly
print(funcImp(10))   # Expected output: 5 (prime factors are [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are [3,7])
print(funcImp(13195))# Expected output: 29 (prime factors are [5,7,13,29])
print(funcImp(29))   # Expected output: 29 (since it's already a prime)
```",13195,29,29,PASS,TRUE,
19,4,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor for.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    
    # Initialize the maximum prime factor variable
    max_prime = -1
    
    # Divide out all factors of 2
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    
    # If remaining n is greater than 2, it must be a prime number
    if n > 2:
        max_prime = n
    
    return max_prime

# Test cases to verify that funcImp works correctly
print(funcImp(10))   # Expected output: 5 (prime factors are [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are [3,7])
print(funcImp(13195))# Expected output: 29 (prime factors are [5,7,13,29])
print(funcImp(29))   # Expected output: 29 (since it's already a prime)
```",29,29,29,PASS,TRUE,
20,0,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",4,TRUE,TRUE,PASS,TRUE,None
20,1,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",6,TRUE,TRUE,PASS,TRUE,None
20,2,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",9,TRUE,TRUE,PASS,TRUE,None
20,3,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",10,TRUE,TRUE,PASS,TRUE,None
20,4,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",11,FALSE,FALSE,PASS,TRUE,None
20,5,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",12,FALSE,FALSE,PASS,TRUE,None
20,6,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",15,TRUE,TRUE,PASS,TRUE,None
20,7,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",-1,FALSE,FALSE,PASS,TRUE,None
20,8,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number n is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(number):
    """"""
    Determine if the given number is semiprime.
    
    A semiprime number is defined as a natural number that is the product of two (not necessarily distinct) prime numbers.
    
    :param number: Integer, the number to check.
    :return: Boolean, True if the number is semiprime, otherwise False.
    """"""
    
    # Edge case for numbers less than or equal to 1 which cannot be semiprimes
    if number <= 1:
        return False
    
    # Iterate over possible factors up to sqrt(number)
    for i in range(2, int(number**0.5) + 1):
        # If 'i' divides 'number', then check both 'i' and 'number // i' are primes
        if number % i == 0:
            other_factor = number // i
            # Check both factors are prime numbers
            if is_prime(i) and is_prime(other_factor):
                return True
    
    # If no such pair of primes found, it's not a semiprime
    return False

# Test cases to verify the solution

# Semiprimes examples: 
print(funcImp(4))   # True (2 * 2)
print(funcImp(6))   # True (2 * 3)
print(funcImp(9))   # True (3 * 3)
print(funcImp(10))  # True (2 * 5)

# Non-semiprimes examples:
print(funcImp(11))   # False (prime itself)
print(funcImp(12))   # False (not just two primes: it's divisible by more than two primes)
print(funcImp(15))   # True (3 * 5)

# Edge cases:
print(funcImp(-1))   # False (negative numbers can't be semiprimes)
print(funcImp(0))     # False 
print(funcImp(1))     # False 

```",0,FALSE,FALSE,PASS,TRUE,None
21,0,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Bubble Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    
    # Traverse through all elements in the array
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test cases to verify that funcImp works correctly
def test_funcImp():
    # Test case 1: Normal case with random numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4]) == [1, 2, 3, 4]
    
    # Test case 3: Reverse sorted array
    assert funcImp([4, 3, 2, 1]) == [1, 2, 3, 4]
    
    # Test case 4: Array with duplicate values
    assert funcImp([5,5 ,5 ,5 ,5]) == [5 ,5 ,5 ,5 ,5]
    
    # Test case 5: Single element array
    assert funcImp([42]) == [42]
    
    # Test case6 : Empty array 
     assert funcImp([]) == []
     
     print(""All test cases passed!"")

# Run tests to verify correctness of our implementation
test_funcImp()
```","[64, 34, 25, 12, 22, 11, 90]","[11, 12, 22, 25, 34, 64, 90]","[11, 12, 22, 25, 34, 64, 90]",PASS,TRUE,
21,1,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Bubble Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    
    # Traverse through all elements in the array
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test cases to verify that funcImp works correctly
def test_funcImp():
    # Test case 1: Normal case with random numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4]) == [1, 2, 3, 4]
    
    # Test case 3: Reverse sorted array
    assert funcImp([4, 3, 2, 1]) == [1, 2, 3, 4]
    
    # Test case 4: Array with duplicate values
    assert funcImp([5,5 ,5 ,5 ,5]) == [5 ,5 ,5 ,5 ,5]
    
    # Test case 5: Single element array
    assert funcImp([42]) == [42]
    
    # Test case6 : Empty array 
     assert funcImp([]) == []
     
     print(""All test cases passed!"")

# Run tests to verify correctness of our implementation
test_funcImp()
```","[1, 2, 3, 4]","[1, 2, 3, 4]","[1, 2, 3, 4]",PASS,TRUE,
21,2,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Bubble Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    
    # Traverse through all elements in the array
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test cases to verify that funcImp works correctly
def test_funcImp():
    # Test case 1: Normal case with random numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4]) == [1, 2, 3, 4]
    
    # Test case 3: Reverse sorted array
    assert funcImp([4, 3, 2, 1]) == [1, 2, 3, 4]
    
    # Test case 4: Array with duplicate values
    assert funcImp([5,5 ,5 ,5 ,5]) == [5 ,5 ,5 ,5 ,5]
    
    # Test case 5: Single element array
    assert funcImp([42]) == [42]
    
    # Test case6 : Empty array 
     assert funcImp([]) == []
     
     print(""All test cases passed!"")

# Run tests to verify correctness of our implementation
test_funcImp()
```","[4, 3, 2, 1]","[1, 2, 3, 4]","[1, 2, 3, 4]",PASS,TRUE,
21,3,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Bubble Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    
    # Traverse through all elements in the array
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test cases to verify that funcImp works correctly
def test_funcImp():
    # Test case 1: Normal case with random numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4]) == [1, 2, 3, 4]
    
    # Test case 3: Reverse sorted array
    assert funcImp([4, 3, 2, 1]) == [1, 2, 3, 4]
    
    # Test case 4: Array with duplicate values
    assert funcImp([5,5 ,5 ,5 ,5]) == [5 ,5 ,5 ,5 ,5]
    
    # Test case 5: Single element array
    assert funcImp([42]) == [42]
    
    # Test case6 : Empty array 
     assert funcImp([]) == []
     
     print(""All test cases passed!"")

# Run tests to verify correctness of our implementation
test_funcImp()
```","[5, 5, 5, 5]","[5, 5, 5]","[5, 5, 5, 5]",FAIL,FALSE,
21,4,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Bubble Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    
    # Traverse through all elements in the array
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test cases to verify that funcImp works correctly
def test_funcImp():
    # Test case 1: Normal case with random numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4]) == [1, 2, 3, 4]
    
    # Test case 3: Reverse sorted array
    assert funcImp([4, 3, 2, 1]) == [1, 2, 3, 4]
    
    # Test case 4: Array with duplicate values
    assert funcImp([5,5 ,5 ,5 ,5]) == [5 ,5 ,5 ,5 ,5]
    
    # Test case 5: Single element array
    assert funcImp([42]) == [42]
    
    # Test case6 : Empty array 
     assert funcImp([]) == []
     
     print(""All test cases passed!"")

# Run tests to verify correctness of our implementation
test_funcImp()
```",[42],[42],[42],PASS,TRUE,
21,5,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Bubble Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    
    # Traverse through all elements in the array
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test cases to verify that funcImp works correctly
def test_funcImp():
    # Test case 1: Normal case with random numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4]) == [1, 2, 3, 4]
    
    # Test case 3: Reverse sorted array
    assert funcImp([4, 3, 2, 1]) == [1, 2, 3, 4]
    
    # Test case 4: Array with duplicate values
    assert funcImp([5,5 ,5 ,5 ,5]) == [5 ,5 ,5 ,5 ,5]
    
    # Test case 5: Single element array
    assert funcImp([42]) == [42]
    
    # Test case6 : Empty array 
     assert funcImp([]) == []
     
     print(""All test cases passed!"")

# Run tests to verify correctness of our implementation
test_funcImp()
```",[],[],[],PASS,TRUE,
22,0,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform insertion sort on a list.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    
    return arr

# Test cases to verify our implementation
def test_funcImp():
    print(""Test Case 1: "", funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13])
    print(""Test Case 2: "", funcImp([4]) == [4])
    print(""Test Case 3: "", funcImp([]) == [])
    print(""Test Case 4: "", funcImp([3, -2, -5]) == [-5, -2, 3])
    print(""Test Case 5: "", funcImp([10, -10]) == [-10, 10])

# Execute test cases
test_funcImp()
```","[12, 11, 13, 5, 6]","[5, 6, 11, 12, 13]","[5, 6, 11, 12, 13]",PASS,TRUE,
22,1,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform insertion sort on a list.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    
    return arr

# Test cases to verify our implementation
def test_funcImp():
    print(""Test Case 1: "", funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13])
    print(""Test Case 2: "", funcImp([4]) == [4])
    print(""Test Case 3: "", funcImp([]) == [])
    print(""Test Case 4: "", funcImp([3, -2, -5]) == [-5, -2, 3])
    print(""Test Case 5: "", funcImp([10, -10]) == [-10, 10])

# Execute test cases
test_funcImp()
```",[4],[4],[4],PASS,TRUE,
22,2,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform insertion sort on a list.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    
    return arr

# Test cases to verify our implementation
def test_funcImp():
    print(""Test Case 1: "", funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13])
    print(""Test Case 2: "", funcImp([4]) == [4])
    print(""Test Case 3: "", funcImp([]) == [])
    print(""Test Case 4: "", funcImp([3, -2, -5]) == [-5, -2, 3])
    print(""Test Case 5: "", funcImp([10, -10]) == [-10, 10])

# Execute test cases
test_funcImp()
```",[],[],[],PASS,TRUE,
22,3,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform insertion sort on a list.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    
    return arr

# Test cases to verify our implementation
def test_funcImp():
    print(""Test Case 1: "", funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13])
    print(""Test Case 2: "", funcImp([4]) == [4])
    print(""Test Case 3: "", funcImp([]) == [])
    print(""Test Case 4: "", funcImp([3, -2, -5]) == [-5, -2, 3])
    print(""Test Case 5: "", funcImp([10, -10]) == [-10, 10])

# Execute test cases
test_funcImp()
```","[3, -2, -5]","[-5, -2, 3]","[-5, -2, 3]",PASS,TRUE,
22,4,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform insertion sort on a list.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    
    return arr

# Test cases to verify our implementation
def test_funcImp():
    print(""Test Case 1: "", funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13])
    print(""Test Case 2: "", funcImp([4]) == [4])
    print(""Test Case 3: "", funcImp([]) == [])
    print(""Test Case 4: "", funcImp([3, -2, -5]) == [-5, -2, 3])
    print(""Test Case 5: "", funcImp([10, -10]) == [-10, 10])

# Execute test cases
test_funcImp()
```","[10, -10]","[-10, 10]","[-10, 10]",PASS,TRUE,
23,0,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.
    
    Parameters:
    - strings (list): A list of strings to be sorted.
    
    Returns:
    - list: A new list containing the sorted strings.
    """"""
    # Use Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def run_tests():
    test_cases = [
        ([""banana"", ""apple"", ""cherry""], [""apple"", ""banana"", ""cherry""]),
        ([""dog"", ""cat"", ""elephant""], [""cat"", ""dog"", ""elephant""]),
        ([""123"", ""45"", ""!@#"", """"], ["""", ""!@#"", ""123"", ""45""]),
        ([], []),  # Edge case: empty list
        ([""a""], [""a""]),  # Edge case: single element
        ([""same"", ""same""], [""same"", ""same""]),  # Edge case: identical elements
        ([""Zebra"", ""zebra""], [""Zebra"", ""zebra""]),  # Case sensitivity check
        ([""abc1"", ""abc10"", ""abc2""], [""abc1"", ""abc10"", ""abc2""])  # Numeric string comparison
    ]
    
    for i, (input_data, expected) in enumerate(test_cases):
        result = funcImp(input_data)
        assert result == expected, f""Test case {i+1} failed: input({input_data}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed."")

# Run tests to validate the implementation
run_tests()
```","['banana', 'apple', 'cherry']","['apple', 'banana', 'cherry']","['apple', 'banana', 'cherry']",PASS,TRUE,
23,1,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.
    
    Parameters:
    - strings (list): A list of strings to be sorted.
    
    Returns:
    - list: A new list containing the sorted strings.
    """"""
    # Use Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def run_tests():
    test_cases = [
        ([""banana"", ""apple"", ""cherry""], [""apple"", ""banana"", ""cherry""]),
        ([""dog"", ""cat"", ""elephant""], [""cat"", ""dog"", ""elephant""]),
        ([""123"", ""45"", ""!@#"", """"], ["""", ""!@#"", ""123"", ""45""]),
        ([], []),  # Edge case: empty list
        ([""a""], [""a""]),  # Edge case: single element
        ([""same"", ""same""], [""same"", ""same""]),  # Edge case: identical elements
        ([""Zebra"", ""zebra""], [""Zebra"", ""zebra""]),  # Case sensitivity check
        ([""abc1"", ""abc10"", ""abc2""], [""abc1"", ""abc10"", ""abc2""])  # Numeric string comparison
    ]
    
    for i, (input_data, expected) in enumerate(test_cases):
        result = funcImp(input_data)
        assert result == expected, f""Test case {i+1} failed: input({input_data}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed."")

# Run tests to validate the implementation
run_tests()
```","['dog', 'cat', 'elephant']","['cat', 'dog', 'elephant']","['cat', 'dog', 'elephant']",PASS,TRUE,
23,2,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.
    
    Parameters:
    - strings (list): A list of strings to be sorted.
    
    Returns:
    - list: A new list containing the sorted strings.
    """"""
    # Use Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def run_tests():
    test_cases = [
        ([""banana"", ""apple"", ""cherry""], [""apple"", ""banana"", ""cherry""]),
        ([""dog"", ""cat"", ""elephant""], [""cat"", ""dog"", ""elephant""]),
        ([""123"", ""45"", ""!@#"", """"], ["""", ""!@#"", ""123"", ""45""]),
        ([], []),  # Edge case: empty list
        ([""a""], [""a""]),  # Edge case: single element
        ([""same"", ""same""], [""same"", ""same""]),  # Edge case: identical elements
        ([""Zebra"", ""zebra""], [""Zebra"", ""zebra""]),  # Case sensitivity check
        ([""abc1"", ""abc10"", ""abc2""], [""abc1"", ""abc10"", ""abc2""])  # Numeric string comparison
    ]
    
    for i, (input_data, expected) in enumerate(test_cases):
        result = funcImp(input_data)
        assert result == expected, f""Test case {i+1} failed: input({input_data}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed."")

# Run tests to validate the implementation
run_tests()
```","['123', '45', '!@#', '']","['', '!@#', '123', '45']","['', '!@#', '123', '45']",PASS,TRUE,
23,3,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.
    
    Parameters:
    - strings (list): A list of strings to be sorted.
    
    Returns:
    - list: A new list containing the sorted strings.
    """"""
    # Use Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def run_tests():
    test_cases = [
        ([""banana"", ""apple"", ""cherry""], [""apple"", ""banana"", ""cherry""]),
        ([""dog"", ""cat"", ""elephant""], [""cat"", ""dog"", ""elephant""]),
        ([""123"", ""45"", ""!@#"", """"], ["""", ""!@#"", ""123"", ""45""]),
        ([], []),  # Edge case: empty list
        ([""a""], [""a""]),  # Edge case: single element
        ([""same"", ""same""], [""same"", ""same""]),  # Edge case: identical elements
        ([""Zebra"", ""zebra""], [""Zebra"", ""zebra""]),  # Case sensitivity check
        ([""abc1"", ""abc10"", ""abc2""], [""abc1"", ""abc10"", ""abc2""])  # Numeric string comparison
    ]
    
    for i, (input_data, expected) in enumerate(test_cases):
        result = funcImp(input_data)
        assert result == expected, f""Test case {i+1} failed: input({input_data}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed."")

# Run tests to validate the implementation
run_tests()
```",[],[],[],PASS,TRUE,
23,4,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.
    
    Parameters:
    - strings (list): A list of strings to be sorted.
    
    Returns:
    - list: A new list containing the sorted strings.
    """"""
    # Use Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def run_tests():
    test_cases = [
        ([""banana"", ""apple"", ""cherry""], [""apple"", ""banana"", ""cherry""]),
        ([""dog"", ""cat"", ""elephant""], [""cat"", ""dog"", ""elephant""]),
        ([""123"", ""45"", ""!@#"", """"], ["""", ""!@#"", ""123"", ""45""]),
        ([], []),  # Edge case: empty list
        ([""a""], [""a""]),  # Edge case: single element
        ([""same"", ""same""], [""same"", ""same""]),  # Edge case: identical elements
        ([""Zebra"", ""zebra""], [""Zebra"", ""zebra""]),  # Case sensitivity check
        ([""abc1"", ""abc10"", ""abc2""], [""abc1"", ""abc10"", ""abc2""])  # Numeric string comparison
    ]
    
    for i, (input_data, expected) in enumerate(test_cases):
        result = funcImp(input_data)
        assert result == expected, f""Test case {i+1} failed: input({input_data}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed."")

# Run tests to validate the implementation
run_tests()
```",['a'],['a'],['a'],PASS,TRUE,
23,5,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.
    
    Parameters:
    - strings (list): A list of strings to be sorted.
    
    Returns:
    - list: A new list containing the sorted strings.
    """"""
    # Use Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def run_tests():
    test_cases = [
        ([""banana"", ""apple"", ""cherry""], [""apple"", ""banana"", ""cherry""]),
        ([""dog"", ""cat"", ""elephant""], [""cat"", ""dog"", ""elephant""]),
        ([""123"", ""45"", ""!@#"", """"], ["""", ""!@#"", ""123"", ""45""]),
        ([], []),  # Edge case: empty list
        ([""a""], [""a""]),  # Edge case: single element
        ([""same"", ""same""], [""same"", ""same""]),  # Edge case: identical elements
        ([""Zebra"", ""zebra""], [""Zebra"", ""zebra""]),  # Case sensitivity check
        ([""abc1"", ""abc10"", ""abc2""], [""abc1"", ""abc10"", ""abc2""])  # Numeric string comparison
    ]
    
    for i, (input_data, expected) in enumerate(test_cases):
        result = funcImp(input_data)
        assert result == expected, f""Test case {i+1} failed: input({input_data}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed."")

# Run tests to validate the implementation
run_tests()
```","['same', 'same']","['same', 'same']","['same', 'same']",PASS,TRUE,
23,6,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.
    
    Parameters:
    - strings (list): A list of strings to be sorted.
    
    Returns:
    - list: A new list containing the sorted strings.
    """"""
    # Use Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def run_tests():
    test_cases = [
        ([""banana"", ""apple"", ""cherry""], [""apple"", ""banana"", ""cherry""]),
        ([""dog"", ""cat"", ""elephant""], [""cat"", ""dog"", ""elephant""]),
        ([""123"", ""45"", ""!@#"", """"], ["""", ""!@#"", ""123"", ""45""]),
        ([], []),  # Edge case: empty list
        ([""a""], [""a""]),  # Edge case: single element
        ([""same"", ""same""], [""same"", ""same""]),  # Edge case: identical elements
        ([""Zebra"", ""zebra""], [""Zebra"", ""zebra""]),  # Case sensitivity check
        ([""abc1"", ""abc10"", ""abc2""], [""abc1"", ""abc10"", ""abc2""])  # Numeric string comparison
    ]
    
    for i, (input_data, expected) in enumerate(test_cases):
        result = funcImp(input_data)
        assert result == expected, f""Test case {i+1} failed: input({input_data}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed."")

# Run tests to validate the implementation
run_tests()
```","['Zebra', 'zebra']","['Zebra', 'zebra']","['Zebra', 'zebra']",PASS,TRUE,
23,7,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.
    
    Parameters:
    - strings (list): A list of strings to be sorted.
    
    Returns:
    - list: A new list containing the sorted strings.
    """"""
    # Use Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def run_tests():
    test_cases = [
        ([""banana"", ""apple"", ""cherry""], [""apple"", ""banana"", ""cherry""]),
        ([""dog"", ""cat"", ""elephant""], [""cat"", ""dog"", ""elephant""]),
        ([""123"", ""45"", ""!@#"", """"], ["""", ""!@#"", ""123"", ""45""]),
        ([], []),  # Edge case: empty list
        ([""a""], [""a""]),  # Edge case: single element
        ([""same"", ""same""], [""same"", ""same""]),  # Edge case: identical elements
        ([""Zebra"", ""zebra""], [""Zebra"", ""zebra""]),  # Case sensitivity check
        ([""abc1"", ""abc10"", ""abc2""], [""abc1"", ""abc10"", ""abc2""])  # Numeric string comparison
    ]
    
    for i, (input_data, expected) in enumerate(test_cases):
        result = funcImp(input_data)
        assert result == expected, f""Test case {i+1} failed: input({input_data}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed."")

# Run tests to validate the implementation
run_tests()
```","['abc1', 'abc10', 'abc2']","['abc1', 'abc10', 'abc2']","['abc1', 'abc10', 'abc2']",PASS,TRUE,
24,0,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements Selection Sort algorithm.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: Sorted list in ascending order.
    """"""
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap found minimum element with first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases to verify our implementation
def run_tests():
    print(""Test Case 1:"", funcImp([64, 25, 12, 22, 11]))  # Expected output: [11, 12, 22, 25, 64]
    print(""Test Case 2:"", funcImp([5]))                  # Expected output: [5]
    print(""Test Case 3:"", funcImp([]))                   # Expected output: []
    print(""Test Case 4:"", funcImp([3, -1, -7, -4]))      # Expected output: [-7, -4, -1, 3]
    print(""Test Case 5:"", funcImp([10.5, -2.3]))         # Expected output: [-2.3, 10.5]

run_tests()
```","[64, 25, 12, 22, 11]","[11, 12, 22, 25, 64]","[11, 12, 22, 25, 64]",PASS,TRUE,
24,1,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements Selection Sort algorithm.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: Sorted list in ascending order.
    """"""
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap found minimum element with first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases to verify our implementation
def run_tests():
    print(""Test Case 1:"", funcImp([64, 25, 12, 22, 11]))  # Expected output: [11, 12, 22, 25, 64]
    print(""Test Case 2:"", funcImp([5]))                  # Expected output: [5]
    print(""Test Case 3:"", funcImp([]))                   # Expected output: []
    print(""Test Case 4:"", funcImp([3, -1, -7, -4]))      # Expected output: [-7, -4, -1, 3]
    print(""Test Case 5:"", funcImp([10.5, -2.3]))         # Expected output: [-2.3, 10.5]

run_tests()
```",[5],[5],[5],PASS,TRUE,
24,2,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements Selection Sort algorithm.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: Sorted list in ascending order.
    """"""
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap found minimum element with first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases to verify our implementation
def run_tests():
    print(""Test Case 1:"", funcImp([64, 25, 12, 22, 11]))  # Expected output: [11, 12, 22, 25, 64]
    print(""Test Case 2:"", funcImp([5]))                  # Expected output: [5]
    print(""Test Case 3:"", funcImp([]))                   # Expected output: []
    print(""Test Case 4:"", funcImp([3, -1, -7, -4]))      # Expected output: [-7, -4, -1, 3]
    print(""Test Case 5:"", funcImp([10.5, -2.3]))         # Expected output: [-2.3, 10.5]

run_tests()
```",[],[],[],PASS,TRUE,
24,3,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements Selection Sort algorithm.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: Sorted list in ascending order.
    """"""
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap found minimum element with first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases to verify our implementation
def run_tests():
    print(""Test Case 1:"", funcImp([64, 25, 12, 22, 11]))  # Expected output: [11, 12, 22, 25, 64]
    print(""Test Case 2:"", funcImp([5]))                  # Expected output: [5]
    print(""Test Case 3:"", funcImp([]))                   # Expected output: []
    print(""Test Case 4:"", funcImp([3, -1, -7, -4]))      # Expected output: [-7, -4, -1, 3]
    print(""Test Case 5:"", funcImp([10.5, -2.3]))         # Expected output: [-2.3, 10.5]

run_tests()
```","[3, -1, -7, -4]","[-7, -4, -1, 3]","[-7, -4, -1, 3]",PASS,TRUE,
24,4,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements Selection Sort algorithm.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: Sorted list in ascending order.
    """"""
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap found minimum element with first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases to verify our implementation
def run_tests():
    print(""Test Case 1:"", funcImp([64, 25, 12, 22, 11]))  # Expected output: [11, 12, 22, 25, 64]
    print(""Test Case 2:"", funcImp([5]))                  # Expected output: [5]
    print(""Test Case 3:"", funcImp([]))                   # Expected output: []
    print(""Test Case 4:"", funcImp([3, -1, -7, -4]))      # Expected output: [-7, -4, -1, 3]
    print(""Test Case 5:"", funcImp([10.5, -2.3]))         # Expected output: [-2.3, 10.5]

run_tests()
```","[10.5, -2.3]","[-2.3, 10.5]","[-2.3, 10.5]",PASS,TRUE,
25,0,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def funcImp(head):
    # Base case: if head is None or there's only one element in the list
    if not head or not head.next:
        return head
    
    # Function to split the linked list into two halves
    def split(head):
        slow = head
        fast = head.next  # Start fast one step ahead for even number of nodes
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        mid = slow.next
        slow.next = None  # Split the list into two parts
        
        return head, mid
    
    # Function to merge two sorted linked lists
    def merge(l1, l2):
        dummy = ListNode()
        tail = dummy
        
        while l1 and l2:
            if l1.value < l2.value:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            
            tail = tail.next
        
        if l1:
            tail.next = l1
        elif l2:
            tail.next = l2
        
        return dummy.next
    
    # Split the current list into two halves
    left_half, right_half = split(head)
    
    # Recursively sort each half
    left_sorted = funcImp(left_half)
    right_sorted = funcImp(right_half)
    
    # Merge sorted halves and return result
    return merge(left_sorted, right_sorted)

# Helper function to print out a linked list (for testing purposes)
def print_list(node):
    while node:
        print(node.value, end="" -> "")
        node = node.next
    print(""None"")

# Test cases

# Create a sample unsorted linked list: 4 -> 3 -> 5 -> 1 -> 2 -> None
head_test_1 = ListNode(4)
head_test_1.next = ListNode(3)
head_test_1.next.next = ListNode(5)
head_test_1.next.next.next = ListNode(1)
head_test_1.next.next.next.next= ListNode(2)

print(""Original Linked List:"")
print_list(head_test_1)

sorted_head_1 = funcImp(head_test_1)

print(""Sorted Linked List:"")
print_list(sorted_head_1)

# Additional test cases can be created similarly by creating new instances of ListNode with different values.
```",4 -> 3 -> 5 -> 1 -> 2 -> None,1 -> 2 -> 3 -> 4 -> 5 -> None,1 -> 2 -> 3 -> 4 -> 5 -> None,PASS,TRUE,
26,0,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers in ascending order.
    """"""
    
    def counting_sort_for_radix(input_list, place):
        size = len(input_list)
        output_list = [0] * size
        count = [0] * 10
        
        # Calculate count of elements
        for i in range(size):
            index = input_list[i] // place
            count[index % 10] += 1
        
        # Calculate cumulative count
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # Place elements into output array based on current digit
        i = size - 1
        while i >= 0:
            index = input_list[i] // place
            output_list[count[index % 10] - 1] = input_list[i]
            count[index % 10] -= 1
            i -= 1
        
        # Copy sorted elements back into original array
        for i in range(size):
            input_list[i] = output_list[i]

    # Get maximum element to know number of digits
    max_num = max(arr)
    
    # Apply counting sort to sort elements based on place value (digit by digit)
    place = 1
    while max_num // place > 0:
        counting_sort_for_radix(arr, place)
        place *= 10
    
    return arr

# Test cases to validate the solution

# Test case with random numbers
print(funcImp([170, 45, 75, 90, 802, 24, 2, 66])) 
# Expected Output: [2, 24, 45, 66, 75, 90, 170, 802]

# Test case with already sorted numbers
print(funcImp([1,2,3]))
# Expected Output: [1,2,3]

# Test case with reverse sorted numbers
print(funcImp([9,8]))
# Expected Output: [8,9]

# Test case with single element array 
print(funcImp([5]))
# Expected Output: [5]

# Edge case with empty array 
print(funcImp([]))
# Expected Output: []

```","[170, 45, 75, 90, 802, 24, 2, 66]","[2, 24, 45, 66, 75, 90, 170, 802]","[2, 24, 45, 66, 75, 90, 170, 802]",PASS,TRUE,
26,1,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers in ascending order.
    """"""
    
    def counting_sort_for_radix(input_list, place):
        size = len(input_list)
        output_list = [0] * size
        count = [0] * 10
        
        # Calculate count of elements
        for i in range(size):
            index = input_list[i] // place
            count[index % 10] += 1
        
        # Calculate cumulative count
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # Place elements into output array based on current digit
        i = size - 1
        while i >= 0:
            index = input_list[i] // place
            output_list[count[index % 10] - 1] = input_list[i]
            count[index % 10] -= 1
            i -= 1
        
        # Copy sorted elements back into original array
        for i in range(size):
            input_list[i] = output_list[i]

    # Get maximum element to know number of digits
    max_num = max(arr)
    
    # Apply counting sort to sort elements based on place value (digit by digit)
    place = 1
    while max_num // place > 0:
        counting_sort_for_radix(arr, place)
        place *= 10
    
    return arr

# Test cases to validate the solution

# Test case with random numbers
print(funcImp([170, 45, 75, 90, 802, 24, 2, 66])) 
# Expected Output: [2, 24, 45, 66, 75, 90, 170, 802]

# Test case with already sorted numbers
print(funcImp([1,2,3]))
# Expected Output: [1,2,3]

# Test case with reverse sorted numbers
print(funcImp([9,8]))
# Expected Output: [8,9]

# Test case with single element array 
print(funcImp([5]))
# Expected Output: [5]

# Edge case with empty array 
print(funcImp([]))
# Expected Output: []

```","[1, 2, 3]","[1, 2, 3]","[1, 2, 3]",PASS,TRUE,
26,2,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers in ascending order.
    """"""
    
    def counting_sort_for_radix(input_list, place):
        size = len(input_list)
        output_list = [0] * size
        count = [0] * 10
        
        # Calculate count of elements
        for i in range(size):
            index = input_list[i] // place
            count[index % 10] += 1
        
        # Calculate cumulative count
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # Place elements into output array based on current digit
        i = size - 1
        while i >= 0:
            index = input_list[i] // place
            output_list[count[index % 10] - 1] = input_list[i]
            count[index % 10] -= 1
            i -= 1
        
        # Copy sorted elements back into original array
        for i in range(size):
            input_list[i] = output_list[i]

    # Get maximum element to know number of digits
    max_num = max(arr)
    
    # Apply counting sort to sort elements based on place value (digit by digit)
    place = 1
    while max_num // place > 0:
        counting_sort_for_radix(arr, place)
        place *= 10
    
    return arr

# Test cases to validate the solution

# Test case with random numbers
print(funcImp([170, 45, 75, 90, 802, 24, 2, 66])) 
# Expected Output: [2, 24, 45, 66, 75, 90, 170, 802]

# Test case with already sorted numbers
print(funcImp([1,2,3]))
# Expected Output: [1,2,3]

# Test case with reverse sorted numbers
print(funcImp([9,8]))
# Expected Output: [8,9]

# Test case with single element array 
print(funcImp([5]))
# Expected Output: [5]

# Edge case with empty array 
print(funcImp([]))
# Expected Output: []

```","[9, 8]","[8, 9]","[8, 9]",PASS,TRUE,
26,3,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers in ascending order.
    """"""
    
    def counting_sort_for_radix(input_list, place):
        size = len(input_list)
        output_list = [0] * size
        count = [0] * 10
        
        # Calculate count of elements
        for i in range(size):
            index = input_list[i] // place
            count[index % 10] += 1
        
        # Calculate cumulative count
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # Place elements into output array based on current digit
        i = size - 1
        while i >= 0:
            index = input_list[i] // place
            output_list[count[index % 10] - 1] = input_list[i]
            count[index % 10] -= 1
            i -= 1
        
        # Copy sorted elements back into original array
        for i in range(size):
            input_list[i] = output_list[i]

    # Get maximum element to know number of digits
    max_num = max(arr)
    
    # Apply counting sort to sort elements based on place value (digit by digit)
    place = 1
    while max_num // place > 0:
        counting_sort_for_radix(arr, place)
        place *= 10
    
    return arr

# Test cases to validate the solution

# Test case with random numbers
print(funcImp([170, 45, 75, 90, 802, 24, 2, 66])) 
# Expected Output: [2, 24, 45, 66, 75, 90, 170, 802]

# Test case with already sorted numbers
print(funcImp([1,2,3]))
# Expected Output: [1,2,3]

# Test case with reverse sorted numbers
print(funcImp([9,8]))
# Expected Output: [8,9]

# Test case with single element array 
print(funcImp([5]))
# Expected Output: [5]

# Edge case with empty array 
print(funcImp([]))
# Expected Output: []

```",[5],[5],[5],PASS,TRUE,
26,4,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers in ascending order.
    """"""
    
    def counting_sort_for_radix(input_list, place):
        size = len(input_list)
        output_list = [0] * size
        count = [0] * 10
        
        # Calculate count of elements
        for i in range(size):
            index = input_list[i] // place
            count[index % 10] += 1
        
        # Calculate cumulative count
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # Place elements into output array based on current digit
        i = size - 1
        while i >= 0:
            index = input_list[i] // place
            output_list[count[index % 10] - 1] = input_list[i]
            count[index % 10] -= 1
            i -= 1
        
        # Copy sorted elements back into original array
        for i in range(size):
            input_list[i] = output_list[i]

    # Get maximum element to know number of digits
    max_num = max(arr)
    
    # Apply counting sort to sort elements based on place value (digit by digit)
    place = 1
    while max_num // place > 0:
        counting_sort_for_radix(arr, place)
        place *= 10
    
    return arr

# Test cases to validate the solution

# Test case with random numbers
print(funcImp([170, 45, 75, 90, 802, 24, 2, 66])) 
# Expected Output: [2, 24, 45, 66, 75, 90, 170, 802]

# Test case with already sorted numbers
print(funcImp([1,2,3]))
# Expected Output: [1,2,3]

# Test case with reverse sorted numbers
print(funcImp([9,8]))
# Expected Output: [8,9]

# Test case with single element array 
print(funcImp([5]))
# Expected Output: [5]

# Edge case with empty array 
print(funcImp([]))
# Expected Output: []

```",[],[],[],PASS,TRUE,
27,0,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using counting sort.
    
    Parameters:
    arr (list): The list of integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers.
    """"""
    
    if not arr:
        return []
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Create a count array to store the frequency of each element
    count_range = max_val - min_val + 1
    count = [0] * count_range
    
    # Fill the count array with frequencies
    for num in arr:
        count[num - min_val] += 1
    
    # Reconstruct the sorted array from the count array
    sorted_arr = []
    
    for i, cnt in enumerate(count):
        if cnt > 0:
            sorted_arr.extend([i + min_val] * cnt)
    
    return sorted_arr

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with duplicates
arr1 = [4, 2, 2, 8, 3, 3, 1]
print(funcImp(arr1))  # Expected output: [1, 2, 2, 3, 3, 4, 8]

# Test case 2: All elements are identical
arr2 = [5, 5, 5, 5]
print(funcImp(arr2))  # Expected output: [5, 5, 5, 5]

# Test case 3: Already sorted array
arr3 = [1, 2, 3]
print(funcImp(arr3))   # Expected output: [1, 2, 3]

# Test case 4: Reverse order array
arr4 = [9,7,-10,-10,-10,-10]
print(funcImp(arr4))   # Expected output: [-10,-10,-10,-10 ,7 ,9]

# Test case : Empty Array 
arr5=[]
print(funcImp(arr5))   #Expected Output : []

```","[4, 2, 2, 8, 3, 3, 1]","[1, 2, 2, 3, 3, 4, 8]","[1, 2, 2, 3, 3, 4, 8]",PASS,TRUE,
27,1,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using counting sort.
    
    Parameters:
    arr (list): The list of integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers.
    """"""
    
    if not arr:
        return []
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Create a count array to store the frequency of each element
    count_range = max_val - min_val + 1
    count = [0] * count_range
    
    # Fill the count array with frequencies
    for num in arr:
        count[num - min_val] += 1
    
    # Reconstruct the sorted array from the count array
    sorted_arr = []
    
    for i, cnt in enumerate(count):
        if cnt > 0:
            sorted_arr.extend([i + min_val] * cnt)
    
    return sorted_arr

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with duplicates
arr1 = [4, 2, 2, 8, 3, 3, 1]
print(funcImp(arr1))  # Expected output: [1, 2, 2, 3, 3, 4, 8]

# Test case 2: All elements are identical
arr2 = [5, 5, 5, 5]
print(funcImp(arr2))  # Expected output: [5, 5, 5, 5]

# Test case 3: Already sorted array
arr3 = [1, 2, 3]
print(funcImp(arr3))   # Expected output: [1, 2, 3]

# Test case 4: Reverse order array
arr4 = [9,7,-10,-10,-10,-10]
print(funcImp(arr4))   # Expected output: [-10,-10,-10,-10 ,7 ,9]

# Test case : Empty Array 
arr5=[]
print(funcImp(arr5))   #Expected Output : []

```","[5, 5, 5, 5]","[5, 5, 5, 5]","[5, 5, 5, 5]",PASS,TRUE,
27,2,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using counting sort.
    
    Parameters:
    arr (list): The list of integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers.
    """"""
    
    if not arr:
        return []
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Create a count array to store the frequency of each element
    count_range = max_val - min_val + 1
    count = [0] * count_range
    
    # Fill the count array with frequencies
    for num in arr:
        count[num - min_val] += 1
    
    # Reconstruct the sorted array from the count array
    sorted_arr = []
    
    for i, cnt in enumerate(count):
        if cnt > 0:
            sorted_arr.extend([i + min_val] * cnt)
    
    return sorted_arr

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with duplicates
arr1 = [4, 2, 2, 8, 3, 3, 1]
print(funcImp(arr1))  # Expected output: [1, 2, 2, 3, 3, 4, 8]

# Test case 2: All elements are identical
arr2 = [5, 5, 5, 5]
print(funcImp(arr2))  # Expected output: [5, 5, 5, 5]

# Test case 3: Already sorted array
arr3 = [1, 2, 3]
print(funcImp(arr3))   # Expected output: [1, 2, 3]

# Test case 4: Reverse order array
arr4 = [9,7,-10,-10,-10,-10]
print(funcImp(arr4))   # Expected output: [-10,-10,-10,-10 ,7 ,9]

# Test case : Empty Array 
arr5=[]
print(funcImp(arr5))   #Expected Output : []

```","[1, 2, 3]","[1, 2, 3]","[1, 2, 3]",PASS,TRUE,
27,3,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using counting sort.
    
    Parameters:
    arr (list): The list of integers to be sorted.
    
    Returns:
    list: A new list containing the sorted integers.
    """"""
    
    if not arr:
        return []
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Create a count array to store the frequency of each element
    count_range = max_val - min_val + 1
    count = [0] * count_range
    
    # Fill the count array with frequencies
    for num in arr:
        count[num - min_val] += 1
    
    # Reconstruct the sorted array from the count array
    sorted_arr = []
    
    for i, cnt in enumerate(count):
        if cnt > 0:
            sorted_arr.extend([i + min_val] * cnt)
    
    return sorted_arr

# Test cases to verify that funcImp works correctly

# Test case 1: Normal case with duplicates
arr1 = [4, 2, 2, 8, 3, 3, 1]
print(funcImp(arr1))  # Expected output: [1, 2, 2, 3, 3, 4, 8]

# Test case 2: All elements are identical
arr2 = [5, 5, 5, 5]
print(funcImp(arr2))  # Expected output: [5, 5, 5, 5]

# Test case 3: Already sorted array
arr3 = [1, 2, 3]
print(funcImp(arr3))   # Expected output: [1, 2, 3]

# Test case 4: Reverse order array
arr4 = [9,7,-10,-10,-10,-10]
print(funcImp(arr4))   # Expected output: [-10,-10,-10,-10 ,7 ,9]

# Test case : Empty Array 
arr5=[]
print(funcImp(arr5))   #Expected Output : []

```","[9, -10, -10, -10, -10, 7]","[-10, -10, -10, -10, 7, 9]","[-10, -10, -10, -10, 7, 9]",PASS,TRUE,
28,0,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Perform Heap Sort on an array.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    
    def heapify(arr, n, i):
        # Assume largest as root
        largest = i
        left = 2 * i + 1     # left child index
        right = 2 * i + 2    # right child index
        
        # If left child exists and is greater than root
        if left < n and arr[i] < arr[left]:
            largest = left
        
        # If right child exists and is greater than current largest
        if right < n and arr[largest] < arr[right]:
            largest = right
        
        # If largest is not root
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]  # swap
            
            # Recursively heapify the affected sub-tree
            heapify(arr, n, largest)
    
    def heap_sort(arr):
        n = len(arr)
        
        # Build a maxheap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # Extract elements one by one from the end of array
        for i in range(n-1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]   # swap
            heapify(arr, i, 0)
    
    # Call internal function to perform sorting
    heap_sort(arr)
    
    return arr

# Test cases to verify our implementation

def run_tests():
    test_cases = [
        ([], []),
        ([3], [3]),
        ([4, 10, 3, 5, 1], [1, 3, 4, 5, 10]),
        ([12, 11, 13, 5, 6], [5, 6, 11, 12]),
        ([9,-3,-7,-8,-4,-6,-5,-2,-9],[ -9 ,-8 ,-7 ,-6 ,-5 ,-4 ,-3 ,-2 ,9])
    ]
    
    for idx,test_case in enumerate(test_cases):
      input_data , expected_output= test_case 
      assert funcImp(input_data) == expected_output , f""Test case {idx+1} failed""
      
run_tests()
print(""All test cases passed!"")
```",[],[],[],PASS,TRUE,
28,1,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Perform Heap Sort on an array.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    
    def heapify(arr, n, i):
        # Assume largest as root
        largest = i
        left = 2 * i + 1     # left child index
        right = 2 * i + 2    # right child index
        
        # If left child exists and is greater than root
        if left < n and arr[i] < arr[left]:
            largest = left
        
        # If right child exists and is greater than current largest
        if right < n and arr[largest] < arr[right]:
            largest = right
        
        # If largest is not root
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]  # swap
            
            # Recursively heapify the affected sub-tree
            heapify(arr, n, largest)
    
    def heap_sort(arr):
        n = len(arr)
        
        # Build a maxheap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # Extract elements one by one from the end of array
        for i in range(n-1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]   # swap
            heapify(arr, i, 0)
    
    # Call internal function to perform sorting
    heap_sort(arr)
    
    return arr

# Test cases to verify our implementation

def run_tests():
    test_cases = [
        ([], []),
        ([3], [3]),
        ([4, 10, 3, 5, 1], [1, 3, 4, 5, 10]),
        ([12, 11, 13, 5, 6], [5, 6, 11, 12]),
        ([9,-3,-7,-8,-4,-6,-5,-2,-9],[ -9 ,-8 ,-7 ,-6 ,-5 ,-4 ,-3 ,-2 ,9])
    ]
    
    for idx,test_case in enumerate(test_cases):
      input_data , expected_output= test_case 
      assert funcImp(input_data) == expected_output , f""Test case {idx+1} failed""
      
run_tests()
print(""All test cases passed!"")
```",[3],[3],[3],PASS,TRUE,
28,2,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Perform Heap Sort on an array.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    
    def heapify(arr, n, i):
        # Assume largest as root
        largest = i
        left = 2 * i + 1     # left child index
        right = 2 * i + 2    # right child index
        
        # If left child exists and is greater than root
        if left < n and arr[i] < arr[left]:
            largest = left
        
        # If right child exists and is greater than current largest
        if right < n and arr[largest] < arr[right]:
            largest = right
        
        # If largest is not root
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]  # swap
            
            # Recursively heapify the affected sub-tree
            heapify(arr, n, largest)
    
    def heap_sort(arr):
        n = len(arr)
        
        # Build a maxheap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # Extract elements one by one from the end of array
        for i in range(n-1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]   # swap
            heapify(arr, i, 0)
    
    # Call internal function to perform sorting
    heap_sort(arr)
    
    return arr

# Test cases to verify our implementation

def run_tests():
    test_cases = [
        ([], []),
        ([3], [3]),
        ([4, 10, 3, 5, 1], [1, 3, 4, 5, 10]),
        ([12, 11, 13, 5, 6], [5, 6, 11, 12]),
        ([9,-3,-7,-8,-4,-6,-5,-2,-9],[ -9 ,-8 ,-7 ,-6 ,-5 ,-4 ,-3 ,-2 ,9])
    ]
    
    for idx,test_case in enumerate(test_cases):
      input_data , expected_output= test_case 
      assert funcImp(input_data) == expected_output , f""Test case {idx+1} failed""
      
run_tests()
print(""All test cases passed!"")
```","[4, 10, 3, 5, 1]","[1, 3, 4, 5, 10]","[1, 3, 4, 5, 10]",PASS,TRUE,
28,3,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Perform Heap Sort on an array.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    
    def heapify(arr, n, i):
        # Assume largest as root
        largest = i
        left = 2 * i + 1     # left child index
        right = 2 * i + 2    # right child index
        
        # If left child exists and is greater than root
        if left < n and arr[i] < arr[left]:
            largest = left
        
        # If right child exists and is greater than current largest
        if right < n and arr[largest] < arr[right]:
            largest = right
        
        # If largest is not root
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]  # swap
            
            # Recursively heapify the affected sub-tree
            heapify(arr, n, largest)
    
    def heap_sort(arr):
        n = len(arr)
        
        # Build a maxheap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # Extract elements one by one from the end of array
        for i in range(n-1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]   # swap
            heapify(arr, i, 0)
    
    # Call internal function to perform sorting
    heap_sort(arr)
    
    return arr

# Test cases to verify our implementation

def run_tests():
    test_cases = [
        ([], []),
        ([3], [3]),
        ([4, 10, 3, 5, 1], [1, 3, 4, 5, 10]),
        ([12, 11, 13, 5, 6], [5, 6, 11, 12]),
        ([9,-3,-7,-8,-4,-6,-5,-2,-9],[ -9 ,-8 ,-7 ,-6 ,-5 ,-4 ,-3 ,-2 ,9])
    ]
    
    for idx,test_case in enumerate(test_cases):
      input_data , expected_output= test_case 
      assert funcImp(input_data) == expected_output , f""Test case {idx+1} failed""
      
run_tests()
print(""All test cases passed!"")
```","[12, 11, 13, 5, 6]","[5, 6, 11, 12, 13]","[5, 6, 11, 12, 13]",PASS,TRUE,
28,4,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Perform Heap Sort on an array.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    
    def heapify(arr, n, i):
        # Assume largest as root
        largest = i
        left = 2 * i + 1     # left child index
        right = 2 * i + 2    # right child index
        
        # If left child exists and is greater than root
        if left < n and arr[i] < arr[left]:
            largest = left
        
        # If right child exists and is greater than current largest
        if right < n and arr[largest] < arr[right]:
            largest = right
        
        # If largest is not root
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]  # swap
            
            # Recursively heapify the affected sub-tree
            heapify(arr, n, largest)
    
    def heap_sort(arr):
        n = len(arr)
        
        # Build a maxheap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # Extract elements one by one from the end of array
        for i in range(n-1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]   # swap
            heapify(arr, i, 0)
    
    # Call internal function to perform sorting
    heap_sort(arr)
    
    return arr

# Test cases to verify our implementation

def run_tests():
    test_cases = [
        ([], []),
        ([3], [3]),
        ([4, 10, 3, 5, 1], [1, 3, 4, 5, 10]),
        ([12, 11, 13, 5, 6], [5, 6, 11, 12]),
        ([9,-3,-7,-8,-4,-6,-5,-2,-9],[ -9 ,-8 ,-7 ,-6 ,-5 ,-4 ,-3 ,-2 ,9])
    ]
    
    for idx,test_case in enumerate(test_cases):
      input_data , expected_output= test_case 
      assert funcImp(input_data) == expected_output , f""Test case {idx+1} failed""
      
run_tests()
print(""All test cases passed!"")
```","[9, -3, -7, -8, -4, -6, -5, -2, -9]","[-9, -8, -7, -6, -5, -4, -3, -2, 9]","[-9, -8, -7, -6, -5, -4, -3, -2, 9]",PASS,TRUE,
29,0,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.
    
    :param graph: A dictionary representing an adjacency list of the graph.
                  Keys are node identifiers and values are lists of adjacent nodes.
    :param start: The starting node for the path.
    :param end: The ending node for the path.
    :return: A list representing the shortest path from start to end, or None if no path exists.
    """"""
    
    # If start or end is not in graph, return None
    if start not in graph or end not in graph:
        return None
    
    # Queue for BFS that stores (current_node, path_to_current_node)
    queue = deque([(start, [start])])
    
    # Set to keep track of visited nodes
    visited = set()
    
    while queue:
        current_node, path = queue.popleft()
        
        # If we reach the end node, return the current path
        if current_node == end:
            return path
        
        # Mark current node as visited
        visited.add(current_node)
        
        # Explore neighbors
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))
                visited.add(neighbor)  # Mark neighbor as visited when it's added to avoid re-adding
    
    # If no path found
    return None

# Test cases to verify correctness of funcImp

# Example Graph (Undirected)
graph_example = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path exists between A and F
print(funcImp(graph_example, 'A', 'F'))  # Expected output: ['A', 'C', 'F'] or similar valid shortest paths

# Test case 2: Path does not exist between D and C directly but should find through B or E
print(funcImp(graph_example, 'D', 'C'))  # Expected output: ['D', 'B', ... , ..., ..., ..., ..., ..., ...]

# Test case 3: Start equals End
print(funcImp(graph_example, 'A', 'A'))  # Expected output: ['A']

# Test case 4: No such nodes exist in graph
print(funcImp(graph_example, 'X', 'Y'))  # Expected output: None

# Test case 5: Empty Graph
empty_graph = {}
print(funcImp(empty_graph, 'A', 'B'))   # Expected output: None

```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'F')","[['A', 'C', 'F'], ['A', 'B', 'E', 'F']]","['A', 'C', 'F']",FAIL,FALSE,
29,1,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.
    
    :param graph: A dictionary representing an adjacency list of the graph.
                  Keys are node identifiers and values are lists of adjacent nodes.
    :param start: The starting node for the path.
    :param end: The ending node for the path.
    :return: A list representing the shortest path from start to end, or None if no path exists.
    """"""
    
    # If start or end is not in graph, return None
    if start not in graph or end not in graph:
        return None
    
    # Queue for BFS that stores (current_node, path_to_current_node)
    queue = deque([(start, [start])])
    
    # Set to keep track of visited nodes
    visited = set()
    
    while queue:
        current_node, path = queue.popleft()
        
        # If we reach the end node, return the current path
        if current_node == end:
            return path
        
        # Mark current node as visited
        visited.add(current_node)
        
        # Explore neighbors
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))
                visited.add(neighbor)  # Mark neighbor as visited when it's added to avoid re-adding
    
    # If no path found
    return None

# Test cases to verify correctness of funcImp

# Example Graph (Undirected)
graph_example = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path exists between A and F
print(funcImp(graph_example, 'A', 'F'))  # Expected output: ['A', 'C', 'F'] or similar valid shortest paths

# Test case 2: Path does not exist between D and C directly but should find through B or E
print(funcImp(graph_example, 'D', 'C'))  # Expected output: ['D', 'B', ... , ..., ..., ..., ..., ..., ...]

# Test case 3: Start equals End
print(funcImp(graph_example, 'A', 'A'))  # Expected output: ['A']

# Test case 4: No such nodes exist in graph
print(funcImp(graph_example, 'X', 'Y'))  # Expected output: None

# Test case 5: Empty Graph
empty_graph = {}
print(funcImp(empty_graph, 'A', 'B'))   # Expected output: None

```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'D', 'C')","[['D', 'B', Ellipsis], Ellipsis]","['D', 'B', 'A', 'C']",FAIL,FALSE,
29,2,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.
    
    :param graph: A dictionary representing an adjacency list of the graph.
                  Keys are node identifiers and values are lists of adjacent nodes.
    :param start: The starting node for the path.
    :param end: The ending node for the path.
    :return: A list representing the shortest path from start to end, or None if no path exists.
    """"""
    
    # If start or end is not in graph, return None
    if start not in graph or end not in graph:
        return None
    
    # Queue for BFS that stores (current_node, path_to_current_node)
    queue = deque([(start, [start])])
    
    # Set to keep track of visited nodes
    visited = set()
    
    while queue:
        current_node, path = queue.popleft()
        
        # If we reach the end node, return the current path
        if current_node == end:
            return path
        
        # Mark current node as visited
        visited.add(current_node)
        
        # Explore neighbors
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))
                visited.add(neighbor)  # Mark neighbor as visited when it's added to avoid re-adding
    
    # If no path found
    return None

# Test cases to verify correctness of funcImp

# Example Graph (Undirected)
graph_example = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path exists between A and F
print(funcImp(graph_example, 'A', 'F'))  # Expected output: ['A', 'C', 'F'] or similar valid shortest paths

# Test case 2: Path does not exist between D and C directly but should find through B or E
print(funcImp(graph_example, 'D', 'C'))  # Expected output: ['D', 'B', ... , ..., ..., ..., ..., ..., ...]

# Test case 3: Start equals End
print(funcImp(graph_example, 'A', 'A'))  # Expected output: ['A']

# Test case 4: No such nodes exist in graph
print(funcImp(graph_example, 'X', 'Y'))  # Expected output: None

# Test case 5: Empty Graph
empty_graph = {}
print(funcImp(empty_graph, 'A', 'B'))   # Expected output: None

```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'A')",[['A']],['A'],FAIL,FALSE,
29,3,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.
    
    :param graph: A dictionary representing an adjacency list of the graph.
                  Keys are node identifiers and values are lists of adjacent nodes.
    :param start: The starting node for the path.
    :param end: The ending node for the path.
    :return: A list representing the shortest path from start to end, or None if no path exists.
    """"""
    
    # If start or end is not in graph, return None
    if start not in graph or end not in graph:
        return None
    
    # Queue for BFS that stores (current_node, path_to_current_node)
    queue = deque([(start, [start])])
    
    # Set to keep track of visited nodes
    visited = set()
    
    while queue:
        current_node, path = queue.popleft()
        
        # If we reach the end node, return the current path
        if current_node == end:
            return path
        
        # Mark current node as visited
        visited.add(current_node)
        
        # Explore neighbors
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))
                visited.add(neighbor)  # Mark neighbor as visited when it's added to avoid re-adding
    
    # If no path found
    return None

# Test cases to verify correctness of funcImp

# Example Graph (Undirected)
graph_example = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path exists between A and F
print(funcImp(graph_example, 'A', 'F'))  # Expected output: ['A', 'C', 'F'] or similar valid shortest paths

# Test case 2: Path does not exist between D and C directly but should find through B or E
print(funcImp(graph_example, 'D', 'C'))  # Expected output: ['D', 'B', ... , ..., ..., ..., ..., ..., ...]

# Test case 3: Start equals End
print(funcImp(graph_example, 'A', 'A'))  # Expected output: ['A']

# Test case 4: No such nodes exist in graph
print(funcImp(graph_example, 'X', 'Y'))  # Expected output: None

# Test case 5: Empty Graph
empty_graph = {}
print(funcImp(empty_graph, 'A', 'B'))   # Expected output: None

```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'X', 'Y')",[None],None,FAIL,FALSE,
29,4,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.
    
    :param graph: A dictionary representing an adjacency list of the graph.
                  Keys are node identifiers and values are lists of adjacent nodes.
    :param start: The starting node for the path.
    :param end: The ending node for the path.
    :return: A list representing the shortest path from start to end, or None if no path exists.
    """"""
    
    # If start or end is not in graph, return None
    if start not in graph or end not in graph:
        return None
    
    # Queue for BFS that stores (current_node, path_to_current_node)
    queue = deque([(start, [start])])
    
    # Set to keep track of visited nodes
    visited = set()
    
    while queue:
        current_node, path = queue.popleft()
        
        # If we reach the end node, return the current path
        if current_node == end:
            return path
        
        # Mark current node as visited
        visited.add(current_node)
        
        # Explore neighbors
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))
                visited.add(neighbor)  # Mark neighbor as visited when it's added to avoid re-adding
    
    # If no path found
    return None

# Test cases to verify correctness of funcImp

# Example Graph (Undirected)
graph_example = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path exists between A and F
print(funcImp(graph_example, 'A', 'F'))  # Expected output: ['A', 'C', 'F'] or similar valid shortest paths

# Test case 2: Path does not exist between D and C directly but should find through B or E
print(funcImp(graph_example, 'D', 'C'))  # Expected output: ['D', 'B', ... , ..., ..., ..., ..., ..., ...]

# Test case 3: Start equals End
print(funcImp(graph_example, 'A', 'A'))  # Expected output: ['A']

# Test case 4: No such nodes exist in graph
print(funcImp(graph_example, 'X', 'Y'))  # Expected output: None

# Test case 5: Empty Graph
empty_graph = {}
print(funcImp(empty_graph, 'A', 'B'))   # Expected output: None

```","({}, 'A', 'B')",[None],None,FAIL,FALSE,
30,0,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determine if a directed graph contains a cycle using depth-first search.
    
    :param graph: A dictionary representing the adjacency list of the graph.
                  The keys are node identifiers and the values are lists of nodes
                  that each key node has edges to.
    :return: True if there is a cycle in the graph, False otherwise.
    """"""
    
    # Helper function for DFS
    def dfs(node):
        # If we're visiting an already visited node that's still in recursion stack, there's a cycle
        if visited[node] == 1:
            return True
        # If it's fully processed, no need to visit again
        if visited[node] == 2:
            return False
        
        # Mark the current node as being visited (part of recursion stack)
        visited[node] = 1
        
        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True
        
        # Mark the current node as fully processed
        visited[node] = 2
        return False
    
    # Dictionary to keep track of visit status: 0 = unvisited, 1 = visiting, 2 = fully processed
    visited = {node: 0 for node in graph}
    
    # Check each component of the graph
    for node in graph:
        if visited[node] == 0:  # Unvisited nodes only
            if dfs(node):
                return True
    
    return False

# Test cases to verify our solution

# Test case 1: Graph with no cycles (A -> B -> C)
graph1 = {
    'A': ['B'],
    'B': ['C'],
    'C': []
}

# Test case 2: Graph with a simple cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

# Test case 3: Disconnected components with one having a cycle (D -> E; F -> G -> H -> F)
graph3 = {
    'D': ['E'],
    'E': [],
    'F': ['G'],
    'G': ['H'],
    'H': ['F']
}

# Test case 4: Empty graph (no nodes)
graph4 = {}

# Execute test cases and print results

print(funcImp(graph1))   # Expected output: False (no cycles)
print(funcImp(graph2))   # Expected output: True (contains a cycle)
print(funcImp(graph3))   # Expected output: True (contains a cycle in one component)
print(funcImp(graph4))   # Expected output: False (empty graph)

```","{'A': ['B'], 'B': ['C'], 'C': []}",FALSE,FALSE,PASS,TRUE,
30,1,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determine if a directed graph contains a cycle using depth-first search.
    
    :param graph: A dictionary representing the adjacency list of the graph.
                  The keys are node identifiers and the values are lists of nodes
                  that each key node has edges to.
    :return: True if there is a cycle in the graph, False otherwise.
    """"""
    
    # Helper function for DFS
    def dfs(node):
        # If we're visiting an already visited node that's still in recursion stack, there's a cycle
        if visited[node] == 1:
            return True
        # If it's fully processed, no need to visit again
        if visited[node] == 2:
            return False
        
        # Mark the current node as being visited (part of recursion stack)
        visited[node] = 1
        
        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True
        
        # Mark the current node as fully processed
        visited[node] = 2
        return False
    
    # Dictionary to keep track of visit status: 0 = unvisited, 1 = visiting, 2 = fully processed
    visited = {node: 0 for node in graph}
    
    # Check each component of the graph
    for node in graph:
        if visited[node] == 0:  # Unvisited nodes only
            if dfs(node):
                return True
    
    return False

# Test cases to verify our solution

# Test case 1: Graph with no cycles (A -> B -> C)
graph1 = {
    'A': ['B'],
    'B': ['C'],
    'C': []
}

# Test case 2: Graph with a simple cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

# Test case 3: Disconnected components with one having a cycle (D -> E; F -> G -> H -> F)
graph3 = {
    'D': ['E'],
    'E': [],
    'F': ['G'],
    'G': ['H'],
    'H': ['F']
}

# Test case 4: Empty graph (no nodes)
graph4 = {}

# Execute test cases and print results

print(funcImp(graph1))   # Expected output: False (no cycles)
print(funcImp(graph2))   # Expected output: True (contains a cycle)
print(funcImp(graph3))   # Expected output: True (contains a cycle in one component)
print(funcImp(graph4))   # Expected output: False (empty graph)

```","{'A': ['B'], 'B': ['C'], 'C': ['A']}",TRUE,TRUE,PASS,TRUE,
30,2,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determine if a directed graph contains a cycle using depth-first search.
    
    :param graph: A dictionary representing the adjacency list of the graph.
                  The keys are node identifiers and the values are lists of nodes
                  that each key node has edges to.
    :return: True if there is a cycle in the graph, False otherwise.
    """"""
    
    # Helper function for DFS
    def dfs(node):
        # If we're visiting an already visited node that's still in recursion stack, there's a cycle
        if visited[node] == 1:
            return True
        # If it's fully processed, no need to visit again
        if visited[node] == 2:
            return False
        
        # Mark the current node as being visited (part of recursion stack)
        visited[node] = 1
        
        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True
        
        # Mark the current node as fully processed
        visited[node] = 2
        return False
    
    # Dictionary to keep track of visit status: 0 = unvisited, 1 = visiting, 2 = fully processed
    visited = {node: 0 for node in graph}
    
    # Check each component of the graph
    for node in graph:
        if visited[node] == 0:  # Unvisited nodes only
            if dfs(node):
                return True
    
    return False

# Test cases to verify our solution

# Test case 1: Graph with no cycles (A -> B -> C)
graph1 = {
    'A': ['B'],
    'B': ['C'],
    'C': []
}

# Test case 2: Graph with a simple cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

# Test case 3: Disconnected components with one having a cycle (D -> E; F -> G -> H -> F)
graph3 = {
    'D': ['E'],
    'E': [],
    'F': ['G'],
    'G': ['H'],
    'H': ['F']
}

# Test case 4: Empty graph (no nodes)
graph4 = {}

# Execute test cases and print results

print(funcImp(graph1))   # Expected output: False (no cycles)
print(funcImp(graph2))   # Expected output: True (contains a cycle)
print(funcImp(graph3))   # Expected output: True (contains a cycle in one component)
print(funcImp(graph4))   # Expected output: False (empty graph)

```","{'D': ['E'], 'E': [], 'F': ['G'], 'G': ['H'], 'H': ['F']}",TRUE,TRUE,PASS,TRUE,
30,3,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determine if a directed graph contains a cycle using depth-first search.
    
    :param graph: A dictionary representing the adjacency list of the graph.
                  The keys are node identifiers and the values are lists of nodes
                  that each key node has edges to.
    :return: True if there is a cycle in the graph, False otherwise.
    """"""
    
    # Helper function for DFS
    def dfs(node):
        # If we're visiting an already visited node that's still in recursion stack, there's a cycle
        if visited[node] == 1:
            return True
        # If it's fully processed, no need to visit again
        if visited[node] == 2:
            return False
        
        # Mark the current node as being visited (part of recursion stack)
        visited[node] = 1
        
        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True
        
        # Mark the current node as fully processed
        visited[node] = 2
        return False
    
    # Dictionary to keep track of visit status: 0 = unvisited, 1 = visiting, 2 = fully processed
    visited = {node: 0 for node in graph}
    
    # Check each component of the graph
    for node in graph:
        if visited[node] == 0:  # Unvisited nodes only
            if dfs(node):
                return True
    
    return False

# Test cases to verify our solution

# Test case 1: Graph with no cycles (A -> B -> C)
graph1 = {
    'A': ['B'],
    'B': ['C'],
    'C': []
}

# Test case 2: Graph with a simple cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

# Test case 3: Disconnected components with one having a cycle (D -> E; F -> G -> H -> F)
graph3 = {
    'D': ['E'],
    'E': [],
    'F': ['G'],
    'G': ['H'],
    'H': ['F']
}

# Test case 4: Empty graph (no nodes)
graph4 = {}

# Execute test cases and print results

print(funcImp(graph1))   # Expected output: False (no cycles)
print(funcImp(graph2))   # Expected output: True (contains a cycle)
print(funcImp(graph3))   # Expected output: True (contains a cycle in one component)
print(funcImp(graph4))   # Expected output: False (empty graph)

```",{},FALSE,FALSE,PASS,TRUE,
31,0,medium,"Graph traversal (depth-first search, breadth-first search)",Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import heapq

def funcImp(graph, start):
    """"""
    Implements Dijkstra's algorithm to find the shortest path from a single source node
    to all other nodes in a weighted graph.
    
    Parameters:
    - graph: A dictionary where keys are node identifiers and values are lists of tuples,
             each tuple representing (neighbor, weight).
    - start: The starting node for Dijkstra's algorithm.
    
    Returns:
    - A dictionary with nodes as keys and their shortest distance from the start node as values.
    """"""
    
    # Initialize distances with infinity for all nodes except the start node
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    # Priority queue to hold vertices to explore; initialized with the start vertex
    priority_queue = [(0, start)]  # (distance, vertex)
    
    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        
        # If we found a better way already, continue
        if current_distance > distances[current_node]:
            continue
        
        # Explore neighbors
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            
            # Only consider this new path if it's better
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

# Test cases to verify correctness of funcImp

def test_funcImp():
    # Define graphs using adjacency lists
    
    # Graph 1: Simple triangle graph
    graph1 = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2)],
        'C': [('A', 4), ('B', 2)]
    }
    
    assert funcImp(graph1, 'A') == {'A': 0, 'B': 1, 'C': 3}
    
    # Graph 2: More complex graph with multiple paths
    graph2 = {
        'A': [('B', 10), ('C', 3)],
        'B': [('C', 1), ('D', 2)],
        'C': [('B', 4), ('D', 8), ('E', 2)],
        'D': [('E', 7)],
        'E': [('D', 9)]
    }
    
    assert funcImp(graph2, 'A') == {'A': 0, 'B': 7, 'C': 3, 'D': 9, 'E':5}
    
test_funcImp()
print(""All test cases passed!"")

```","{
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2)],
        'C': [('A', 4), ('B', 2)]
    }","{'A': 0, 'B': 1, 'C': 3}","{'A': 0, 'B': 1, 'C': 3}",PASS,TRUE,None
31,1,medium,"Graph traversal (depth-first search, breadth-first search)",Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import heapq

def funcImp(graph, start):
    """"""
    Implements Dijkstra's algorithm to find the shortest path from a single source node
    to all other nodes in a weighted graph.
    
    Parameters:
    - graph: A dictionary where keys are node identifiers and values are lists of tuples,
             each tuple representing (neighbor, weight).
    - start: The starting node for Dijkstra's algorithm.
    
    Returns:
    - A dictionary with nodes as keys and their shortest distance from the start node as values.
    """"""
    
    # Initialize distances with infinity for all nodes except the start node
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    # Priority queue to hold vertices to explore; initialized with the start vertex
    priority_queue = [(0, start)]  # (distance, vertex)
    
    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        
        # If we found a better way already, continue
        if current_distance > distances[current_node]:
            continue
        
        # Explore neighbors
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            
            # Only consider this new path if it's better
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

# Test cases to verify correctness of funcImp

def test_funcImp():
    # Define graphs using adjacency lists
    
    # Graph 1: Simple triangle graph
    graph1 = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2)],
        'C': [('A', 4), ('B', 2)]
    }
    
    assert funcImp(graph1, 'A') == {'A': 0, 'B': 1, 'C': 3}
    
    # Graph 2: More complex graph with multiple paths
    graph2 = {
        'A': [('B', 10), ('C', 3)],
        'B': [('C', 1), ('D', 2)],
        'C': [('B', 4), ('D', 8), ('E', 2)],
        'D': [('E', 7)],
        'E': [('D', 9)]
    }
    
    assert funcImp(graph2, 'A') == {'A': 0, 'B': 7, 'C': 3, 'D': 9, 'E':5}
    
test_funcImp()
print(""All test cases passed!"")

```","{
        'A': [('B', 10), ('C', 3)],
        'B': [('C', 1), ('D', 2)],
        'C': [('B', 4), ('D', 8), ('E', 2)],
        'D': [('E', 7)],
        'E': [('D', 9)]
    }","{'A': 0, 'B': 7, 'C': 3, 'D':9 , 'E' :5}","{'A': 0, 'B': 7, 'C': 3, 'D':9 , 'E' :5}",PASS,TRUE,None
32,0,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    This function checks if an undirected graph is connected using Depth-First Search (DFS).
    
    Parameters:
    - graph: A dictionary representing an adjacency list of the graph.
             The keys are node identifiers, and the values are lists of adjacent nodes.
             
    Returns:
    - True if the graph is connected, False otherwise.
    """"""
    
    # If the graph is empty, it is considered connected
    if not graph:
        return True
    
    # Start DFS from any arbitrary node, here we choose the first key in the dictionary
    start_node = next(iter(graph))
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases to verify the solution

# Test case 1: A simple connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
print(funcImp(graph1))  # Expected output: True

# Test case 2: A disconnected graph with two components
graph2 = {
   'A': ['B'],
   'B': ['A'],
   'C': ['D'],
   'D': ['C']
}
print(funcImp(graph2))  # Expected output: False

# Test case 3: An empty graph (considered connected)
graph3 = {}
print(funcImp(graph3))  # Expected output: True

# Test case 4: A single-node graph (considered connected)
graph4 = {'A': []}
print(funcImp(graph4))  # Expected output: True

# Test case 5: A larger connected graph with more nodes and edges
graph5 = {
   0: [1, 2],
   1: [0, 3],
   2: [0, 3],
   3: [1, 2]
}
print(funcImp(graph5))  # Expected output: True

```","{'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'D'], 'D': ['B', 'C']}",TRUE,TRUE,PASS,TRUE,None
32,1,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    This function checks if an undirected graph is connected using Depth-First Search (DFS).
    
    Parameters:
    - graph: A dictionary representing an adjacency list of the graph.
             The keys are node identifiers, and the values are lists of adjacent nodes.
             
    Returns:
    - True if the graph is connected, False otherwise.
    """"""
    
    # If the graph is empty, it is considered connected
    if not graph:
        return True
    
    # Start DFS from any arbitrary node, here we choose the first key in the dictionary
    start_node = next(iter(graph))
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases to verify the solution

# Test case 1: A simple connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
print(funcImp(graph1))  # Expected output: True

# Test case 2: A disconnected graph with two components
graph2 = {
   'A': ['B'],
   'B': ['A'],
   'C': ['D'],
   'D': ['C']
}
print(funcImp(graph2))  # Expected output: False

# Test case 3: An empty graph (considered connected)
graph3 = {}
print(funcImp(graph3))  # Expected output: True

# Test case 4: A single-node graph (considered connected)
graph4 = {'A': []}
print(funcImp(graph4))  # Expected output: True

# Test case 5: A larger connected graph with more nodes and edges
graph5 = {
   0: [1, 2],
   1: [0, 3],
   2: [0, 3],
   3: [1, 2]
}
print(funcImp(graph5))  # Expected output: True

```","{'A': ['B'], 'B': ['A'], 'C': ['D'], 'D': ['C']}",FALSE,FALSE,PASS,TRUE,None
32,2,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    This function checks if an undirected graph is connected using Depth-First Search (DFS).
    
    Parameters:
    - graph: A dictionary representing an adjacency list of the graph.
             The keys are node identifiers, and the values are lists of adjacent nodes.
             
    Returns:
    - True if the graph is connected, False otherwise.
    """"""
    
    # If the graph is empty, it is considered connected
    if not graph:
        return True
    
    # Start DFS from any arbitrary node, here we choose the first key in the dictionary
    start_node = next(iter(graph))
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases to verify the solution

# Test case 1: A simple connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
print(funcImp(graph1))  # Expected output: True

# Test case 2: A disconnected graph with two components
graph2 = {
   'A': ['B'],
   'B': ['A'],
   'C': ['D'],
   'D': ['C']
}
print(funcImp(graph2))  # Expected output: False

# Test case 3: An empty graph (considered connected)
graph3 = {}
print(funcImp(graph3))  # Expected output: True

# Test case 4: A single-node graph (considered connected)
graph4 = {'A': []}
print(funcImp(graph4))  # Expected output: True

# Test case 5: A larger connected graph with more nodes and edges
graph5 = {
   0: [1, 2],
   1: [0, 3],
   2: [0, 3],
   3: [1, 2]
}
print(funcImp(graph5))  # Expected output: True

```",{},TRUE,TRUE,PASS,TRUE,None
32,3,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    This function checks if an undirected graph is connected using Depth-First Search (DFS).
    
    Parameters:
    - graph: A dictionary representing an adjacency list of the graph.
             The keys are node identifiers, and the values are lists of adjacent nodes.
             
    Returns:
    - True if the graph is connected, False otherwise.
    """"""
    
    # If the graph is empty, it is considered connected
    if not graph:
        return True
    
    # Start DFS from any arbitrary node, here we choose the first key in the dictionary
    start_node = next(iter(graph))
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases to verify the solution

# Test case 1: A simple connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
print(funcImp(graph1))  # Expected output: True

# Test case 2: A disconnected graph with two components
graph2 = {
   'A': ['B'],
   'B': ['A'],
   'C': ['D'],
   'D': ['C']
}
print(funcImp(graph2))  # Expected output: False

# Test case 3: An empty graph (considered connected)
graph3 = {}
print(funcImp(graph3))  # Expected output: True

# Test case 4: A single-node graph (considered connected)
graph4 = {'A': []}
print(funcImp(graph4))  # Expected output: True

# Test case 5: A larger connected graph with more nodes and edges
graph5 = {
   0: [1, 2],
   1: [0, 3],
   2: [0, 3],
   3: [1, 2]
}
print(funcImp(graph5))  # Expected output: True

```",{'A': []},TRUE,TRUE,PASS,TRUE,None
32,4,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    This function checks if an undirected graph is connected using Depth-First Search (DFS).
    
    Parameters:
    - graph: A dictionary representing an adjacency list of the graph.
             The keys are node identifiers, and the values are lists of adjacent nodes.
             
    Returns:
    - True if the graph is connected, False otherwise.
    """"""
    
    # If the graph is empty, it is considered connected
    if not graph:
        return True
    
    # Start DFS from any arbitrary node, here we choose the first key in the dictionary
    start_node = next(iter(graph))
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases to verify the solution

# Test case 1: A simple connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
print(funcImp(graph1))  # Expected output: True

# Test case 2: A disconnected graph with two components
graph2 = {
   'A': ['B'],
   'B': ['A'],
   'C': ['D'],
   'D': ['C']
}
print(funcImp(graph2))  # Expected output: False

# Test case 3: An empty graph (considered connected)
graph3 = {}
print(funcImp(graph3))  # Expected output: True

# Test case 4: A single-node graph (considered connected)
graph4 = {'A': []}
print(funcImp(graph4))  # Expected output: True

# Test case 5: A larger connected graph with more nodes and edges
graph5 = {
   0: [1, 2],
   1: [0, 3],
   2: [0, 3],
   3: [1, 2]
}
print(funcImp(graph5))  # Expected output: True

```","{0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}",TRUE,TRUE,PASS,TRUE,None
33,0,medium,"Graph traversal (depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Perform topological sorting on a directed acyclic graph using depth-first search.
    
    Parameters:
    - graph: A dictionary representing the adjacency list of the DAG. 
             The keys are node identifiers, and the values are lists of nodes that each key has edges to.
             
    Returns:
    - A list representing one possible topological order of the nodes.
    """"""
    
    # Helper function to perform DFS
    def dfs(node):
        nonlocal visited, stack, cycle_detected
        
        if cycle_detected:  # If a cycle is detected, stop further processing
            return
        
        visited[node] = True  # Mark the current node as visited
        recursion_stack[node] = True  # Add to recursion stack
        
        for neighbor in graph.get(node, []):  # Visit all neighbors
            if not visited[neighbor]:  # If neighbor hasn't been visited yet
                dfs(neighbor)
            elif recursion_stack[neighbor]:  # If neighbor is in recursion stack, we have a cycle
                cycle_detected = True
        
        recursion_stack[node] = False  # Remove from recursion stack after visiting all neighbors
        stack.append(node)  # Add node to stack which stores result
    
    visited = {node: False for node in graph}  # Track visited nodes
    recursion_stack = {node: False for node in graph}  # Track nodes in current path (recursion stack)
    stack = []  # Stack to store result (topologically sorted order)
    
    cycle_detected = False
    
    for node in graph:
        if not visited[node]:
            dfs(node)
        
        if cycle_detected:
            raise ValueError(""Graph is not a DAG; it contains at least one cycle."")
    
    return stack[::-1]  # Return reversed stack as topological order

# Test cases

# Example DAG with no cycles
graph1 = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': [],
    'F': []
}

# Another example DAG with no cycles
graph2 = {
   '5': ['11'],
   '7': ['11', '8'],
   '3': ['8', '10'],
   '11': ['2', '9', '10'],
   '8': ['9'],
   '2': [],
   '9': [],
   '10': []
}

print(""Topological Sort of Graph1:"", funcImp(graph1))
print(""Topological Sort of Graph2:"", funcImp(graph2))

# Edge case: Empty graph should return an empty list
empty_graph = {}
print(""Topological Sort of Empty Graph:"", funcImp(empty_graph))

# Edge case: Single node with no edges should return just that node
single_node_graph = {'A': []}
print(""Topological Sort of Single Node Graph:"", funcImp(single_node_graph))
```","{'A': ['C'], 'B': ['C', 'D'], 'C': ['E'], 'D': ['F'], 'E': [], 'F': []}","['B', 'A', 'D', 'C', 'F', 'E']","['B', 'D', 'F', 'A', 'C', 'E']",FAIL,FALSE,
33,1,medium,"Graph traversal (depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Perform topological sorting on a directed acyclic graph using depth-first search.
    
    Parameters:
    - graph: A dictionary representing the adjacency list of the DAG. 
             The keys are node identifiers, and the values are lists of nodes that each key has edges to.
             
    Returns:
    - A list representing one possible topological order of the nodes.
    """"""
    
    # Helper function to perform DFS
    def dfs(node):
        nonlocal visited, stack, cycle_detected
        
        if cycle_detected:  # If a cycle is detected, stop further processing
            return
        
        visited[node] = True  # Mark the current node as visited
        recursion_stack[node] = True  # Add to recursion stack
        
        for neighbor in graph.get(node, []):  # Visit all neighbors
            if not visited[neighbor]:  # If neighbor hasn't been visited yet
                dfs(neighbor)
            elif recursion_stack[neighbor]:  # If neighbor is in recursion stack, we have a cycle
                cycle_detected = True
        
        recursion_stack[node] = False  # Remove from recursion stack after visiting all neighbors
        stack.append(node)  # Add node to stack which stores result
    
    visited = {node: False for node in graph}  # Track visited nodes
    recursion_stack = {node: False for node in graph}  # Track nodes in current path (recursion stack)
    stack = []  # Stack to store result (topologically sorted order)
    
    cycle_detected = False
    
    for node in graph:
        if not visited[node]:
            dfs(node)
        
        if cycle_detected:
            raise ValueError(""Graph is not a DAG; it contains at least one cycle."")
    
    return stack[::-1]  # Return reversed stack as topological order

# Test cases

# Example DAG with no cycles
graph1 = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': [],
    'F': []
}

# Another example DAG with no cycles
graph2 = {
   '5': ['11'],
   '7': ['11', '8'],
   '3': ['8', '10'],
   '11': ['2', '9', '10'],
   '8': ['9'],
   '2': [],
   '9': [],
   '10': []
}

print(""Topological Sort of Graph1:"", funcImp(graph1))
print(""Topological Sort of Graph2:"", funcImp(graph2))

# Edge case: Empty graph should return an empty list
empty_graph = {}
print(""Topological Sort of Empty Graph:"", funcImp(empty_graph))

# Edge case: Single node with no edges should return just that node
single_node_graph = {'A': []}
print(""Topological Sort of Single Node Graph:"", funcImp(single_node_graph))
```","{'5': ['11'], '7': ['11', '8'], '3': ['8', '10'], '11': ['2', '9', '10'], '8': ['9'], '2': [], '9': [], '10': []}","['7', '5', '3', '11', '8', '10', '9', '2']","['3', '7', '8', '5', '11', '10', '9', '2']",FAIL,FALSE,
33,2,medium,"Graph traversal (depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Perform topological sorting on a directed acyclic graph using depth-first search.
    
    Parameters:
    - graph: A dictionary representing the adjacency list of the DAG. 
             The keys are node identifiers, and the values are lists of nodes that each key has edges to.
             
    Returns:
    - A list representing one possible topological order of the nodes.
    """"""
    
    # Helper function to perform DFS
    def dfs(node):
        nonlocal visited, stack, cycle_detected
        
        if cycle_detected:  # If a cycle is detected, stop further processing
            return
        
        visited[node] = True  # Mark the current node as visited
        recursion_stack[node] = True  # Add to recursion stack
        
        for neighbor in graph.get(node, []):  # Visit all neighbors
            if not visited[neighbor]:  # If neighbor hasn't been visited yet
                dfs(neighbor)
            elif recursion_stack[neighbor]:  # If neighbor is in recursion stack, we have a cycle
                cycle_detected = True
        
        recursion_stack[node] = False  # Remove from recursion stack after visiting all neighbors
        stack.append(node)  # Add node to stack which stores result
    
    visited = {node: False for node in graph}  # Track visited nodes
    recursion_stack = {node: False for node in graph}  # Track nodes in current path (recursion stack)
    stack = []  # Stack to store result (topologically sorted order)
    
    cycle_detected = False
    
    for node in graph:
        if not visited[node]:
            dfs(node)
        
        if cycle_detected:
            raise ValueError(""Graph is not a DAG; it contains at least one cycle."")
    
    return stack[::-1]  # Return reversed stack as topological order

# Test cases

# Example DAG with no cycles
graph1 = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': [],
    'F': []
}

# Another example DAG with no cycles
graph2 = {
   '5': ['11'],
   '7': ['11', '8'],
   '3': ['8', '10'],
   '11': ['2', '9', '10'],
   '8': ['9'],
   '2': [],
   '9': [],
   '10': []
}

print(""Topological Sort of Graph1:"", funcImp(graph1))
print(""Topological Sort of Graph2:"", funcImp(graph2))

# Edge case: Empty graph should return an empty list
empty_graph = {}
print(""Topological Sort of Empty Graph:"", funcImp(empty_graph))

# Edge case: Single node with no edges should return just that node
single_node_graph = {'A': []}
print(""Topological Sort of Single Node Graph:"", funcImp(single_node_graph))
```",{},[],[],PASS,TRUE,
33,3,medium,"Graph traversal (depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Perform topological sorting on a directed acyclic graph using depth-first search.
    
    Parameters:
    - graph: A dictionary representing the adjacency list of the DAG. 
             The keys are node identifiers, and the values are lists of nodes that each key has edges to.
             
    Returns:
    - A list representing one possible topological order of the nodes.
    """"""
    
    # Helper function to perform DFS
    def dfs(node):
        nonlocal visited, stack, cycle_detected
        
        if cycle_detected:  # If a cycle is detected, stop further processing
            return
        
        visited[node] = True  # Mark the current node as visited
        recursion_stack[node] = True  # Add to recursion stack
        
        for neighbor in graph.get(node, []):  # Visit all neighbors
            if not visited[neighbor]:  # If neighbor hasn't been visited yet
                dfs(neighbor)
            elif recursion_stack[neighbor]:  # If neighbor is in recursion stack, we have a cycle
                cycle_detected = True
        
        recursion_stack[node] = False  # Remove from recursion stack after visiting all neighbors
        stack.append(node)  # Add node to stack which stores result
    
    visited = {node: False for node in graph}  # Track visited nodes
    recursion_stack = {node: False for node in graph}  # Track nodes in current path (recursion stack)
    stack = []  # Stack to store result (topologically sorted order)
    
    cycle_detected = False
    
    for node in graph:
        if not visited[node]:
            dfs(node)
        
        if cycle_detected:
            raise ValueError(""Graph is not a DAG; it contains at least one cycle."")
    
    return stack[::-1]  # Return reversed stack as topological order

# Test cases

# Example DAG with no cycles
graph1 = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': [],
    'F': []
}

# Another example DAG with no cycles
graph2 = {
   '5': ['11'],
   '7': ['11', '8'],
   '3': ['8', '10'],
   '11': ['2', '9', '10'],
   '8': ['9'],
   '2': [],
   '9': [],
   '10': []
}

print(""Topological Sort of Graph1:"", funcImp(graph1))
print(""Topological Sort of Graph2:"", funcImp(graph2))

# Edge case: Empty graph should return an empty list
empty_graph = {}
print(""Topological Sort of Empty Graph:"", funcImp(empty_graph))

# Edge case: Single node with no edges should return just that node
single_node_graph = {'A': []}
print(""Topological Sort of Single Node Graph:"", funcImp(single_node_graph))
```",{'A': []},['A'],['A'],PASS,TRUE,
34,0,medium,"Graph traversal (depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end):
    """"""
    Find all paths from 'start' to 'end' in an undirected graph using DFS.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    :param start: The starting node for paths.
    :param end: The ending node for paths.
    :return: A list of lists, where each inner list is a path from 'start' to 'end'.
    """"""
    
    def dfs(current_node, path):
        # Add current node to the path
        path.append(current_node)
        
        # If current node is the end node, add the path to results
        if current_node == end:
            results.append(path.copy())
        else:
            # Explore neighbors that haven't been visited yet
            for neighbor in graph.get(current_node, []):
                if neighbor not in path:
                    dfs(neighbor, path)
        
        # Backtrack by removing the current node from path
        path.pop()
    
    results = []
    dfs(start, [])
    
    return results

# Test cases to verify our solution

# Example Graph:
# A -- B -- C
# |         |
# D --------E

graph = {
    'A': ['B', 'D'],
    'B': ['A', 'C'],
    'C': ['B', 'E'],
    'D': ['A', 'E'],
    'E': ['D', 'C']
}

# Test case 1: Find all paths from A to E
print(""Paths from A to E:"", funcImp(graph, 'A', 'E'))

# Test case 2: Find all paths from B to D
print(""Paths from B to D:"", funcImp(graph, 'B', 'D'))

# Test case 3: Find all paths from C to A (should be empty since no direct connection)
print(""Paths from C to A:"", funcImp(graph, 'C', 'A'))
```","start=A, end=E","[['A', 'B', 'C', 'E'], ['A', 'D', 'E']]","[['A', 'B', 'C', 'E'], ['A', 'D', 'E']]",PASS,TRUE,
34,1,medium,"Graph traversal (depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end):
    """"""
    Find all paths from 'start' to 'end' in an undirected graph using DFS.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    :param start: The starting node for paths.
    :param end: The ending node for paths.
    :return: A list of lists, where each inner list is a path from 'start' to 'end'.
    """"""
    
    def dfs(current_node, path):
        # Add current node to the path
        path.append(current_node)
        
        # If current node is the end node, add the path to results
        if current_node == end:
            results.append(path.copy())
        else:
            # Explore neighbors that haven't been visited yet
            for neighbor in graph.get(current_node, []):
                if neighbor not in path:
                    dfs(neighbor, path)
        
        # Backtrack by removing the current node from path
        path.pop()
    
    results = []
    dfs(start, [])
    
    return results

# Test cases to verify our solution

# Example Graph:
# A -- B -- C
# |         |
# D --------E

graph = {
    'A': ['B', 'D'],
    'B': ['A', 'C'],
    'C': ['B', 'E'],
    'D': ['A', 'E'],
    'E': ['D', 'C']
}

# Test case 1: Find all paths from A to E
print(""Paths from A to E:"", funcImp(graph, 'A', 'E'))

# Test case 2: Find all paths from B to D
print(""Paths from B to D:"", funcImp(graph, 'B', 'D'))

# Test case 3: Find all paths from C to A (should be empty since no direct connection)
print(""Paths from C to A:"", funcImp(graph, 'C', 'A'))
```","start=B, end=D","[['B', 'A', 'D'], ['B', 'C', 'E', 'D']]","[['B', 'A', 'D'], ['B', 'C', 'E', 'D']]",PASS,TRUE,
34,2,medium,"Graph traversal (depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end):
    """"""
    Find all paths from 'start' to 'end' in an undirected graph using DFS.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    :param start: The starting node for paths.
    :param end: The ending node for paths.
    :return: A list of lists, where each inner list is a path from 'start' to 'end'.
    """"""
    
    def dfs(current_node, path):
        # Add current node to the path
        path.append(current_node)
        
        # If current node is the end node, add the path to results
        if current_node == end:
            results.append(path.copy())
        else:
            # Explore neighbors that haven't been visited yet
            for neighbor in graph.get(current_node, []):
                if neighbor not in path:
                    dfs(neighbor, path)
        
        # Backtrack by removing the current node from path
        path.pop()
    
    results = []
    dfs(start, [])
    
    return results

# Test cases to verify our solution

# Example Graph:
# A -- B -- C
# |         |
# D --------E

graph = {
    'A': ['B', 'D'],
    'B': ['A', 'C'],
    'C': ['B', 'E'],
    'D': ['A', 'E'],
    'E': ['D', 'C']
}

# Test case 1: Find all paths from A to E
print(""Paths from A to E:"", funcImp(graph, 'A', 'E'))

# Test case 2: Find all paths from B to D
print(""Paths from B to D:"", funcImp(graph, 'B', 'D'))

# Test case 3: Find all paths from C to A (should be empty since no direct connection)
print(""Paths from C to A:"", funcImp(graph, 'C', 'A'))
```","start=C, end=A",[],"[['C', 'B', 'A'], ['C', 'E', 'D', 'A']]",FAIL,FALSE,
35,0,medium,"Graph traversal (depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Detects and prints all cycles in an undirected graph using depth-first search.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    """"""
    def dfs(v, parent):
        # Mark the current node as visited
        visited[v] = True
        # Add it to the current path
        path.append(v)
        
        # Explore each neighbor
        for neighbor in graph[v]:
            if not visited[neighbor]:
                # Recur for DFS on unvisited neighbors
                dfs(neighbor, v)
            elif neighbor != parent:
                # Found a back edge indicating a cycle
                cycle_start_index = path.index(neighbor)
                cycle = path[cycle_start_index:]
                cycles.append(cycle)
        
        # Backtrack - remove current vertex from path
        path.pop()
    
    visited = {node: False for node in graph}
    cycles = []
    
    for node in graph:
        if not visited[node]:
            path = []
            dfs(node, None)
    
    # Print all unique cycles found
    unique_cycles = set(tuple(sorted(cycle)) for cycle in cycles)
    
    print(""Cycles found:"")
    for cycle in unique_cycles:
        print(list(cycle))

# Test cases

# Example 1: Simple triangle cycle
graph1 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1]
}

# Example 2: Graph with two separate triangles (two separate cycles)
graph2 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1],
    3: [4, 5],
    4: [3, 5],
    5: [3, 4]
}

# Example 3: Complex graph with multiple overlapping cycles
graph3 = {
   'A': ['B', 'C'],
   'B': ['A', 'D', 'E'],
   'C': ['A', 'F'],
   'D': ['B', 'E'],
   'E': ['B', 'D'],
   'F': ['C']
}

print(""Test Case - Graph with one simple triangle:"")
funcImp(graph1)

print(""\nTest Case - Graph with two separate triangles:"")
funcImp(graph2)

print(""\nTest Case - Complex Graph with multiple overlapping cycles:"")
funcImp(graph3)
```",,,,FAIL,FALSE,2 is not in list
35,1,medium,"Graph traversal (depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Detects and prints all cycles in an undirected graph using depth-first search.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    """"""
    def dfs(v, parent):
        # Mark the current node as visited
        visited[v] = True
        # Add it to the current path
        path.append(v)
        
        # Explore each neighbor
        for neighbor in graph[v]:
            if not visited[neighbor]:
                # Recur for DFS on unvisited neighbors
                dfs(neighbor, v)
            elif neighbor != parent:
                # Found a back edge indicating a cycle
                cycle_start_index = path.index(neighbor)
                cycle = path[cycle_start_index:]
                cycles.append(cycle)
        
        # Backtrack - remove current vertex from path
        path.pop()
    
    visited = {node: False for node in graph}
    cycles = []
    
    for node in graph:
        if not visited[node]:
            path = []
            dfs(node, None)
    
    # Print all unique cycles found
    unique_cycles = set(tuple(sorted(cycle)) for cycle in cycles)
    
    print(""Cycles found:"")
    for cycle in unique_cycles:
        print(list(cycle))

# Test cases

# Example 1: Simple triangle cycle
graph1 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1]
}

# Example 2: Graph with two separate triangles (two separate cycles)
graph2 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1],
    3: [4, 5],
    4: [3, 5],
    5: [3, 4]
}

# Example 3: Complex graph with multiple overlapping cycles
graph3 = {
   'A': ['B', 'C'],
   'B': ['A', 'D', 'E'],
   'C': ['A', 'F'],
   'D': ['B', 'E'],
   'E': ['B', 'D'],
   'F': ['C']
}

print(""Test Case - Graph with one simple triangle:"")
funcImp(graph1)

print(""\nTest Case - Graph with two separate triangles:"")
funcImp(graph2)

print(""\nTest Case - Complex Graph with multiple overlapping cycles:"")
funcImp(graph3)
```",,,,FAIL,FALSE,2 is not in list
35,2,medium,"Graph traversal (depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Detects and prints all cycles in an undirected graph using depth-first search.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    """"""
    def dfs(v, parent):
        # Mark the current node as visited
        visited[v] = True
        # Add it to the current path
        path.append(v)
        
        # Explore each neighbor
        for neighbor in graph[v]:
            if not visited[neighbor]:
                # Recur for DFS on unvisited neighbors
                dfs(neighbor, v)
            elif neighbor != parent:
                # Found a back edge indicating a cycle
                cycle_start_index = path.index(neighbor)
                cycle = path[cycle_start_index:]
                cycles.append(cycle)
        
        # Backtrack - remove current vertex from path
        path.pop()
    
    visited = {node: False for node in graph}
    cycles = []
    
    for node in graph:
        if not visited[node]:
            path = []
            dfs(node, None)
    
    # Print all unique cycles found
    unique_cycles = set(tuple(sorted(cycle)) for cycle in cycles)
    
    print(""Cycles found:"")
    for cycle in unique_cycles:
        print(list(cycle))

# Test cases

# Example 1: Simple triangle cycle
graph1 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1]
}

# Example 2: Graph with two separate triangles (two separate cycles)
graph2 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1],
    3: [4, 5],
    4: [3, 5],
    5: [3, 4]
}

# Example 3: Complex graph with multiple overlapping cycles
graph3 = {
   'A': ['B', 'C'],
   'B': ['A', 'D', 'E'],
   'C': ['A', 'F'],
   'D': ['B', 'E'],
   'E': ['B', 'D'],
   'F': ['C']
}

print(""Test Case - Graph with one simple triangle:"")
funcImp(graph1)

print(""\nTest Case - Graph with two separate triangles:"")
funcImp(graph2)

print(""\nTest Case - Complex Graph with multiple overlapping cycles:"")
funcImp(graph3)
```",,,,FAIL,FALSE,'E' is not in list
36,0,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start_node, end_node):
    """"""
    Determine if there exists a path between two nodes in an undirected graph using BFS.
    
    :param graph: A dictionary representing an adjacency list of the graph.
                  Keys are node identifiers and values are lists of adjacent nodes.
    :param start_node: The node from which to start the search.
    :param end_node: The target node to find a path to.
    :return: True if there is a path from start_node to end_node, False otherwise.
    """"""
    
    # If the start or end node is not in the graph, return False
    if start_node not in graph or end_node not in graph:
        return False
    
    # Use a queue for BFS
    queue = deque([start_node])
    
    # Set to keep track of visited nodes
    visited = set()
    
    while queue:
        current = queue.popleft()
        
        # If we reach the end node, return True
        if current == end_node:
            return True
        
        # Mark the current node as visited
        visited.add(current)
        
        # Add all unvisited neighbors to the queue
        for neighbor in graph[current]:
            if neighbor not in visited:
                queue.append(neighbor)
                
    # If we've exhausted all possibilities and haven't found the end node, return False
    return False

# Test cases to verify that funcImp works correctly

# Example Graph (Undirected)
# 1 -- 2 -- 3
# |         |
# 4 ------- 5

graph = {
    1: [2, 4],
    2: [1, 3],
    3: [2, 5],
    4: [1, 5],
    5: [3, 4]
}

# Test case where there is a direct path
print(funcImp(graph, 1, 3)) # Expected output: True

# Test case where there is no direct connection but still reachable through other nodes
print(funcImp(graph, 1, 5)) # Expected output: True

# Test case where both nodes are same (trivial path)
print(funcImp(graph, 1, 1)) # Expected output: True

# Test case where one of the nodes does not exist in the graph
print(funcImp(graph, 6, 3)) # Expected output: False

# Test case with disconnected components (if any were present)
disconnected_graph = {
   'A': ['B'],
   'B': ['A'],
   'C': []
}

print(funcImp(disconnected_graph,'A','C')) # Expected output: False

```","Graph={1: [2, 4], 2: [1, 3], 3: [2, 5], 4: [1, 5], 5: [3, 4]}, Start=1, End=3",TRUE,TRUE,PASS,TRUE,
36,1,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start_node, end_node):
    """"""
    Determine if there exists a path between two nodes in an undirected graph using BFS.
    
    :param graph: A dictionary representing an adjacency list of the graph.
                  Keys are node identifiers and values are lists of adjacent nodes.
    :param start_node: The node from which to start the search.
    :param end_node: The target node to find a path to.
    :return: True if there is a path from start_node to end_node, False otherwise.
    """"""
    
    # If the start or end node is not in the graph, return False
    if start_node not in graph or end_node not in graph:
        return False
    
    # Use a queue for BFS
    queue = deque([start_node])
    
    # Set to keep track of visited nodes
    visited = set()
    
    while queue:
        current = queue.popleft()
        
        # If we reach the end node, return True
        if current == end_node:
            return True
        
        # Mark the current node as visited
        visited.add(current)
        
        # Add all unvisited neighbors to the queue
        for neighbor in graph[current]:
            if neighbor not in visited:
                queue.append(neighbor)
                
    # If we've exhausted all possibilities and haven't found the end node, return False
    return False

# Test cases to verify that funcImp works correctly

# Example Graph (Undirected)
# 1 -- 2 -- 3
# |         |
# 4 ------- 5

graph = {
    1: [2, 4],
    2: [1, 3],
    3: [2, 5],
    4: [1, 5],
    5: [3, 4]
}

# Test case where there is a direct path
print(funcImp(graph, 1, 3)) # Expected output: True

# Test case where there is no direct connection but still reachable through other nodes
print(funcImp(graph, 1, 5)) # Expected output: True

# Test case where both nodes are same (trivial path)
print(funcImp(graph, 1, 1)) # Expected output: True

# Test case where one of the nodes does not exist in the graph
print(funcImp(graph, 6, 3)) # Expected output: False

# Test case with disconnected components (if any were present)
disconnected_graph = {
   'A': ['B'],
   'B': ['A'],
   'C': []
}

print(funcImp(disconnected_graph,'A','C')) # Expected output: False

```","Graph={1: [2, 4], 2: [1, 3], 3: [2, 5], 4: [1, 5], 5: [3, 4]}, Start=1, End=5",TRUE,TRUE,PASS,TRUE,
36,2,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start_node, end_node):
    """"""
    Determine if there exists a path between two nodes in an undirected graph using BFS.
    
    :param graph: A dictionary representing an adjacency list of the graph.
                  Keys are node identifiers and values are lists of adjacent nodes.
    :param start_node: The node from which to start the search.
    :param end_node: The target node to find a path to.
    :return: True if there is a path from start_node to end_node, False otherwise.
    """"""
    
    # If the start or end node is not in the graph, return False
    if start_node not in graph or end_node not in graph:
        return False
    
    # Use a queue for BFS
    queue = deque([start_node])
    
    # Set to keep track of visited nodes
    visited = set()
    
    while queue:
        current = queue.popleft()
        
        # If we reach the end node, return True
        if current == end_node:
            return True
        
        # Mark the current node as visited
        visited.add(current)
        
        # Add all unvisited neighbors to the queue
        for neighbor in graph[current]:
            if neighbor not in visited:
                queue.append(neighbor)
                
    # If we've exhausted all possibilities and haven't found the end node, return False
    return False

# Test cases to verify that funcImp works correctly

# Example Graph (Undirected)
# 1 -- 2 -- 3
# |         |
# 4 ------- 5

graph = {
    1: [2, 4],
    2: [1, 3],
    3: [2, 5],
    4: [1, 5],
    5: [3, 4]
}

# Test case where there is a direct path
print(funcImp(graph, 1, 3)) # Expected output: True

# Test case where there is no direct connection but still reachable through other nodes
print(funcImp(graph, 1, 5)) # Expected output: True

# Test case where both nodes are same (trivial path)
print(funcImp(graph, 1, 1)) # Expected output: True

# Test case where one of the nodes does not exist in the graph
print(funcImp(graph, 6, 3)) # Expected output: False

# Test case with disconnected components (if any were present)
disconnected_graph = {
   'A': ['B'],
   'B': ['A'],
   'C': []
}

print(funcImp(disconnected_graph,'A','C')) # Expected output: False

```","Graph={1: [2, 4], 2: [1, 3], 3: [2, 5], 4: [1, 5], 5: [3, 4]}, Start=1, End=1",TRUE,TRUE,PASS,TRUE,
37,0,medium,"Graph traversal (depth-first search, breadth-first search)","Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.","## Problem Statement
- Develop a Python script to solve the problem: 'Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class DisjointSet:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        rootU = self.find(u)
        rootV = self.find(v)
        
        if rootU != rootV:
            # Union by rank
            if self.rank[rootU] > self.rank[rootV]:
                self.parent[rootV] = rootU
            elif self.rank[rootU] < self.rank[rootV]:
                self.parent[rootU] = rootV
            else:
                self.parent[rootV] = rootU
                self.rank[rootU] += 1

def funcImp(vertices, edges):
    """"""
    Function to find Minimum Spanning Tree using Kruskal's Algorithm.
    
    :param vertices: Number of vertices in the graph.
    :param edges: List of tuples representing edges (u, v, weight).
                  Each tuple is (start_vertex, end_vertex, weight).
    
    :return: List of tuples representing edges in the Minimum Spanning Tree.
             Each tuple is (start_vertex, end_vertex, weight).
    """"""
    
    # Step 1: Sort all edges based on their weights
    sorted_edges = sorted(edges, key=lambda edge: edge[2])
    
    # Step 2: Create disjoint sets for each vertex
    ds = DisjointSet(vertices)
    
    mst_edges = []  # This will store the resultant MST
    
    # Step 3: Iterate over sorted edges and apply union-find logic
    for u, v, weight in sorted_edges:
        if ds.find(u) != ds.find(v):  # If adding this edge doesn't cause a cycle
            ds.union(u, v)           # Union these two sets
            mst_edges.append((u, v, weight))  # Add this edge to MST
    
        if len(mst_edges) == vertices - 1:  # If we have V-1 edges in our MST already
            break
    
    return mst_edges

# Test cases to verify correctness

# Example test case with four nodes and five weighted edges forming a connected graph.
vertices_count = 4
edges_list = [
    (0, 1, 10),
    (0, 2, 6),
    (0, 3, 5),
    (1, 3, 15),
    (2, 3, 4)
]

# Expected output should be [(2-3), (0-3), (0-1)] or similar depending on sorting but with same total weight.
print(""Minimum Spanning Tree:"", funcImp(vertices_count ,edges_list))

```","vertices=4, edges=[(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]","[(2, 3), (0, 3), (0, 1)]","[(2, 3, 4), (0, 3, 5), (0, 1, 10)]",PASS,TRUE,
38,0,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n, edges):
    """"""
    Count the number of connected components in an undirected graph.
    
    :param n: Number of nodes in the graph
    :param edges: List of edges where each edge is represented by a tuple (u, v)
    :return: Number of connected components
    """"""
    
    # Create an adjacency list for the graph
    adj_list = {i: [] for i in range(n)}
    
    # Populate the adjacency list with edges
    for u, v in edges:
        adj_list[u].append(v)
        adj_list[v].append(u)
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Perform DFS starting from node.""""""
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                # Add all unvisited neighbors to the stack
                for neighbor in adj_list[current]:
                    if neighbor not in visited:
                        stack.append(neighbor)

    # Count connected components
    num_components = 0
    
    # Iterate through each node to ensure all are covered
    for i in range(n):
        if i not in visited:
            # If node i is not visited, it's part of a new component
            dfs(i)
            num_components += 1
    
    return num_components

# Test cases to verify our solution

# Test case 1: A simple graph with two separate components
n1 = 5
edges1 = [(0, 1), (2, 3)]
print(funcImp(n1, edges1))  # Expected output: 3

# Test case 2: A fully connected graph (one component)
n2 = 4
edges2 = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
print(funcImp(n2, edges2))  # Expected output: 1

# Test case 3: No edges at all; every node is its own component
n3 = 4
edges3 = []
print(funcImp(n3, edges3))  # Expected output: 4

# Test case 4: Single node with no connections should be one component by itself.
n4 = 1
edges4 = []
print(funcImp(n4, edges4))   # Expected output: 1

# Test case with more complex structure 
n5 = 6 
edges5 = [(0,1),(0,2),(3,4)]
print(funcImp(n5 ,edges5))   # Expected output :3 
```","n=5, edges=[(0, 1), (2, 3)]",3,3,PASS,TRUE,
38,1,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n, edges):
    """"""
    Count the number of connected components in an undirected graph.
    
    :param n: Number of nodes in the graph
    :param edges: List of edges where each edge is represented by a tuple (u, v)
    :return: Number of connected components
    """"""
    
    # Create an adjacency list for the graph
    adj_list = {i: [] for i in range(n)}
    
    # Populate the adjacency list with edges
    for u, v in edges:
        adj_list[u].append(v)
        adj_list[v].append(u)
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Perform DFS starting from node.""""""
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                # Add all unvisited neighbors to the stack
                for neighbor in adj_list[current]:
                    if neighbor not in visited:
                        stack.append(neighbor)

    # Count connected components
    num_components = 0
    
    # Iterate through each node to ensure all are covered
    for i in range(n):
        if i not in visited:
            # If node i is not visited, it's part of a new component
            dfs(i)
            num_components += 1
    
    return num_components

# Test cases to verify our solution

# Test case 1: A simple graph with two separate components
n1 = 5
edges1 = [(0, 1), (2, 3)]
print(funcImp(n1, edges1))  # Expected output: 3

# Test case 2: A fully connected graph (one component)
n2 = 4
edges2 = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
print(funcImp(n2, edges2))  # Expected output: 1

# Test case 3: No edges at all; every node is its own component
n3 = 4
edges3 = []
print(funcImp(n3, edges3))  # Expected output: 4

# Test case 4: Single node with no connections should be one component by itself.
n4 = 1
edges4 = []
print(funcImp(n4, edges4))   # Expected output: 1

# Test case with more complex structure 
n5 = 6 
edges5 = [(0,1),(0,2),(3,4)]
print(funcImp(n5 ,edges5))   # Expected output :3 
```","n=4, edges=[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]",1,1,PASS,TRUE,
38,2,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n, edges):
    """"""
    Count the number of connected components in an undirected graph.
    
    :param n: Number of nodes in the graph
    :param edges: List of edges where each edge is represented by a tuple (u, v)
    :return: Number of connected components
    """"""
    
    # Create an adjacency list for the graph
    adj_list = {i: [] for i in range(n)}
    
    # Populate the adjacency list with edges
    for u, v in edges:
        adj_list[u].append(v)
        adj_list[v].append(u)
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Perform DFS starting from node.""""""
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                # Add all unvisited neighbors to the stack
                for neighbor in adj_list[current]:
                    if neighbor not in visited:
                        stack.append(neighbor)

    # Count connected components
    num_components = 0
    
    # Iterate through each node to ensure all are covered
    for i in range(n):
        if i not in visited:
            # If node i is not visited, it's part of a new component
            dfs(i)
            num_components += 1
    
    return num_components

# Test cases to verify our solution

# Test case 1: A simple graph with two separate components
n1 = 5
edges1 = [(0, 1), (2, 3)]
print(funcImp(n1, edges1))  # Expected output: 3

# Test case 2: A fully connected graph (one component)
n2 = 4
edges2 = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
print(funcImp(n2, edges2))  # Expected output: 1

# Test case 3: No edges at all; every node is its own component
n3 = 4
edges3 = []
print(funcImp(n3, edges3))  # Expected output: 4

# Test case 4: Single node with no connections should be one component by itself.
n4 = 1
edges4 = []
print(funcImp(n4, edges4))   # Expected output: 1

# Test case with more complex structure 
n5 = 6 
edges5 = [(0,1),(0,2),(3,4)]
print(funcImp(n5 ,edges5))   # Expected output :3 
```","n=4, edges=[]",4,4,PASS,TRUE,
38,3,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n, edges):
    """"""
    Count the number of connected components in an undirected graph.
    
    :param n: Number of nodes in the graph
    :param edges: List of edges where each edge is represented by a tuple (u, v)
    :return: Number of connected components
    """"""
    
    # Create an adjacency list for the graph
    adj_list = {i: [] for i in range(n)}
    
    # Populate the adjacency list with edges
    for u, v in edges:
        adj_list[u].append(v)
        adj_list[v].append(u)
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Perform DFS starting from node.""""""
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                # Add all unvisited neighbors to the stack
                for neighbor in adj_list[current]:
                    if neighbor not in visited:
                        stack.append(neighbor)

    # Count connected components
    num_components = 0
    
    # Iterate through each node to ensure all are covered
    for i in range(n):
        if i not in visited:
            # If node i is not visited, it's part of a new component
            dfs(i)
            num_components += 1
    
    return num_components

# Test cases to verify our solution

# Test case 1: A simple graph with two separate components
n1 = 5
edges1 = [(0, 1), (2, 3)]
print(funcImp(n1, edges1))  # Expected output: 3

# Test case 2: A fully connected graph (one component)
n2 = 4
edges2 = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
print(funcImp(n2, edges2))  # Expected output: 1

# Test case 3: No edges at all; every node is its own component
n3 = 4
edges3 = []
print(funcImp(n3, edges3))  # Expected output: 4

# Test case 4: Single node with no connections should be one component by itself.
n4 = 1
edges4 = []
print(funcImp(n4, edges4))   # Expected output: 1

# Test case with more complex structure 
n5 = 6 
edges5 = [(0,1),(0,2),(3,4)]
print(funcImp(n5 ,edges5))   # Expected output :3 
```","n=1, edges=[]",1,1,PASS,TRUE,
38,4,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n, edges):
    """"""
    Count the number of connected components in an undirected graph.
    
    :param n: Number of nodes in the graph
    :param edges: List of edges where each edge is represented by a tuple (u, v)
    :return: Number of connected components
    """"""
    
    # Create an adjacency list for the graph
    adj_list = {i: [] for i in range(n)}
    
    # Populate the adjacency list with edges
    for u, v in edges:
        adj_list[u].append(v)
        adj_list[v].append(u)
    
    # Set to keep track of visited nodes
    visited = set()
    
    def dfs(node):
        """"""Perform DFS starting from node.""""""
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                # Add all unvisited neighbors to the stack
                for neighbor in adj_list[current]:
                    if neighbor not in visited:
                        stack.append(neighbor)

    # Count connected components
    num_components = 0
    
    # Iterate through each node to ensure all are covered
    for i in range(n):
        if i not in visited:
            # If node i is not visited, it's part of a new component
            dfs(i)
            num_components += 1
    
    return num_components

# Test cases to verify our solution

# Test case 1: A simple graph with two separate components
n1 = 5
edges1 = [(0, 1), (2, 3)]
print(funcImp(n1, edges1))  # Expected output: 3

# Test case 2: A fully connected graph (one component)
n2 = 4
edges2 = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
print(funcImp(n2, edges2))  # Expected output: 1

# Test case 3: No edges at all; every node is its own component
n3 = 4
edges3 = []
print(funcImp(n3, edges3))  # Expected output: 4

# Test case 4: Single node with no connections should be one component by itself.
n4 = 1
edges4 = []
print(funcImp(n4, edges4))   # Expected output: 1

# Test case with more complex structure 
n5 = 6 
edges5 = [(0,1),(0,2),(3,4)]
print(funcImp(n5 ,edges5))   # Expected output :3 
```","n=6, edges=[(0, 1), (0, 2), (3, 4)]",3,3,PASS,TRUE,
39,0,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(sorted_array, target):
    """"""
    Perform binary search on a sorted array to find the index of the target element.
    
    Parameters:
    sorted_array (list): A list of elements that is already sorted.
    target (any): The element to search for in the sorted_array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(sorted_array) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if target is present at mid
        if sorted_array[mid] == target:
            return mid
        
        # If target is greater, ignore left half
        elif sorted_array[mid] < target:
            left = mid + 1
        
        # If target is smaller, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify our solution
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))   # Expected output: 2
    print(funcImp([10, 20, 30, 40], 25)) # Expected output: -1
    print(funcImp([], 5))                # Expected output: -1
    print(funcImp([5], 5))               # Expected output: 0
    print(funcImp([2, 4, 6, 8], 8))      # Expected output: 3

# Run test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 3)",2,2,PASS,TRUE,
39,1,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(sorted_array, target):
    """"""
    Perform binary search on a sorted array to find the index of the target element.
    
    Parameters:
    sorted_array (list): A list of elements that is already sorted.
    target (any): The element to search for in the sorted_array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(sorted_array) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if target is present at mid
        if sorted_array[mid] == target:
            return mid
        
        # If target is greater, ignore left half
        elif sorted_array[mid] < target:
            left = mid + 1
        
        # If target is smaller, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify our solution
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))   # Expected output: 2
    print(funcImp([10, 20, 30, 40], 25)) # Expected output: -1
    print(funcImp([], 5))                # Expected output: -1
    print(funcImp([5], 5))               # Expected output: 0
    print(funcImp([2, 4, 6, 8], 8))      # Expected output: 3

# Run test cases
test_funcImp()
```","([10, 20, 30, 40], 25)",-1,-1,PASS,TRUE,
39,2,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(sorted_array, target):
    """"""
    Perform binary search on a sorted array to find the index of the target element.
    
    Parameters:
    sorted_array (list): A list of elements that is already sorted.
    target (any): The element to search for in the sorted_array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(sorted_array) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if target is present at mid
        if sorted_array[mid] == target:
            return mid
        
        # If target is greater, ignore left half
        elif sorted_array[mid] < target:
            left = mid + 1
        
        # If target is smaller, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify our solution
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))   # Expected output: 2
    print(funcImp([10, 20, 30, 40], 25)) # Expected output: -1
    print(funcImp([], 5))                # Expected output: -1
    print(funcImp([5], 5))               # Expected output: 0
    print(funcImp([2, 4, 6, 8], 8))      # Expected output: 3

# Run test cases
test_funcImp()
```","([], 5)",-1,-1,PASS,TRUE,
39,3,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(sorted_array, target):
    """"""
    Perform binary search on a sorted array to find the index of the target element.
    
    Parameters:
    sorted_array (list): A list of elements that is already sorted.
    target (any): The element to search for in the sorted_array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(sorted_array) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if target is present at mid
        if sorted_array[mid] == target:
            return mid
        
        # If target is greater, ignore left half
        elif sorted_array[mid] < target:
            left = mid + 1
        
        # If target is smaller, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify our solution
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))   # Expected output: 2
    print(funcImp([10, 20, 30, 40], 25)) # Expected output: -1
    print(funcImp([], 5))                # Expected output: -1
    print(funcImp([5], 5))               # Expected output: 0
    print(funcImp([2, 4, 6, 8], 8))      # Expected output: 3

# Run test cases
test_funcImp()
```","([5], 5)",0,0,PASS,TRUE,
39,4,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(sorted_array, target):
    """"""
    Perform binary search on a sorted array to find the index of the target element.
    
    Parameters:
    sorted_array (list): A list of elements that is already sorted.
    target (any): The element to search for in the sorted_array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(sorted_array) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if target is present at mid
        if sorted_array[mid] == target:
            return mid
        
        # If target is greater, ignore left half
        elif sorted_array[mid] < target:
            left = mid + 1
        
        # If target is smaller, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify our solution
def test_funcImp():
    print(funcImp([1, 2, 3, 4, 5], 3))   # Expected output: 2
    print(funcImp([10, 20, 30, 40], 25)) # Expected output: -1
    print(funcImp([], 5))                # Expected output: -1
    print(funcImp([5], 5))               # Expected output: 0
    print(funcImp([2, 4, 6, 8], 8))      # Expected output: 3

# Run test cases
test_funcImp()
```","([2, 4, 6, 8], 8)",3,3,PASS,TRUE,
40,0,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find
    the first occurrence of a given target element.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose first occurrence needs to be found.
    
    Returns:
    int: The index of the first occurrence of the target element if found,
         otherwise -1.
    """"""
    
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid
            # Move left to find earlier occurrences
            right = mid - 1
        elif arr[mid] < target:
            # Move right as all elements on left are smaller than target
            left = mid + 1
        else:
            # Move left as all elements on right are greater than target
            right = mid - 1
    
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present and has multiple occurrences
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 1

# Test case 2: Target is present and occurs once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present in the array
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array input
arr4 = []
target4 = any_value_here 
print(funcImp(arr4, target4)) # Expected output: -1

# Test case5 : Array with one element which is not equal to the target 
arr5= [9]
target5=8 
print(funcImp(arr5,target5)) #Expected output : -1 

```","([1, 2, 2, 2, 3, 4], 2)",1,1,PASS,TRUE,
40,1,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find
    the first occurrence of a given target element.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose first occurrence needs to be found.
    
    Returns:
    int: The index of the first occurrence of the target element if found,
         otherwise -1.
    """"""
    
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid
            # Move left to find earlier occurrences
            right = mid - 1
        elif arr[mid] < target:
            # Move right as all elements on left are smaller than target
            left = mid + 1
        else:
            # Move left as all elements on right are greater than target
            right = mid - 1
    
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present and has multiple occurrences
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 1

# Test case 2: Target is present and occurs once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present in the array
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array input
arr4 = []
target4 = any_value_here 
print(funcImp(arr4, target4)) # Expected output: -1

# Test case5 : Array with one element which is not equal to the target 
arr5= [9]
target5=8 
print(funcImp(arr5,target5)) #Expected output : -1 

```","([5, 6, 7, 8], 7)",2,2,PASS,TRUE,
40,2,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find
    the first occurrence of a given target element.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose first occurrence needs to be found.
    
    Returns:
    int: The index of the first occurrence of the target element if found,
         otherwise -1.
    """"""
    
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid
            # Move left to find earlier occurrences
            right = mid - 1
        elif arr[mid] < target:
            # Move right as all elements on left are smaller than target
            left = mid + 1
        else:
            # Move left as all elements on right are greater than target
            right = mid - 1
    
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present and has multiple occurrences
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 1

# Test case 2: Target is present and occurs once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present in the array
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array input
arr4 = []
target4 = any_value_here 
print(funcImp(arr4, target4)) # Expected output: -1

# Test case5 : Array with one element which is not equal to the target 
arr5= [9]
target5=8 
print(funcImp(arr5,target5)) #Expected output : -1 

```","([10, 20, 30], 25)",-1,-1,PASS,TRUE,
40,3,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find
    the first occurrence of a given target element.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose first occurrence needs to be found.
    
    Returns:
    int: The index of the first occurrence of the target element if found,
         otherwise -1.
    """"""
    
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid
            # Move left to find earlier occurrences
            right = mid - 1
        elif arr[mid] < target:
            # Move right as all elements on left are smaller than target
            left = mid + 1
        else:
            # Move left as all elements on right are greater than target
            right = mid - 1
    
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present and has multiple occurrences
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 1

# Test case 2: Target is present and occurs once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present in the array
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array input
arr4 = []
target4 = any_value_here 
print(funcImp(arr4, target4)) # Expected output: -1

# Test case5 : Array with one element which is not equal to the target 
arr5= [9]
target5=8 
print(funcImp(arr5,target5)) #Expected output : -1 

```","([], None)",-1,-1,PASS,TRUE,
40,4,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find
    the first occurrence of a given target element.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose first occurrence needs to be found.
    
    Returns:
    int: The index of the first occurrence of the target element if found,
         otherwise -1.
    """"""
    
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid
            # Move left to find earlier occurrences
            right = mid - 1
        elif arr[mid] < target:
            # Move right as all elements on left are smaller than target
            left = mid + 1
        else:
            # Move left as all elements on right are greater than target
            right = mid - 1
    
    return result

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present and has multiple occurrences
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 1

# Test case 2: Target is present and occurs once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present in the array
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array input
arr4 = []
target4 = any_value_here 
print(funcImp(arr4, target4)) # Expected output: -1

# Test case5 : Array with one element which is not equal to the target 
arr5= [9]
target5=8 
print(funcImp(arr5,target5)) #Expected output : -1 

```","([9], 8)",-1,-1,PASS,TRUE,
41,0,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array,
         or -1 if the target is not present in the array.
    """"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid  # Update result and move right to find later occurrences
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Test cases to verify the solution

# Test case 1: Target is present multiple times
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 3

# Test case 2: Target is present once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array
arr4 = []
target4 = any_value_here # Replace with any value since it doesn't matter for an empty list.
print(funcImp(arr4, target4)) # Expected output: -1

# Test case 5: All elements are same as target
arr5 = [9,9,9]
target5 =9 
print(funcImp(arr5,target5)) # Expected output :2 

```","arr=[1, 2, 2, 2, 3, 4], target=2",3,3,PASS,TRUE,
41,1,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array,
         or -1 if the target is not present in the array.
    """"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid  # Update result and move right to find later occurrences
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Test cases to verify the solution

# Test case 1: Target is present multiple times
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 3

# Test case 2: Target is present once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array
arr4 = []
target4 = any_value_here # Replace with any value since it doesn't matter for an empty list.
print(funcImp(arr4, target4)) # Expected output: -1

# Test case 5: All elements are same as target
arr5 = [9,9,9]
target5 =9 
print(funcImp(arr5,target5)) # Expected output :2 

```","arr=[5, 6, 7, 8], target=7",2,2,PASS,TRUE,
41,2,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array,
         or -1 if the target is not present in the array.
    """"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid  # Update result and move right to find later occurrences
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Test cases to verify the solution

# Test case 1: Target is present multiple times
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 3

# Test case 2: Target is present once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array
arr4 = []
target4 = any_value_here # Replace with any value since it doesn't matter for an empty list.
print(funcImp(arr4, target4)) # Expected output: -1

# Test case 5: All elements are same as target
arr5 = [9,9,9]
target5 =9 
print(funcImp(arr5,target5)) # Expected output :2 

```","arr=[10, 20, 30], target=25",-1,-1,PASS,TRUE,
41,3,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array,
         or -1 if the target is not present in the array.
    """"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid  # Update result and move right to find later occurrences
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Test cases to verify the solution

# Test case 1: Target is present multiple times
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 3

# Test case 2: Target is present once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array
arr4 = []
target4 = any_value_here # Replace with any value since it doesn't matter for an empty list.
print(funcImp(arr4, target4)) # Expected output: -1

# Test case 5: All elements are same as target
arr5 = [9,9,9]
target5 =9 
print(funcImp(arr5,target5)) # Expected output :2 

```","arr=[], target=None",-1,-1,PASS,TRUE,
41,4,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A list of elements sorted in non-decreasing order.
    target: The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array,
         or -1 if the target is not present in the array.
    """"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is equal to target
        if arr[mid] == target:
            result = mid  # Update result and move right to find later occurrences
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Test cases to verify the solution

# Test case 1: Target is present multiple times
arr1 = [1, 2, 2, 2, 3, 4]
target1 = 2
print(funcImp(arr1, target1)) # Expected output: 3

# Test case 2: Target is present once
arr2 = [5, 6, 7, 8]
target2 = 7
print(funcImp(arr2, target2)) # Expected output: 2

# Test case 3: Target is not present
arr3 = [10, 20, 30]
target3 = 25
print(funcImp(arr3, target3)) # Expected output: -1

# Test case 4: Empty array
arr4 = []
target4 = any_value_here # Replace with any value since it doesn't matter for an empty list.
print(funcImp(arr4, target4)) # Expected output: -1

# Test case 5: All elements are same as target
arr5 = [9,9,9]
target5 =9 
print(funcImp(arr5,target5)) # Expected output :2 

```","arr=[9, 9, 9], target=9",2,2,PASS,TRUE,
42,0,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of a target element.
    
    Parameters:
    arr (list): A list of elements sorted in ascending order.
    target: The element to search for in the array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if the middle element is equal to the target
        if arr[mid] == target:
            return mid
        # If the target is greater than mid, ignore left half
        elif arr[mid] < target:
            left = mid + 1
        # If the target is smaller than mid, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present in the middle of the array
print(funcImp([1, 2, 3, 4, 5], 3)) # Expected output: 2

# Test case 2: Target is present at the beginning of the array
print(funcImp([10, 20, 30, 40], 10)) # Expected output: 0

# Test case 3: Target is present at the end of the array
print(funcImp([5, 15, 25], 25)) # Expected output: 2

# Test case 4: Target is not present in an odd-length array
print(funcImp([7,8,9],6)) # Expected output: -1

# Test case 5: Empty array should always return -1 regardless of target value
print(funcImp([],10)) # Expected output: -1

# Test case with negative numbers and zeroes included 
print(funcImp([-10,-5,-2,-1,0],-5)) # Expected output :1 

```","arr=[1, 2, 3, 4, 5],target=3",2,2,PASS,TRUE,
42,1,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of a target element.
    
    Parameters:
    arr (list): A list of elements sorted in ascending order.
    target: The element to search for in the array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if the middle element is equal to the target
        if arr[mid] == target:
            return mid
        # If the target is greater than mid, ignore left half
        elif arr[mid] < target:
            left = mid + 1
        # If the target is smaller than mid, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present in the middle of the array
print(funcImp([1, 2, 3, 4, 5], 3)) # Expected output: 2

# Test case 2: Target is present at the beginning of the array
print(funcImp([10, 20, 30, 40], 10)) # Expected output: 0

# Test case 3: Target is present at the end of the array
print(funcImp([5, 15, 25], 25)) # Expected output: 2

# Test case 4: Target is not present in an odd-length array
print(funcImp([7,8,9],6)) # Expected output: -1

# Test case 5: Empty array should always return -1 regardless of target value
print(funcImp([],10)) # Expected output: -1

# Test case with negative numbers and zeroes included 
print(funcImp([-10,-5,-2,-1,0],-5)) # Expected output :1 

```","arr=[10, 20, 30, 40],target=10",0,0,PASS,TRUE,
42,2,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of a target element.
    
    Parameters:
    arr (list): A list of elements sorted in ascending order.
    target: The element to search for in the array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if the middle element is equal to the target
        if arr[mid] == target:
            return mid
        # If the target is greater than mid, ignore left half
        elif arr[mid] < target:
            left = mid + 1
        # If the target is smaller than mid, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present in the middle of the array
print(funcImp([1, 2, 3, 4, 5], 3)) # Expected output: 2

# Test case 2: Target is present at the beginning of the array
print(funcImp([10, 20, 30, 40], 10)) # Expected output: 0

# Test case 3: Target is present at the end of the array
print(funcImp([5, 15, 25], 25)) # Expected output: 2

# Test case 4: Target is not present in an odd-length array
print(funcImp([7,8,9],6)) # Expected output: -1

# Test case 5: Empty array should always return -1 regardless of target value
print(funcImp([],10)) # Expected output: -1

# Test case with negative numbers and zeroes included 
print(funcImp([-10,-5,-2,-1,0],-5)) # Expected output :1 

```","arr=[5, 15, 25],target=25",2,2,PASS,TRUE,
42,3,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of a target element.
    
    Parameters:
    arr (list): A list of elements sorted in ascending order.
    target: The element to search for in the array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if the middle element is equal to the target
        if arr[mid] == target:
            return mid
        # If the target is greater than mid, ignore left half
        elif arr[mid] < target:
            left = mid + 1
        # If the target is smaller than mid, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present in the middle of the array
print(funcImp([1, 2, 3, 4, 5], 3)) # Expected output: 2

# Test case 2: Target is present at the beginning of the array
print(funcImp([10, 20, 30, 40], 10)) # Expected output: 0

# Test case 3: Target is present at the end of the array
print(funcImp([5, 15, 25], 25)) # Expected output: 2

# Test case 4: Target is not present in an odd-length array
print(funcImp([7,8,9],6)) # Expected output: -1

# Test case 5: Empty array should always return -1 regardless of target value
print(funcImp([],10)) # Expected output: -1

# Test case with negative numbers and zeroes included 
print(funcImp([-10,-5,-2,-1,0],-5)) # Expected output :1 

```","arr=[7, 8, 9],target=6",-1,-1,PASS,TRUE,
42,4,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of a target element.
    
    Parameters:
    arr (list): A list of elements sorted in ascending order.
    target: The element to search for in the array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if the middle element is equal to the target
        if arr[mid] == target:
            return mid
        # If the target is greater than mid, ignore left half
        elif arr[mid] < target:
            left = mid + 1
        # If the target is smaller than mid, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present in the middle of the array
print(funcImp([1, 2, 3, 4, 5], 3)) # Expected output: 2

# Test case 2: Target is present at the beginning of the array
print(funcImp([10, 20, 30, 40], 10)) # Expected output: 0

# Test case 3: Target is present at the end of the array
print(funcImp([5, 15, 25], 25)) # Expected output: 2

# Test case 4: Target is not present in an odd-length array
print(funcImp([7,8,9],6)) # Expected output: -1

# Test case 5: Empty array should always return -1 regardless of target value
print(funcImp([],10)) # Expected output: -1

# Test case with negative numbers and zeroes included 
print(funcImp([-10,-5,-2,-1,0],-5)) # Expected output :1 

```","arr=[],target=10",-1,-1,PASS,TRUE,
42,5,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of a target element.
    
    Parameters:
    arr (list): A list of elements sorted in ascending order.
    target: The element to search for in the array.
    
    Returns:
    int: The index of the target element if found; otherwise, -1.
    """"""
    
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if the middle element is equal to the target
        if arr[mid] == target:
            return mid
        # If the target is greater than mid, ignore left half
        elif arr[mid] < target:
            left = mid + 1
        # If the target is smaller than mid, ignore right half
        else:
            right = mid - 1
    
    # Target was not found in the array
    return -1

# Test cases to verify that funcImp works correctly

# Test case 1: Target is present in the middle of the array
print(funcImp([1, 2, 3, 4, 5], 3)) # Expected output: 2

# Test case 2: Target is present at the beginning of the array
print(funcImp([10, 20, 30, 40], 10)) # Expected output: 0

# Test case 3: Target is present at the end of the array
print(funcImp([5, 15, 25], 25)) # Expected output: 2

# Test case 4: Target is not present in an odd-length array
print(funcImp([7,8,9],6)) # Expected output: -1

# Test case 5: Empty array should always return -1 regardless of target value
print(funcImp([],10)) # Expected output: -1

# Test case with negative numbers and zeroes included 
print(funcImp([-10,-5,-2,-1,0],-5)) # Expected output :1 

```","arr=[-10, -5, -2, -1, 0],target=-5",1,1,PASS,TRUE,
43,0,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A list of integers representing a rotated sorted array.
    :return: int - The minimum element in the array.
    """"""
    if not nums:
        raise ValueError(""Input array cannot be empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the list has just one element or is not rotated (first element < last element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # Check if mid+1 is the smallest
        if mid < right and nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        
        # Check if mid itself is the smallest
        if mid > left and nums[mid] < nums[mid - 1]:
            return nums[mid]
        
        # Decide which side to go
        if nums[mid] >= nums[left]:
            # Minimum must be on right side
            left = mid + 1
        else:
            # Minimum must be on left side
            right = mid - 1
    
    return nums[left]

# Test cases to verify our solution

# Test case 1: Rotated at some point
print(funcImp([4,5,6,7,0,1,2]))  # Expected output: 0

# Test case 2: Not rotated (already sorted)
print(funcImp([0,1,2,3,4]))      # Expected output: 0

# Test case 3: Single element
print(funcImp([10]))             # Expected output: 10

# Test case 4: Rotated with duplicates around pivot point
print(funcImp([3,4,5,6,-2,-1,-0.5]))   # Expected output: -2

# Test case 5: Array with two elements where rotation happened between them
print(funcImp([2,-3]))           # Expected output: -3

# Edge Case test case for empty input should raise an error
try:
    print(funcImp([]))           # Should raise ValueError
except ValueError as e:
    print(e)                     # Output error message for empty input test case

```","[4, 5, 6, 7, 0, 1, 2]",0,0,PASS,TRUE,
43,1,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A list of integers representing a rotated sorted array.
    :return: int - The minimum element in the array.
    """"""
    if not nums:
        raise ValueError(""Input array cannot be empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the list has just one element or is not rotated (first element < last element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # Check if mid+1 is the smallest
        if mid < right and nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        
        # Check if mid itself is the smallest
        if mid > left and nums[mid] < nums[mid - 1]:
            return nums[mid]
        
        # Decide which side to go
        if nums[mid] >= nums[left]:
            # Minimum must be on right side
            left = mid + 1
        else:
            # Minimum must be on left side
            right = mid - 1
    
    return nums[left]

# Test cases to verify our solution

# Test case 1: Rotated at some point
print(funcImp([4,5,6,7,0,1,2]))  # Expected output: 0

# Test case 2: Not rotated (already sorted)
print(funcImp([0,1,2,3,4]))      # Expected output: 0

# Test case 3: Single element
print(funcImp([10]))             # Expected output: 10

# Test case 4: Rotated with duplicates around pivot point
print(funcImp([3,4,5,6,-2,-1,-0.5]))   # Expected output: -2

# Test case 5: Array with two elements where rotation happened between them
print(funcImp([2,-3]))           # Expected output: -3

# Edge Case test case for empty input should raise an error
try:
    print(funcImp([]))           # Should raise ValueError
except ValueError as e:
    print(e)                     # Output error message for empty input test case

```","[0, 1, 2, 3, 4]",0,0,PASS,TRUE,
43,2,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A list of integers representing a rotated sorted array.
    :return: int - The minimum element in the array.
    """"""
    if not nums:
        raise ValueError(""Input array cannot be empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the list has just one element or is not rotated (first element < last element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # Check if mid+1 is the smallest
        if mid < right and nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        
        # Check if mid itself is the smallest
        if mid > left and nums[mid] < nums[mid - 1]:
            return nums[mid]
        
        # Decide which side to go
        if nums[mid] >= nums[left]:
            # Minimum must be on right side
            left = mid + 1
        else:
            # Minimum must be on left side
            right = mid - 1
    
    return nums[left]

# Test cases to verify our solution

# Test case 1: Rotated at some point
print(funcImp([4,5,6,7,0,1,2]))  # Expected output: 0

# Test case 2: Not rotated (already sorted)
print(funcImp([0,1,2,3,4]))      # Expected output: 0

# Test case 3: Single element
print(funcImp([10]))             # Expected output: 10

# Test case 4: Rotated with duplicates around pivot point
print(funcImp([3,4,5,6,-2,-1,-0.5]))   # Expected output: -2

# Test case 5: Array with two elements where rotation happened between them
print(funcImp([2,-3]))           # Expected output: -3

# Edge Case test case for empty input should raise an error
try:
    print(funcImp([]))           # Should raise ValueError
except ValueError as e:
    print(e)                     # Output error message for empty input test case

```",[10],10,10,PASS,TRUE,
43,3,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A list of integers representing a rotated sorted array.
    :return: int - The minimum element in the array.
    """"""
    if not nums:
        raise ValueError(""Input array cannot be empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the list has just one element or is not rotated (first element < last element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # Check if mid+1 is the smallest
        if mid < right and nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        
        # Check if mid itself is the smallest
        if mid > left and nums[mid] < nums[mid - 1]:
            return nums[mid]
        
        # Decide which side to go
        if nums[mid] >= nums[left]:
            # Minimum must be on right side
            left = mid + 1
        else:
            # Minimum must be on left side
            right = mid - 1
    
    return nums[left]

# Test cases to verify our solution

# Test case 1: Rotated at some point
print(funcImp([4,5,6,7,0,1,2]))  # Expected output: 0

# Test case 2: Not rotated (already sorted)
print(funcImp([0,1,2,3,4]))      # Expected output: 0

# Test case 3: Single element
print(funcImp([10]))             # Expected output: 10

# Test case 4: Rotated with duplicates around pivot point
print(funcImp([3,4,5,6,-2,-1,-0.5]))   # Expected output: -2

# Test case 5: Array with two elements where rotation happened between them
print(funcImp([2,-3]))           # Expected output: -3

# Edge Case test case for empty input should raise an error
try:
    print(funcImp([]))           # Should raise ValueError
except ValueError as e:
    print(e)                     # Output error message for empty input test case

```","[3, 4, 5, 6, -2, -1, -0.5]",-2,-2,PASS,TRUE,
43,4,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A list of integers representing a rotated sorted array.
    :return: int - The minimum element in the array.
    """"""
    if not nums:
        raise ValueError(""Input array cannot be empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the list has just one element or is not rotated (first element < last element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # Check if mid+1 is the smallest
        if mid < right and nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        
        # Check if mid itself is the smallest
        if mid > left and nums[mid] < nums[mid - 1]:
            return nums[mid]
        
        # Decide which side to go
        if nums[mid] >= nums[left]:
            # Minimum must be on right side
            left = mid + 1
        else:
            # Minimum must be on left side
            right = mid - 1
    
    return nums[left]

# Test cases to verify our solution

# Test case 1: Rotated at some point
print(funcImp([4,5,6,7,0,1,2]))  # Expected output: 0

# Test case 2: Not rotated (already sorted)
print(funcImp([0,1,2,3,4]))      # Expected output: 0

# Test case 3: Single element
print(funcImp([10]))             # Expected output: 10

# Test case 4: Rotated with duplicates around pivot point
print(funcImp([3,4,5,6,-2,-1,-0.5]))   # Expected output: -2

# Test case 5: Array with two elements where rotation happened between them
print(funcImp([2,-3]))           # Expected output: -3

# Edge Case test case for empty input should raise an error
try:
    print(funcImp([]))           # Should raise ValueError
except ValueError as e:
    print(e)                     # Output error message for empty input test case

```","[2, -3]",-3,-3,PASS,TRUE,
44,0,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if a target element exists.
    
    :param matrix: List[List[int]] - A list of lists where each sublist represents a row in the matrix.
    :param target: int - The target integer to find in the matrix.
    :return: bool - True if target exists in the matrix, False otherwise.
    """"""
    
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Number of rows and columns
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Binary search initialization
    left = 0
    right = rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Calculate row and column from mid index
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify our solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [
   [1, 3, 5],
   [7, 9, 11],
   [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix
matrix2 = [
   [10, 20],
   [30, 40]
]
target2 = 25
print(funcImp(matrix2, target2)) # Expected output: False

# Test case 3: Empty Matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3)) # Expected output: False

# Test case 4: Single Element Matrix with matching target
matrix4 = [[42]]
target4 = 42
print(funcImp(matrix4, target4)) # Expected output: True

# Test case 5: Single Element Matrix without matching target
matrix5 = [[42]]
target5 = -42
print(funcImp(matrix5, target5)) # Expected output: False

```","Matrix: [[1, 3, 5], [7, 9, 11], [13, 15, 17]], Target: 9",TRUE,TRUE,PASS,TRUE,
44,1,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if a target element exists.
    
    :param matrix: List[List[int]] - A list of lists where each sublist represents a row in the matrix.
    :param target: int - The target integer to find in the matrix.
    :return: bool - True if target exists in the matrix, False otherwise.
    """"""
    
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Number of rows and columns
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Binary search initialization
    left = 0
    right = rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Calculate row and column from mid index
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify our solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [
   [1, 3, 5],
   [7, 9, 11],
   [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix
matrix2 = [
   [10, 20],
   [30, 40]
]
target2 = 25
print(funcImp(matrix2, target2)) # Expected output: False

# Test case 3: Empty Matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3)) # Expected output: False

# Test case 4: Single Element Matrix with matching target
matrix4 = [[42]]
target4 = 42
print(funcImp(matrix4, target4)) # Expected output: True

# Test case 5: Single Element Matrix without matching target
matrix5 = [[42]]
target5 = -42
print(funcImp(matrix5, target5)) # Expected output: False

```","Matrix: [[10, 20], [30, 40]], Target: 25",FALSE,FALSE,PASS,TRUE,
44,2,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if a target element exists.
    
    :param matrix: List[List[int]] - A list of lists where each sublist represents a row in the matrix.
    :param target: int - The target integer to find in the matrix.
    :return: bool - True if target exists in the matrix, False otherwise.
    """"""
    
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Number of rows and columns
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Binary search initialization
    left = 0
    right = rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Calculate row and column from mid index
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify our solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [
   [1, 3, 5],
   [7, 9, 11],
   [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix
matrix2 = [
   [10, 20],
   [30, 40]
]
target2 = 25
print(funcImp(matrix2, target2)) # Expected output: False

# Test case 3: Empty Matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3)) # Expected output: False

# Test case 4: Single Element Matrix with matching target
matrix4 = [[42]]
target4 = 42
print(funcImp(matrix4, target4)) # Expected output: True

# Test case 5: Single Element Matrix without matching target
matrix5 = [[42]]
target5 = -42
print(funcImp(matrix5, target5)) # Expected output: False

```","Matrix: [], Target: 5",FALSE,FALSE,PASS,TRUE,
44,3,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if a target element exists.
    
    :param matrix: List[List[int]] - A list of lists where each sublist represents a row in the matrix.
    :param target: int - The target integer to find in the matrix.
    :return: bool - True if target exists in the matrix, False otherwise.
    """"""
    
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Number of rows and columns
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Binary search initialization
    left = 0
    right = rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Calculate row and column from mid index
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify our solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [
   [1, 3, 5],
   [7, 9, 11],
   [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix
matrix2 = [
   [10, 20],
   [30, 40]
]
target2 = 25
print(funcImp(matrix2, target2)) # Expected output: False

# Test case 3: Empty Matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3)) # Expected output: False

# Test case 4: Single Element Matrix with matching target
matrix4 = [[42]]
target4 = 42
print(funcImp(matrix4, target4)) # Expected output: True

# Test case 5: Single Element Matrix without matching target
matrix5 = [[42]]
target5 = -42
print(funcImp(matrix5, target5)) # Expected output: False

```","Matrix: [[42]], Target: 42",TRUE,TRUE,PASS,TRUE,
44,4,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if a target element exists.
    
    :param matrix: List[List[int]] - A list of lists where each sublist represents a row in the matrix.
    :param target: int - The target integer to find in the matrix.
    :return: bool - True if target exists in the matrix, False otherwise.
    """"""
    
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Number of rows and columns
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Binary search initialization
    left = 0
    right = rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Calculate row and column from mid index
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify our solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [
   [1, 3, 5],
   [7, 9, 11],
   [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix
matrix2 = [
   [10, 20],
   [30, 40]
]
target2 = 25
print(funcImp(matrix2, target2)) # Expected output: False

# Test case 3: Empty Matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3)) # Expected output: False

# Test case 4: Single Element Matrix with matching target
matrix4 = [[42]]
target4 = 42
print(funcImp(matrix4, target4)) # Expected output: True

# Test case 5: Single Element Matrix without matching target
matrix5 = [[42]]
target5 = -42
print(funcImp(matrix5, target5)) # Expected output: False

```","Matrix: [[42]], Target: -42",FALSE,FALSE,PASS,TRUE,
45,0,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is one which is greater than its neighbors.
    
    :param nums: List[int] - The input list of integers where we need to find a peak.
    :return: int - The index of any one of the peak elements.
    """"""
    
    # Edge case: if the list is empty, return None
    if not nums:
        return None
    
    # Initialize left and right pointers for binary search
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        # Compare middle with its next neighbor
        if nums[mid] > nums[mid + 1]:
            # If mid is greater than mid+1, then the peak must be on the left side (including mid)
            right = mid
        else:
            # If mid is less than or equal to mid+1, then the peak must be on the right side (excluding mid)
            left = mid + 1
    
    # When left == right, we have found a peak position
    return left

# Test cases to verify the solution

# Test case 1: Single element array
print(funcImp([1]))  # Output: 0

# Test case 2: Array with multiple peaks
print(funcImp([1, 3, 20, 4, 1]))  # Output could be any index among [2]

# Test case 3: Peak at start
print(funcImp([10, 5, 2]))   # Output: 0

# Test case 4: Peak at end
print(funcImp([2, 5, 10]))   # Output: 2

# Test case 5: No distinct peaks but all elements are same
print(funcImp([7,7,7]))      # Output could be any index among [0-2]

# Test case with empty array should return None as there are no elements to check for peaks.
print(funcImp([]))           # Output: None

```",[1],0,0,PASS,TRUE,
45,1,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is one which is greater than its neighbors.
    
    :param nums: List[int] - The input list of integers where we need to find a peak.
    :return: int - The index of any one of the peak elements.
    """"""
    
    # Edge case: if the list is empty, return None
    if not nums:
        return None
    
    # Initialize left and right pointers for binary search
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        # Compare middle with its next neighbor
        if nums[mid] > nums[mid + 1]:
            # If mid is greater than mid+1, then the peak must be on the left side (including mid)
            right = mid
        else:
            # If mid is less than or equal to mid+1, then the peak must be on the right side (excluding mid)
            left = mid + 1
    
    # When left == right, we have found a peak position
    return left

# Test cases to verify the solution

# Test case 1: Single element array
print(funcImp([1]))  # Output: 0

# Test case 2: Array with multiple peaks
print(funcImp([1, 3, 20, 4, 1]))  # Output could be any index among [2]

# Test case 3: Peak at start
print(funcImp([10, 5, 2]))   # Output: 0

# Test case 4: Peak at end
print(funcImp([2, 5, 10]))   # Output: 2

# Test case 5: No distinct peaks but all elements are same
print(funcImp([7,7,7]))      # Output could be any index among [0-2]

# Test case with empty array should return None as there are no elements to check for peaks.
print(funcImp([]))           # Output: None

```","[1, 3, 20, 4, 1]",[2],2,PASS,TRUE,
45,2,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is one which is greater than its neighbors.
    
    :param nums: List[int] - The input list of integers where we need to find a peak.
    :return: int - The index of any one of the peak elements.
    """"""
    
    # Edge case: if the list is empty, return None
    if not nums:
        return None
    
    # Initialize left and right pointers for binary search
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        # Compare middle with its next neighbor
        if nums[mid] > nums[mid + 1]:
            # If mid is greater than mid+1, then the peak must be on the left side (including mid)
            right = mid
        else:
            # If mid is less than or equal to mid+1, then the peak must be on the right side (excluding mid)
            left = mid + 1
    
    # When left == right, we have found a peak position
    return left

# Test cases to verify the solution

# Test case 1: Single element array
print(funcImp([1]))  # Output: 0

# Test case 2: Array with multiple peaks
print(funcImp([1, 3, 20, 4, 1]))  # Output could be any index among [2]

# Test case 3: Peak at start
print(funcImp([10, 5, 2]))   # Output: 0

# Test case 4: Peak at end
print(funcImp([2, 5, 10]))   # Output: 2

# Test case 5: No distinct peaks but all elements are same
print(funcImp([7,7,7]))      # Output could be any index among [0-2]

# Test case with empty array should return None as there are no elements to check for peaks.
print(funcImp([]))           # Output: None

```","[10, 5, 2]",0,0,PASS,TRUE,
45,3,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is one which is greater than its neighbors.
    
    :param nums: List[int] - The input list of integers where we need to find a peak.
    :return: int - The index of any one of the peak elements.
    """"""
    
    # Edge case: if the list is empty, return None
    if not nums:
        return None
    
    # Initialize left and right pointers for binary search
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        # Compare middle with its next neighbor
        if nums[mid] > nums[mid + 1]:
            # If mid is greater than mid+1, then the peak must be on the left side (including mid)
            right = mid
        else:
            # If mid is less than or equal to mid+1, then the peak must be on the right side (excluding mid)
            left = mid + 1
    
    # When left == right, we have found a peak position
    return left

# Test cases to verify the solution

# Test case 1: Single element array
print(funcImp([1]))  # Output: 0

# Test case 2: Array with multiple peaks
print(funcImp([1, 3, 20, 4, 1]))  # Output could be any index among [2]

# Test case 3: Peak at start
print(funcImp([10, 5, 2]))   # Output: 0

# Test case 4: Peak at end
print(funcImp([2, 5, 10]))   # Output: 2

# Test case 5: No distinct peaks but all elements are same
print(funcImp([7,7,7]))      # Output could be any index among [0-2]

# Test case with empty array should return None as there are no elements to check for peaks.
print(funcImp([]))           # Output: None

```","[2, 5, 10]",2,2,PASS,TRUE,
45,4,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is one which is greater than its neighbors.
    
    :param nums: List[int] - The input list of integers where we need to find a peak.
    :return: int - The index of any one of the peak elements.
    """"""
    
    # Edge case: if the list is empty, return None
    if not nums:
        return None
    
    # Initialize left and right pointers for binary search
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        # Compare middle with its next neighbor
        if nums[mid] > nums[mid + 1]:
            # If mid is greater than mid+1, then the peak must be on the left side (including mid)
            right = mid
        else:
            # If mid is less than or equal to mid+1, then the peak must be on the right side (excluding mid)
            left = mid + 1
    
    # When left == right, we have found a peak position
    return left

# Test cases to verify the solution

# Test case 1: Single element array
print(funcImp([1]))  # Output: 0

# Test case 2: Array with multiple peaks
print(funcImp([1, 3, 20, 4, 1]))  # Output could be any index among [2]

# Test case 3: Peak at start
print(funcImp([10, 5, 2]))   # Output: 0

# Test case 4: Peak at end
print(funcImp([2, 5, 10]))   # Output: 2

# Test case 5: No distinct peaks but all elements are same
print(funcImp([7,7,7]))      # Output could be any index among [0-2]

# Test case with empty array should return None as there are no elements to check for peaks.
print(funcImp([]))           # Output: None

```","[7, 7, 7]","[0, 1, 2]",2,PASS,TRUE,
45,5,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is one which is greater than its neighbors.
    
    :param nums: List[int] - The input list of integers where we need to find a peak.
    :return: int - The index of any one of the peak elements.
    """"""
    
    # Edge case: if the list is empty, return None
    if not nums:
        return None
    
    # Initialize left and right pointers for binary search
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        # Compare middle with its next neighbor
        if nums[mid] > nums[mid + 1]:
            # If mid is greater than mid+1, then the peak must be on the left side (including mid)
            right = mid
        else:
            # If mid is less than or equal to mid+1, then the peak must be on the right side (excluding mid)
            left = mid + 1
    
    # When left == right, we have found a peak position
    return left

# Test cases to verify the solution

# Test case 1: Single element array
print(funcImp([1]))  # Output: 0

# Test case 2: Array with multiple peaks
print(funcImp([1, 3, 20, 4, 1]))  # Output could be any index among [2]

# Test case 3: Peak at start
print(funcImp([10, 5, 2]))   # Output: 0

# Test case 4: Peak at end
print(funcImp([2, 5, 10]))   # Output: 2

# Test case 5: No distinct peaks but all elements are same
print(funcImp([7,7,7]))      # Output could be any index among [0-2]

# Test case with empty array should return None as there are no elements to check for peaks.
print(funcImp([]))           # Output: None

```",[],None,None,PASS,TRUE,
46,0,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic using binary search.
    
    A bitonic array is one that first increases and then decreases.
    
    Parameters:
    arr (list): The input list of numbers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    
    n = len(arr)
    
    # An empty or single-element array cannot be bitonic
    if n < 3:
        return False
    
    # Binary search for the peak element
    left, right = 0, n - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is a peak
        if (mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1]):
            break
        elif mid > 0 and arr[mid] < arr[mid - 1]:
            right = mid - 1
        else:
            left = mid + 1
    
    # If no peak was found, it's not bitonic
    if not ((mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1])):
        return False

    # Verify increasing part before the peak
    for i in range(1, mid):
        if arr[i] <= arr[i - 1]:
            return False

    # Verify decreasing part after the peak
    for i in range(mid + 1, n):
        if arr[i] >= arr[i - 1]:
            return False

    return True

# Test cases to verify the solution
test_cases = [
    ([3, 5, 8, 12, 9, 4], True),   # Bitonic: Increasing [3,5,8,12], Decreasing [12,9,4]
    ([10], False),                 # Not enough elements to be bitonic
    ([5,7], False),                # Only two elements can't form a bitonic sequence
    ([2,4,6], False),              # Only increasing part but no decreasing part
    ([6,4], False),                # Only decreasing part but no increasing part
]

# Execute test cases
for i, (arr_input, expected) in enumerate(test_cases):
     result = funcImp(arr_input)
     print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[3, 5, 8, 12, 9, 4]",TRUE,TRUE,PASS,TRUE,
46,1,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic using binary search.
    
    A bitonic array is one that first increases and then decreases.
    
    Parameters:
    arr (list): The input list of numbers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    
    n = len(arr)
    
    # An empty or single-element array cannot be bitonic
    if n < 3:
        return False
    
    # Binary search for the peak element
    left, right = 0, n - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is a peak
        if (mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1]):
            break
        elif mid > 0 and arr[mid] < arr[mid - 1]:
            right = mid - 1
        else:
            left = mid + 1
    
    # If no peak was found, it's not bitonic
    if not ((mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1])):
        return False

    # Verify increasing part before the peak
    for i in range(1, mid):
        if arr[i] <= arr[i - 1]:
            return False

    # Verify decreasing part after the peak
    for i in range(mid + 1, n):
        if arr[i] >= arr[i - 1]:
            return False

    return True

# Test cases to verify the solution
test_cases = [
    ([3, 5, 8, 12, 9, 4], True),   # Bitonic: Increasing [3,5,8,12], Decreasing [12,9,4]
    ([10], False),                 # Not enough elements to be bitonic
    ([5,7], False),                # Only two elements can't form a bitonic sequence
    ([2,4,6], False),              # Only increasing part but no decreasing part
    ([6,4], False),                # Only decreasing part but no increasing part
]

# Execute test cases
for i, (arr_input, expected) in enumerate(test_cases):
     result = funcImp(arr_input)
     print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```",[10],FALSE,FALSE,PASS,TRUE,
46,2,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic using binary search.
    
    A bitonic array is one that first increases and then decreases.
    
    Parameters:
    arr (list): The input list of numbers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    
    n = len(arr)
    
    # An empty or single-element array cannot be bitonic
    if n < 3:
        return False
    
    # Binary search for the peak element
    left, right = 0, n - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is a peak
        if (mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1]):
            break
        elif mid > 0 and arr[mid] < arr[mid - 1]:
            right = mid - 1
        else:
            left = mid + 1
    
    # If no peak was found, it's not bitonic
    if not ((mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1])):
        return False

    # Verify increasing part before the peak
    for i in range(1, mid):
        if arr[i] <= arr[i - 1]:
            return False

    # Verify decreasing part after the peak
    for i in range(mid + 1, n):
        if arr[i] >= arr[i - 1]:
            return False

    return True

# Test cases to verify the solution
test_cases = [
    ([3, 5, 8, 12, 9, 4], True),   # Bitonic: Increasing [3,5,8,12], Decreasing [12,9,4]
    ([10], False),                 # Not enough elements to be bitonic
    ([5,7], False),                # Only two elements can't form a bitonic sequence
    ([2,4,6], False),              # Only increasing part but no decreasing part
    ([6,4], False),                # Only decreasing part but no increasing part
]

# Execute test cases
for i, (arr_input, expected) in enumerate(test_cases):
     result = funcImp(arr_input)
     print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[5, 7]",FALSE,FALSE,PASS,TRUE,
46,3,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic using binary search.
    
    A bitonic array is one that first increases and then decreases.
    
    Parameters:
    arr (list): The input list of numbers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    
    n = len(arr)
    
    # An empty or single-element array cannot be bitonic
    if n < 3:
        return False
    
    # Binary search for the peak element
    left, right = 0, n - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is a peak
        if (mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1]):
            break
        elif mid > 0 and arr[mid] < arr[mid - 1]:
            right = mid - 1
        else:
            left = mid + 1
    
    # If no peak was found, it's not bitonic
    if not ((mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1])):
        return False

    # Verify increasing part before the peak
    for i in range(1, mid):
        if arr[i] <= arr[i - 1]:
            return False

    # Verify decreasing part after the peak
    for i in range(mid + 1, n):
        if arr[i] >= arr[i - 1]:
            return False

    return True

# Test cases to verify the solution
test_cases = [
    ([3, 5, 8, 12, 9, 4], True),   # Bitonic: Increasing [3,5,8,12], Decreasing [12,9,4]
    ([10], False),                 # Not enough elements to be bitonic
    ([5,7], False),                # Only two elements can't form a bitonic sequence
    ([2,4,6], False),              # Only increasing part but no decreasing part
    ([6,4], False),                # Only decreasing part but no increasing part
]

# Execute test cases
for i, (arr_input, expected) in enumerate(test_cases):
     result = funcImp(arr_input)
     print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[2, 4, 6]",FALSE,TRUE,FAIL,FALSE,
46,4,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic using binary search.
    
    A bitonic array is one that first increases and then decreases.
    
    Parameters:
    arr (list): The input list of numbers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    
    n = len(arr)
    
    # An empty or single-element array cannot be bitonic
    if n < 3:
        return False
    
    # Binary search for the peak element
    left, right = 0, n - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Check if mid is a peak
        if (mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1]):
            break
        elif mid > 0 and arr[mid] < arr[mid - 1]:
            right = mid - 1
        else:
            left = mid + 1
    
    # If no peak was found, it's not bitonic
    if not ((mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1])):
        return False

    # Verify increasing part before the peak
    for i in range(1, mid):
        if arr[i] <= arr[i - 1]:
            return False

    # Verify decreasing part after the peak
    for i in range(mid + 1, n):
        if arr[i] >= arr[i - 1]:
            return False

    return True

# Test cases to verify the solution
test_cases = [
    ([3, 5, 8, 12, 9, 4], True),   # Bitonic: Increasing [3,5,8,12], Decreasing [12,9,4]
    ([10], False),                 # Not enough elements to be bitonic
    ([5,7], False),                # Only two elements can't form a bitonic sequence
    ([2,4,6], False),              # Only increasing part but no decreasing part
    ([6,4], False),                # Only decreasing part but no increasing part
]

# Execute test cases
for i, (arr_input, expected) in enumerate(test_cases):
     result = funcImp(arr_input)
     print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[6, 4]",FALSE,FALSE,PASS,TRUE,
47,0,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x):
    """"""
    Find the square root of a given non-negative number x using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    
    Returns:
    float: The approximate square root of x.
    """"""
    
    # Handle edge cases
    if x < 0:
        raise ValueError(""Cannot compute square root of negative numbers."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1
    
    # Define precision for floating point result
    precision = 1e-7
    
    while high - low > precision:
        mid = (low + high) / 2
        mid_squared = mid * mid
        
        if abs(mid_squared - x) <= precision:
            return mid
        elif mid_squared < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of funcImp

# Test case 1: Perfect square
print(funcImp(4))   # Expected output: approximately 2.0

# Test case 2: Non-perfect square
print(funcImp(10))  # Expected output: approximately 3.1622776601683795

# Test case 3: Small number less than one
print(funcImp(0.25)) # Expected output: approximately 0.5

# Test case 4: Large number
print(funcImp(1000000)) # Expected output: approximately 1000.0

# Test case 5: Edge case zero and one
print(funcImp(0))   # Expected output: exactly 0.0
print(funcImp(1))   # Expected output: exactly 1.0

# Edge case with very small positive number close to zero but not zero itself.
print(funcImp(1e-10))   # Expected output should be very small, close to sqrt(1e-10)
```",4,2,2,PASS,TRUE,
47,1,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x):
    """"""
    Find the square root of a given non-negative number x using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    
    Returns:
    float: The approximate square root of x.
    """"""
    
    # Handle edge cases
    if x < 0:
        raise ValueError(""Cannot compute square root of negative numbers."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1
    
    # Define precision for floating point result
    precision = 1e-7
    
    while high - low > precision:
        mid = (low + high) / 2
        mid_squared = mid * mid
        
        if abs(mid_squared - x) <= precision:
            return mid
        elif mid_squared < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of funcImp

# Test case 1: Perfect square
print(funcImp(4))   # Expected output: approximately 2.0

# Test case 2: Non-perfect square
print(funcImp(10))  # Expected output: approximately 3.1622776601683795

# Test case 3: Small number less than one
print(funcImp(0.25)) # Expected output: approximately 0.5

# Test case 4: Large number
print(funcImp(1000000)) # Expected output: approximately 1000.0

# Test case 5: Edge case zero and one
print(funcImp(0))   # Expected output: exactly 0.0
print(funcImp(1))   # Expected output: exactly 1.0

# Edge case with very small positive number close to zero but not zero itself.
print(funcImp(1e-10))   # Expected output should be very small, close to sqrt(1e-10)
```",10,3.16227766,3.162277676,PASS,TRUE,
47,2,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x):
    """"""
    Find the square root of a given non-negative number x using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    
    Returns:
    float: The approximate square root of x.
    """"""
    
    # Handle edge cases
    if x < 0:
        raise ValueError(""Cannot compute square root of negative numbers."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1
    
    # Define precision for floating point result
    precision = 1e-7
    
    while high - low > precision:
        mid = (low + high) / 2
        mid_squared = mid * mid
        
        if abs(mid_squared - x) <= precision:
            return mid
        elif mid_squared < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of funcImp

# Test case 1: Perfect square
print(funcImp(4))   # Expected output: approximately 2.0

# Test case 2: Non-perfect square
print(funcImp(10))  # Expected output: approximately 3.1622776601683795

# Test case 3: Small number less than one
print(funcImp(0.25)) # Expected output: approximately 0.5

# Test case 4: Large number
print(funcImp(1000000)) # Expected output: approximately 1000.0

# Test case 5: Edge case zero and one
print(funcImp(0))   # Expected output: exactly 0.0
print(funcImp(1))   # Expected output: exactly 1.0

# Edge case with very small positive number close to zero but not zero itself.
print(funcImp(1e-10))   # Expected output should be very small, close to sqrt(1e-10)
```",0.25,0.5,0.5,PASS,TRUE,
47,3,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x):
    """"""
    Find the square root of a given non-negative number x using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    
    Returns:
    float: The approximate square root of x.
    """"""
    
    # Handle edge cases
    if x < 0:
        raise ValueError(""Cannot compute square root of negative numbers."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1
    
    # Define precision for floating point result
    precision = 1e-7
    
    while high - low > precision:
        mid = (low + high) / 2
        mid_squared = mid * mid
        
        if abs(mid_squared - x) <= precision:
            return mid
        elif mid_squared < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of funcImp

# Test case 1: Perfect square
print(funcImp(4))   # Expected output: approximately 2.0

# Test case 2: Non-perfect square
print(funcImp(10))  # Expected output: approximately 3.1622776601683795

# Test case 3: Small number less than one
print(funcImp(0.25)) # Expected output: approximately 0.5

# Test case 4: Large number
print(funcImp(1000000)) # Expected output: approximately 1000.0

# Test case 5: Edge case zero and one
print(funcImp(0))   # Expected output: exactly 0.0
print(funcImp(1))   # Expected output: exactly 1.0

# Edge case with very small positive number close to zero but not zero itself.
print(funcImp(1e-10))   # Expected output should be very small, close to sqrt(1e-10)
```",1000000,1000,1000,PASS,TRUE,
47,4,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x):
    """"""
    Find the square root of a given non-negative number x using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    
    Returns:
    float: The approximate square root of x.
    """"""
    
    # Handle edge cases
    if x < 0:
        raise ValueError(""Cannot compute square root of negative numbers."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1
    
    # Define precision for floating point result
    precision = 1e-7
    
    while high - low > precision:
        mid = (low + high) / 2
        mid_squared = mid * mid
        
        if abs(mid_squared - x) <= precision:
            return mid
        elif mid_squared < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of funcImp

# Test case 1: Perfect square
print(funcImp(4))   # Expected output: approximately 2.0

# Test case 2: Non-perfect square
print(funcImp(10))  # Expected output: approximately 3.1622776601683795

# Test case 3: Small number less than one
print(funcImp(0.25)) # Expected output: approximately 0.5

# Test case 4: Large number
print(funcImp(1000000)) # Expected output: approximately 1000.0

# Test case 5: Edge case zero and one
print(funcImp(0))   # Expected output: exactly 0.0
print(funcImp(1))   # Expected output: exactly 1.0

# Edge case with very small positive number close to zero but not zero itself.
print(funcImp(1e-10))   # Expected output should be very small, close to sqrt(1e-10)
```",0,0,0,PASS,TRUE,
47,5,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x):
    """"""
    Find the square root of a given non-negative number x using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    
    Returns:
    float: The approximate square root of x.
    """"""
    
    # Handle edge cases
    if x < 0:
        raise ValueError(""Cannot compute square root of negative numbers."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1
    
    # Define precision for floating point result
    precision = 1e-7
    
    while high - low > precision:
        mid = (low + high) / 2
        mid_squared = mid * mid
        
        if abs(mid_squared - x) <= precision:
            return mid
        elif mid_squared < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of funcImp

# Test case 1: Perfect square
print(funcImp(4))   # Expected output: approximately 2.0

# Test case 2: Non-perfect square
print(funcImp(10))  # Expected output: approximately 3.1622776601683795

# Test case 3: Small number less than one
print(funcImp(0.25)) # Expected output: approximately 0.5

# Test case 4: Large number
print(funcImp(1000000)) # Expected output: approximately 1000.0

# Test case 5: Edge case zero and one
print(funcImp(0))   # Expected output: exactly 0.0
print(funcImp(1))   # Expected output: exactly 1.0

# Edge case with very small positive number close to zero but not zero itself.
print(funcImp(1e-10))   # Expected output should be very small, close to sqrt(1e-10)
```",1,1,1,PASS,TRUE,
47,6,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x):
    """"""
    Find the square root of a given non-negative number x using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    
    Returns:
    float: The approximate square root of x.
    """"""
    
    # Handle edge cases
    if x < 0:
        raise ValueError(""Cannot compute square root of negative numbers."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1
    
    # Define precision for floating point result
    precision = 1e-7
    
    while high - low > precision:
        mid = (low + high) / 2
        mid_squared = mid * mid
        
        if abs(mid_squared - x) <= precision:
            return mid
        elif mid_squared < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of funcImp

# Test case 1: Perfect square
print(funcImp(4))   # Expected output: approximately 2.0

# Test case 2: Non-perfect square
print(funcImp(10))  # Expected output: approximately 3.1622776601683795

# Test case 3: Small number less than one
print(funcImp(0.25)) # Expected output: approximately 0.5

# Test case 4: Large number
print(funcImp(1000000)) # Expected output: approximately 1000.0

# Test case 5: Edge case zero and one
print(funcImp(0))   # Expected output: exactly 0.0
print(funcImp(1))   # Expected output: exactly 1.0

# Edge case with very small positive number close to zero but not zero itself.
print(funcImp(1e-10))   # Expected output should be very small, close to sqrt(1e-10)
```",1.00E-10,1.00E-05,0.000244141,FAIL,FALSE,
48,0,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Finds all connected components in an undirected graph using DFS.
    
    Parameters:
    - graph: A dictionary where keys are node identifiers and values are lists of adjacent nodes.
    
    Returns:
    - A list of sets, each set contains the nodes that form a connected component.
    """"""
    
    def dfs(node, visited, component):
        """"""Helper function to perform DFS and find all nodes in the current component.""""""
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                component.add(current)
                # Add all unvisited neighbors to the stack
                for neighbor in graph.get(current, []):
                    if neighbor not in visited:
                        stack.append(neighbor)

    visited = set()  # To keep track of all visited nodes
    components = []  # To store all connected components

    for node in graph.keys():
        if node not in visited:
            # Start a new component
            component = set()
            dfs(node, visited, component)
            components.append(component)

    return components

# Test cases to verify the solution
if __name__ == ""__main__"":
    # Example test case 1: Simple graph with two separate components
    graph1 = {
        0: [1],
        1: [0],
        2: [3],
        3: [2]
    }
    
    print(funcImp(graph1))  # Expected output: [{0, 1}, {2, 3}]

    # Example test case 2: Graph with one large component
    graph2 = {
        0: [1, 2],
        1: [0, 3],
        2: [0],
        3: [1]
    }
    
    print(funcImp(graph2))  # Expected output: [{0, 1, 2, 3}]

    # Example test case 3: Disconnected single nodes
    graph3 = {
        'a': [],
        'b': [],
        'c': []
    }
    
    print(funcImp(graph3))   # Expected output: [{'a'}, {'b'}, {'c'}]

```","{0: [1], 1: [0], 2: [3], 3: [2]}","[{0, 1}, {2, 3}]","[{0, 1}, {2, 3}]",PASS,TRUE,
48,1,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Finds all connected components in an undirected graph using DFS.
    
    Parameters:
    - graph: A dictionary where keys are node identifiers and values are lists of adjacent nodes.
    
    Returns:
    - A list of sets, each set contains the nodes that form a connected component.
    """"""
    
    def dfs(node, visited, component):
        """"""Helper function to perform DFS and find all nodes in the current component.""""""
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                component.add(current)
                # Add all unvisited neighbors to the stack
                for neighbor in graph.get(current, []):
                    if neighbor not in visited:
                        stack.append(neighbor)

    visited = set()  # To keep track of all visited nodes
    components = []  # To store all connected components

    for node in graph.keys():
        if node not in visited:
            # Start a new component
            component = set()
            dfs(node, visited, component)
            components.append(component)

    return components

# Test cases to verify the solution
if __name__ == ""__main__"":
    # Example test case 1: Simple graph with two separate components
    graph1 = {
        0: [1],
        1: [0],
        2: [3],
        3: [2]
    }
    
    print(funcImp(graph1))  # Expected output: [{0, 1}, {2, 3}]

    # Example test case 2: Graph with one large component
    graph2 = {
        0: [1, 2],
        1: [0, 3],
        2: [0],
        3: [1]
    }
    
    print(funcImp(graph2))  # Expected output: [{0, 1, 2, 3}]

    # Example test case 3: Disconnected single nodes
    graph3 = {
        'a': [],
        'b': [],
        'c': []
    }
    
    print(funcImp(graph3))   # Expected output: [{'a'}, {'b'}, {'c'}]

```","{0: [1, 2], 1: [0, 3], 2: [0], 3: [1]}","[{0, 1, 2, 3}]","[{0, 1, 2, 3}]",PASS,TRUE,
48,2,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Finds all connected components in an undirected graph using DFS.
    
    Parameters:
    - graph: A dictionary where keys are node identifiers and values are lists of adjacent nodes.
    
    Returns:
    - A list of sets, each set contains the nodes that form a connected component.
    """"""
    
    def dfs(node, visited, component):
        """"""Helper function to perform DFS and find all nodes in the current component.""""""
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                component.add(current)
                # Add all unvisited neighbors to the stack
                for neighbor in graph.get(current, []):
                    if neighbor not in visited:
                        stack.append(neighbor)

    visited = set()  # To keep track of all visited nodes
    components = []  # To store all connected components

    for node in graph.keys():
        if node not in visited:
            # Start a new component
            component = set()
            dfs(node, visited, component)
            components.append(component)

    return components

# Test cases to verify the solution
if __name__ == ""__main__"":
    # Example test case 1: Simple graph with two separate components
    graph1 = {
        0: [1],
        1: [0],
        2: [3],
        3: [2]
    }
    
    print(funcImp(graph1))  # Expected output: [{0, 1}, {2, 3}]

    # Example test case 2: Graph with one large component
    graph2 = {
        0: [1, 2],
        1: [0, 3],
        2: [0],
        3: [1]
    }
    
    print(funcImp(graph2))  # Expected output: [{0, 1, 2, 3}]

    # Example test case 3: Disconnected single nodes
    graph3 = {
        'a': [],
        'b': [],
        'c': []
    }
    
    print(funcImp(graph3))   # Expected output: [{'a'}, {'b'}, {'c'}]

```","{'a': [], 'b': [], 'c': []}","[{'a'}, {'b'}, {'c'}]","[{'a'}, {'b'}, {'c'}]",PASS,TRUE,
49,0,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define a class for the nodes of the binary tree
class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

# Function to perform Preorder Traversal (Root -> Left -> Right)
def preorder_traversal(node):
    if node is None:
        return []
    # Visit root first, then left subtree, then right subtree
    return [node.value] + preorder_traversal(node.left) + preorder_traversal(node.right)

# Function to perform Inorder Traversal (Left -> Root -> Right)
def inorder_traversal(node):
    if node is None:
        return []
    # Visit left subtree first, then root, then right subtree
    return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)

# Function to perform Postorder Traversal (Left -> Right -> Root)
def postorder_traversal(node):
    if node is None:
        return []
    # Visit left subtree first, then right subtree, then root
    return postorder_traversal(node.left) + postorder_traversal(node.right) + [node.value]

# Test cases to verify the correctness of our implementations
if __name__ == ""__main__"":
    # Create a sample binary tree:
    #       1
    #      / \
    #     2   3
    #    / \   \
    #   4   5   6
    
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    
    root.right.right = TreeNode(6)

    print(""Preorder Traversal:"", preorder_traversal(root))  # Output should be [1, 2, 4, 5, 3, 6]
    
    print(""Inorder Traversal:"", inorder_traversal(root))   # Output should be [4, 2, 5, 1, 3, 6]
    
    print(""Postorder Traversal:"", postorder_traversal(root)) # Output should be [4, 5, 2, 6, 3, 1]
```",(root),"Pre:[1, 2, 4, 5, 3, 6], In:[4, 2, 5, 1, 3, 6], Post:[4, 5, 2, 6, 3, 1]","Pre:[], In:[], Post:[]",FAIL,FALSE,name 'status_post_order' is not defined
50,0,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if the given directed graph contains a cycle.
    
    :param graph: A dictionary representing the adjacency list of the graph.
                  The keys are node identifiers and values are lists of adjacent nodes.
    :return: True if there is a cycle in the graph, False otherwise.
    """"""
    
    def dfs(node):
        # If we're visiting an already visited node that's still in the recursion stack, there's a cycle
        if visited[node] == 1:
            return True
        # If it's fully processed, no need to visit again
        if visited[node] == 2:
            return False
        
        # Mark the node as being visited (part of current path)
        visited[node] = 1
        
        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True
        
        # Mark the node as fully processed
        visited[node] = 2
        return False
    
    # Initialize visitation state for each node: 0 = unvisited, 1 = visiting, 2 = fully processed
    visited = {node: 0 for node in graph}
    
    # Check each component of the graph
    for node in graph:
        if visited[node] == 0:  # Unvisited nodes only
            if dfs(node):
                return True
    
    return False

# Test cases to verify our solution

# Test case 1: Graph with no cycles (A -> B -> C)
graph1 = {
    'A': ['B'],
    'B': ['C'],
    'C': []
}

# Test case 2: Graph with a simple cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

# Test case 3: Disconnected components with one having a cycle (D -> E; F -> G -> H -> F)
graph3 = {
    'D': ['E'],
    'E': [],
    'F': ['G'],
    'G': ['H'],
    'H': ['F']
}

# Test case 4: Empty graph
graph4 = {}

# Execute test cases and print results

print(funcImp(graph1))   # Expected output: False (no cycles)
print(funcImp(graph2))   # Expected output: True (contains cycle A->B->C->A)
print(funcImp(graph3))   # Expected output: True (contains cycle F->G->H->F)
print(funcImp(graph4))   # Expected output: False (empty graph has no cycles)

```","{'A': ['B'], 'B': ['C'], 'C': []}",FALSE,FALSE,PASS,TRUE,
50,1,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if the given directed graph contains a cycle.
    
    :param graph: A dictionary representing the adjacency list of the graph.
                  The keys are node identifiers and values are lists of adjacent nodes.
    :return: True if there is a cycle in the graph, False otherwise.
    """"""
    
    def dfs(node):
        # If we're visiting an already visited node that's still in the recursion stack, there's a cycle
        if visited[node] == 1:
            return True
        # If it's fully processed, no need to visit again
        if visited[node] == 2:
            return False
        
        # Mark the node as being visited (part of current path)
        visited[node] = 1
        
        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True
        
        # Mark the node as fully processed
        visited[node] = 2
        return False
    
    # Initialize visitation state for each node: 0 = unvisited, 1 = visiting, 2 = fully processed
    visited = {node: 0 for node in graph}
    
    # Check each component of the graph
    for node in graph:
        if visited[node] == 0:  # Unvisited nodes only
            if dfs(node):
                return True
    
    return False

# Test cases to verify our solution

# Test case 1: Graph with no cycles (A -> B -> C)
graph1 = {
    'A': ['B'],
    'B': ['C'],
    'C': []
}

# Test case 2: Graph with a simple cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

# Test case 3: Disconnected components with one having a cycle (D -> E; F -> G -> H -> F)
graph3 = {
    'D': ['E'],
    'E': [],
    'F': ['G'],
    'G': ['H'],
    'H': ['F']
}

# Test case 4: Empty graph
graph4 = {}

# Execute test cases and print results

print(funcImp(graph1))   # Expected output: False (no cycles)
print(funcImp(graph2))   # Expected output: True (contains cycle A->B->C->A)
print(funcImp(graph3))   # Expected output: True (contains cycle F->G->H->F)
print(funcImp(graph4))   # Expected output: False (empty graph has no cycles)

```","{'A': ['B'], 'B': ['C'], 'C': ['A']}",TRUE,TRUE,PASS,TRUE,
50,2,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if the given directed graph contains a cycle.
    
    :param graph: A dictionary representing the adjacency list of the graph.
                  The keys are node identifiers and values are lists of adjacent nodes.
    :return: True if there is a cycle in the graph, False otherwise.
    """"""
    
    def dfs(node):
        # If we're visiting an already visited node that's still in the recursion stack, there's a cycle
        if visited[node] == 1:
            return True
        # If it's fully processed, no need to visit again
        if visited[node] == 2:
            return False
        
        # Mark the node as being visited (part of current path)
        visited[node] = 1
        
        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True
        
        # Mark the node as fully processed
        visited[node] = 2
        return False
    
    # Initialize visitation state for each node: 0 = unvisited, 1 = visiting, 2 = fully processed
    visited = {node: 0 for node in graph}
    
    # Check each component of the graph
    for node in graph:
        if visited[node] == 0:  # Unvisited nodes only
            if dfs(node):
                return True
    
    return False

# Test cases to verify our solution

# Test case 1: Graph with no cycles (A -> B -> C)
graph1 = {
    'A': ['B'],
    'B': ['C'],
    'C': []
}

# Test case 2: Graph with a simple cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

# Test case 3: Disconnected components with one having a cycle (D -> E; F -> G -> H -> F)
graph3 = {
    'D': ['E'],
    'E': [],
    'F': ['G'],
    'G': ['H'],
    'H': ['F']
}

# Test case 4: Empty graph
graph4 = {}

# Execute test cases and print results

print(funcImp(graph1))   # Expected output: False (no cycles)
print(funcImp(graph2))   # Expected output: True (contains cycle A->B->C->A)
print(funcImp(graph3))   # Expected output: True (contains cycle F->G->H->F)
print(funcImp(graph4))   # Expected output: False (empty graph has no cycles)

```","{'D': ['E'], 'E': [], 'F': ['G'], 'G': ['H'], 'H': ['F']}",TRUE,TRUE,PASS,TRUE,
50,3,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if the given directed graph contains a cycle.
    
    :param graph: A dictionary representing the adjacency list of the graph.
                  The keys are node identifiers and values are lists of adjacent nodes.
    :return: True if there is a cycle in the graph, False otherwise.
    """"""
    
    def dfs(node):
        # If we're visiting an already visited node that's still in the recursion stack, there's a cycle
        if visited[node] == 1:
            return True
        # If it's fully processed, no need to visit again
        if visited[node] == 2:
            return False
        
        # Mark the node as being visited (part of current path)
        visited[node] = 1
        
        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True
        
        # Mark the node as fully processed
        visited[node] = 2
        return False
    
    # Initialize visitation state for each node: 0 = unvisited, 1 = visiting, 2 = fully processed
    visited = {node: 0 for node in graph}
    
    # Check each component of the graph
    for node in graph:
        if visited[node] == 0:  # Unvisited nodes only
            if dfs(node):
                return True
    
    return False

# Test cases to verify our solution

# Test case 1: Graph with no cycles (A -> B -> C)
graph1 = {
    'A': ['B'],
    'B': ['C'],
    'C': []
}

# Test case 2: Graph with a simple cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

# Test case 3: Disconnected components with one having a cycle (D -> E; F -> G -> H -> F)
graph3 = {
    'D': ['E'],
    'E': [],
    'F': ['G'],
    'G': ['H'],
    'H': ['F']
}

# Test case 4: Empty graph
graph4 = {}

# Execute test cases and print results

print(funcImp(graph1))   # Expected output: False (no cycles)
print(funcImp(graph2))   # Expected output: True (contains cycle A->B->C->A)
print(funcImp(graph3))   # Expected output: True (contains cycle F->G->H->F)
print(funcImp(graph4))   # Expected output: False (empty graph has no cycles)

```",{},FALSE,FALSE,PASS,TRUE,
