problem_number,index,category,problem_type,problem,solution_prompt,solution,test_input,expected,actual,status,pass,exception
1,1,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level of the script.
def funcImp(num1, num2):
    """"""
    This function takes two integers as input and returns their sum.

    Parameters:
    num1 (int): The first integer
    num2 (int): The second integer

    Returns:
    int: The sum of the two input integers
    """"""
    
    # Calculate the sum of the two input integers.
    result = num1 + num2
    
    # Return the result.
    return result


# Test the 'funcImp' function with various test cases to ensure it's correctly defined and functioning as expected.

print(funcImp(5, 3))  # Expected output: 8
print(funcImp(-2, 6))  # Expected output: 4
print(funcImp(0, 0))  # Expected output: 0
```","(5, 3)",8,8,PASS,TRUE,N/A
1,2,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level of the script.
def funcImp(num1, num2):
    """"""
    This function takes two integers as input and returns their sum.

    Parameters:
    num1 (int): The first integer
    num2 (int): The second integer

    Returns:
    int: The sum of the two input integers
    """"""
    
    # Calculate the sum of the two input integers.
    result = num1 + num2
    
    # Return the result.
    return result


# Test the 'funcImp' function with various test cases to ensure it's correctly defined and functioning as expected.

print(funcImp(5, 3))  # Expected output: 8
print(funcImp(-2, 6))  # Expected output: 4
print(funcImp(0, 0))  # Expected output: 0
```","(-2, 6)",4,4,PASS,TRUE,N/A
1,3,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level of the script.
def funcImp(num1, num2):
    """"""
    This function takes two integers as input and returns their sum.

    Parameters:
    num1 (int): The first integer
    num2 (int): The second integer

    Returns:
    int: The sum of the two input integers
    """"""
    
    # Calculate the sum of the two input integers.
    result = num1 + num2
    
    # Return the result.
    return result


# Test the 'funcImp' function with various test cases to ensure it's correctly defined and functioning as expected.

print(funcImp(5, 3))  # Expected output: 8
print(funcImp(-2, 6))  # Expected output: 4
print(funcImp(0, 0))  # Expected output: 0
```","(0, 0)",0,0,PASS,TRUE,N/A
2,1,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' that takes two floating-point numbers as arguments and returns their sum.
def funcImp(num1, num2):
    """"""
    This function takes two floating-point numbers as input and returns their sum.

    Parameters:
    num1 (float): The first number.
    num2 (float): The second number.

    Returns:
    float: The sum of num1 and num2.
    """"""
    
    # Check if the inputs are floats. If not, raise an error.
    if not isinstance(num1, float) or not isinstance(num2, float):
        raise ValueError(""Both inputs must be floating point numbers."")
    
    # Calculate the sum of the two numbers.
    result = num1 + num2
    
    # Return the result.
    return result

# Test cases to verify the correctness of 'funcImp' function
print(funcImp(3.5, 4.5))  # Expected output: 8.0
print(funcImp(-3.7, 7.9))  # Expected output: 4.2
print(funcImp(0.0, -5.6))  # Expected output: -5.6
```","3.5, 4.5",8,8,PASS,TRUE,N/A
2,2,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' that takes two floating-point numbers as arguments and returns their sum.
def funcImp(num1, num2):
    """"""
    This function takes two floating-point numbers as input and returns their sum.

    Parameters:
    num1 (float): The first number.
    num2 (float): The second number.

    Returns:
    float: The sum of num1 and num2.
    """"""
    
    # Check if the inputs are floats. If not, raise an error.
    if not isinstance(num1, float) or not isinstance(num2, float):
        raise ValueError(""Both inputs must be floating point numbers."")
    
    # Calculate the sum of the two numbers.
    result = num1 + num2
    
    # Return the result.
    return result

# Test cases to verify the correctness of 'funcImp' function
print(funcImp(3.5, 4.5))  # Expected output: 8.0
print(funcImp(-3.7, 7.9))  # Expected output: 4.2
print(funcImp(0.0, -5.6))  # Expected output: -5.6
```","-3.7, 7.9",4.2,4.2,PASS,TRUE,N/A
2,3,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' that takes two floating-point numbers as arguments and returns their sum.
def funcImp(num1, num2):
    """"""
    This function takes two floating-point numbers as input and returns their sum.

    Parameters:
    num1 (float): The first number.
    num2 (float): The second number.

    Returns:
    float: The sum of num1 and num2.
    """"""
    
    # Check if the inputs are floats. If not, raise an error.
    if not isinstance(num1, float) or not isinstance(num2, float):
        raise ValueError(""Both inputs must be floating point numbers."")
    
    # Calculate the sum of the two numbers.
    result = num1 + num2
    
    # Return the result.
    return result

# Test cases to verify the correctness of 'funcImp' function
print(funcImp(3.5, 4.5))  # Expected output: 8.0
print(funcImp(-3.7, 7.9))  # Expected output: 4.2
print(funcImp(0.0, -5.6))  # Expected output: -5.6
```","0.0, -5.6",-5.6,-5.6,PASS,TRUE,N/A
3,1,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    This function takes two strings as input, converts them to integers and returns their sum.
    If the conversion is not possible (i.e., the string contains non-numeric characters), it raises a ValueError.
    """"""
    try:
        # Convert the strings to integers
        num1 = int(str1)
        num2 = int(str2)

        # Return the sum of the two numbers
        return num1 + num2

    except ValueError:
        # Raise an error if the conversion is not possible
        raise ValueError(""Both inputs must be convertible to an integer"")


# Test cases to verify the functionality of the function
print(funcImp('10', '20'))  # Expected output: 30
print(funcImp('0', '0'))  # Expected output: 0
print(funcImp('-5', '10'))  # Expected output: 5

# Test case with non-numeric string, should raise a ValueError
try:
    print(funcImp('abc', '10'))
except ValueError as e:
    print(e)  # Expected output: Both inputs must be convertible to an integer
```","('10', '20')",30,30,PASS,TRUE,N/A
3,2,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    This function takes two strings as input, converts them to integers and returns their sum.
    If the conversion is not possible (i.e., the string contains non-numeric characters), it raises a ValueError.
    """"""
    try:
        # Convert the strings to integers
        num1 = int(str1)
        num2 = int(str2)

        # Return the sum of the two numbers
        return num1 + num2

    except ValueError:
        # Raise an error if the conversion is not possible
        raise ValueError(""Both inputs must be convertible to an integer"")


# Test cases to verify the functionality of the function
print(funcImp('10', '20'))  # Expected output: 30
print(funcImp('0', '0'))  # Expected output: 0
print(funcImp('-5', '10'))  # Expected output: 5

# Test case with non-numeric string, should raise a ValueError
try:
    print(funcImp('abc', '10'))
except ValueError as e:
    print(e)  # Expected output: Both inputs must be convertible to an integer
```","('0', '0')",0,0,PASS,TRUE,N/A
3,3,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    This function takes two strings as input, converts them to integers and returns their sum.
    If the conversion is not possible (i.e., the string contains non-numeric characters), it raises a ValueError.
    """"""
    try:
        # Convert the strings to integers
        num1 = int(str1)
        num2 = int(str2)

        # Return the sum of the two numbers
        return num1 + num2

    except ValueError:
        # Raise an error if the conversion is not possible
        raise ValueError(""Both inputs must be convertible to an integer"")


# Test cases to verify the functionality of the function
print(funcImp('10', '20'))  # Expected output: 30
print(funcImp('0', '0'))  # Expected output: 0
print(funcImp('-5', '10'))  # Expected output: 5

# Test case with non-numeric string, should raise a ValueError
try:
    print(funcImp('abc', '10'))
except ValueError as e:
    print(e)  # Expected output: Both inputs must be convertible to an integer
```","('-5', '10')",5,5,PASS,TRUE,N/A
3,4,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    This function takes two strings as input, converts them to integers and returns their sum.
    If the conversion is not possible (i.e., the string contains non-numeric characters), it raises a ValueError.
    """"""
    try:
        # Convert the strings to integers
        num1 = int(str1)
        num2 = int(str2)

        # Return the sum of the two numbers
        return num1 + num2

    except ValueError:
        # Raise an error if the conversion is not possible
        raise ValueError(""Both inputs must be convertible to an integer"")


# Test cases to verify the functionality of the function
print(funcImp('10', '20'))  # Expected output: 30
print(funcImp('0', '0'))  # Expected output: 0
print(funcImp('-5', '10'))  # Expected output: 5

# Test case with non-numeric string, should raise a ValueError
try:
    print(funcImp('abc', '10'))
except ValueError as e:
    print(e)  # Expected output: Both inputs must be convertible to an integer
```","('abc', '10')",Both inputs must be convertible to an integer,,FAIL,FALSE,Both inputs must be convertible to an integer
4,1,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum also in binary form.
    The built-in int() function is used to convert the binary strings into integers, then the sum of these integers is calculated.
    Finally, the built-in bin() function is used to convert the sum back into a binary string. The [2:] slice operation is used to remove the '0b' prefix from the result.
    """"""
    
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)

    # Calculate sum
    sum = num1 + num2

    # Convert sum back to binary string and return
    return bin(sum)[2:]

# Test cases
print(funcImp('1010', '1011'))  # Expected output: '10101'
print(funcImp('1111', '1111'))  # Expected output: '11110'
print(funcImp('0000', '0000'))  # Expected output: '0'
print(funcImp('1101', '1001'))  # Expected output: '10110'
```",1010,1011,10101,PASS,TRUE,N/A
4,2,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum also in binary form.
    The built-in int() function is used to convert the binary strings into integers, then the sum of these integers is calculated.
    Finally, the built-in bin() function is used to convert the sum back into a binary string. The [2:] slice operation is used to remove the '0b' prefix from the result.
    """"""
    
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)

    # Calculate sum
    sum = num1 + num2

    # Convert sum back to binary string and return
    return bin(sum)[2:]

# Test cases
print(funcImp('1010', '1011'))  # Expected output: '10101'
print(funcImp('1111', '1111'))  # Expected output: '11110'
print(funcImp('0000', '0000'))  # Expected output: '0'
print(funcImp('1101', '1001'))  # Expected output: '10110'
```",1111,1111,11110,PASS,TRUE,N/A
4,3,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum also in binary form.
    The built-in int() function is used to convert the binary strings into integers, then the sum of these integers is calculated.
    Finally, the built-in bin() function is used to convert the sum back into a binary string. The [2:] slice operation is used to remove the '0b' prefix from the result.
    """"""
    
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)

    # Calculate sum
    sum = num1 + num2

    # Convert sum back to binary string and return
    return bin(sum)[2:]

# Test cases
print(funcImp('1010', '1011'))  # Expected output: '10101'
print(funcImp('1111', '1111'))  # Expected output: '11110'
print(funcImp('0000', '0000'))  # Expected output: '0'
print(funcImp('1101', '1001'))  # Expected output: '10110'
```",0,0,0,PASS,TRUE,N/A
4,4,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum also in binary form.
    The built-in int() function is used to convert the binary strings into integers, then the sum of these integers is calculated.
    Finally, the built-in bin() function is used to convert the sum back into a binary string. The [2:] slice operation is used to remove the '0b' prefix from the result.
    """"""
    
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)

    # Calculate sum
    sum = num1 + num2

    # Convert sum back to binary string and return
    return bin(sum)[2:]

# Test cases
print(funcImp('1010', '1011'))  # Expected output: '10101'
print(funcImp('1111', '1111'))  # Expected output: '11110'
print(funcImp('0000', '0000'))  # Expected output: '0'
print(funcImp('1101', '1001'))  # Expected output: '10110'
```",1101,1001,10110,PASS,TRUE,N/A
5,1,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def sum_of_odd_numbers(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.

    Returns:
    int: The sum of all odd numbers between start and end.
    """"""
    
    # Initialize the sum to 0
    total = 0
    
    # Loop through all numbers from start to end
    for i in range(start, end + 1):
        # If the number is odd, add it to the total
        if i % 2 != 0:
            total += i
            
    return total

# Test cases to verify the function

print(sum_of_odd_numbers(1, 10))   # Expected output: 25
print(sum_of_odd_numbers(3, 7))   # Expected output: 16
print(sum_of_odd_numbers(-5, 5))   # Expected output: -1
print(sum_of_odd_numbers(0, 0))   # Expected output: 0
```","(1, 10)",25,25,PASS,TRUE,N/A
5,2,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def sum_of_odd_numbers(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.

    Returns:
    int: The sum of all odd numbers between start and end.
    """"""
    
    # Initialize the sum to 0
    total = 0
    
    # Loop through all numbers from start to end
    for i in range(start, end + 1):
        # If the number is odd, add it to the total
        if i % 2 != 0:
            total += i
            
    return total

# Test cases to verify the function

print(sum_of_odd_numbers(1, 10))   # Expected output: 25
print(sum_of_odd_numbers(3, 7))   # Expected output: 16
print(sum_of_odd_numbers(-5, 5))   # Expected output: -1
print(sum_of_odd_numbers(0, 0))   # Expected output: 0
```","(3, 7)",16,15,FAIL,FALSE,N/A
5,3,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def sum_of_odd_numbers(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.

    Returns:
    int: The sum of all odd numbers between start and end.
    """"""
    
    # Initialize the sum to 0
    total = 0
    
    # Loop through all numbers from start to end
    for i in range(start, end + 1):
        # If the number is odd, add it to the total
        if i % 2 != 0:
            total += i
            
    return total

# Test cases to verify the function

print(sum_of_odd_numbers(1, 10))   # Expected output: 25
print(sum_of_odd_numbers(3, 7))   # Expected output: 16
print(sum_of_odd_numbers(-5, 5))   # Expected output: -1
print(sum_of_odd_numbers(0, 0))   # Expected output: 0
```","(-5, 5)",-4,0,FAIL,FALSE,N/A
5,4,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def sum_of_odd_numbers(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.

    Returns:
    int: The sum of all odd numbers between start and end.
    """"""
    
    # Initialize the sum to 0
    total = 0
    
    # Loop through all numbers from start to end
    for i in range(start, end + 1):
        # If the number is odd, add it to the total
        if i % 2 != 0:
            total += i
            
    return total

# Test cases to verify the function

print(sum_of_odd_numbers(1, 10))   # Expected output: 25
print(sum_of_odd_numbers(3, 7))   # Expected output: 16
print(sum_of_odd_numbers(-5, 5))   # Expected output: -1
print(sum_of_odd_numbers(0, 0))   # Expected output: 0
```","(0, 0)",0,0,PASS,TRUE,N/A
6,1,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    """"""
    # Function to check if a number is prime
    def is_prime(n):
        if n <= 1:
            return False
        elif n <= 3:
            return True
        elif n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    # Calculate the sum of primes in the range
    sum_of_primes = sum(i for i in range(start, end + 1) if is_prime(i))
    
    return sum_of_primes


# Test cases to verify the function

print(funcImp(2,10)) # Expected output:17 (2+3+5+7)
print(funcImp(10,30)) # Expected output:112 (11+13+17+19+23+29)
print(funcImp(0,20)) # Expected output:77 (2+3+5+7+11+13+17+19)
```","(2, 10)",17,17,PASS,TRUE,N/A
6,2,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    """"""
    # Function to check if a number is prime
    def is_prime(n):
        if n <= 1:
            return False
        elif n <= 3:
            return True
        elif n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    # Calculate the sum of primes in the range
    sum_of_primes = sum(i for i in range(start, end + 1) if is_prime(i))
    
    return sum_of_primes


# Test cases to verify the function

print(funcImp(2,10)) # Expected output:17 (2+3+5+7)
print(funcImp(10,30)) # Expected output:112 (11+13+17+19+23+29)
print(funcImp(0,20)) # Expected output:77 (2+3+5+7+11+13+17+19)
```","(10, 30)",112,112,PASS,TRUE,N/A
6,3,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    """"""
    # Function to check if a number is prime
    def is_prime(n):
        if n <= 1:
            return False
        elif n <= 3:
            return True
        elif n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    # Calculate the sum of primes in the range
    sum_of_primes = sum(i for i in range(start, end + 1) if is_prime(i))
    
    return sum_of_primes


# Test cases to verify the function

print(funcImp(2,10)) # Expected output:17 (2+3+5+7)
print(funcImp(10,30)) # Expected output:112 (11+13+17+19+23+29)
print(funcImp(0,20)) # Expected output:77 (2+3+5+7+11+13+17+19)
```","(0, 20)",77,77,PASS,TRUE,N/A
7,1,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers as input and returns their average.
    It uses a for loop to iterate over the numbers and calculate their sum, 
    then divides the sum by the number of elements in the list to get the average.
    """"""
    
    # Initialize sum to 0
    sum = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Add current number to sum
        sum += num
    
    # Calculate average by dividing sum by number of elements in list
    average = sum / len(numbers)
    
    return average

# Test cases to verify the function

print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0
print(funcImp([10, 20, 30]))       # Expected output: 20.0
print(funcImp([-1, -2, -3]))       # Expected output: -2.0
print(funcImp([100]))              # Expected output: 100.0
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,N/A
7,2,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers as input and returns their average.
    It uses a for loop to iterate over the numbers and calculate their sum, 
    then divides the sum by the number of elements in the list to get the average.
    """"""
    
    # Initialize sum to 0
    sum = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Add current number to sum
        sum += num
    
    # Calculate average by dividing sum by number of elements in list
    average = sum / len(numbers)
    
    return average

# Test cases to verify the function

print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0
print(funcImp([10, 20, 30]))       # Expected output: 20.0
print(funcImp([-1, -2, -3]))       # Expected output: -2.0
print(funcImp([100]))              # Expected output: 100.0
```","[10, 20, 30]",20,20,PASS,TRUE,N/A
7,3,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers as input and returns their average.
    It uses a for loop to iterate over the numbers and calculate their sum, 
    then divides the sum by the number of elements in the list to get the average.
    """"""
    
    # Initialize sum to 0
    sum = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Add current number to sum
        sum += num
    
    # Calculate average by dividing sum by number of elements in list
    average = sum / len(numbers)
    
    return average

# Test cases to verify the function

print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0
print(funcImp([10, 20, 30]))       # Expected output: 20.0
print(funcImp([-1, -2, -3]))       # Expected output: -2.0
print(funcImp([100]))              # Expected output: 100.0
```","[-1, -2, -3]",-2,-2,PASS,TRUE,N/A
7,4,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function takes a list of numbers as input and returns their average.
    It uses a for loop to iterate over the numbers and calculate their sum, 
    then divides the sum by the number of elements in the list to get the average.
    """"""
    
    # Initialize sum to 0
    sum = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Add current number to sum
        sum += num
    
    # Calculate average by dividing sum by number of elements in list
    average = sum / len(numbers)
    
    return average

# Test cases to verify the function

print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 3.0
print(funcImp([10, 20, 30]))       # Expected output: 20.0
print(funcImp([-1, -2, -3]))       # Expected output: -2.0
print(funcImp([100]))              # Expected output: 100.0
```",[100],100,100,PASS,TRUE,N/A
8,1,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst, n = None):
    """"""
    This function calculates the average of a list of numbers using recursion.
    
    Parameters:
    lst (list): A list of numbers.
    n (int): The length of the list. Default is None.

    Returns:
    float: The average of the numbers in the list.
    """"""
    
    # If n is None, it means this is the first call to funcImp
    # So we initialize n to be len(lst)
    if n == None:
        n = len(lst)

    # Base case: if lst is empty, return 0
    if not lst:
        return 0

    # Recursive case: add lst[0] to funcImp called on lst[1:] and divide by n
    else:
        return (lst[0] + ((n - 1) * funcImp(lst[1:], n - 1))) / n


# Test cases to validate the solution

# Average of [2,4,6] should be 4.0
assert(funcImp([2,4,6]) == 4.0)

# Average of [5] should be 5.0
assert(funcImp([5]) == 5.0)

# Average of [] should be 0
assert(funcImp([]) == 0)

print(""All test cases passed"")
```","[2, 4, 6]",4,4,PASS,TRUE,N/A
8,2,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst, n = None):
    """"""
    This function calculates the average of a list of numbers using recursion.
    
    Parameters:
    lst (list): A list of numbers.
    n (int): The length of the list. Default is None.

    Returns:
    float: The average of the numbers in the list.
    """"""
    
    # If n is None, it means this is the first call to funcImp
    # So we initialize n to be len(lst)
    if n == None:
        n = len(lst)

    # Base case: if lst is empty, return 0
    if not lst:
        return 0

    # Recursive case: add lst[0] to funcImp called on lst[1:] and divide by n
    else:
        return (lst[0] + ((n - 1) * funcImp(lst[1:], n - 1))) / n


# Test cases to validate the solution

# Average of [2,4,6] should be 4.0
assert(funcImp([2,4,6]) == 4.0)

# Average of [5] should be 5.0
assert(funcImp([5]) == 5.0)

# Average of [] should be 0
assert(funcImp([]) == 0)

print(""All test cases passed"")
```",[5],5,5,PASS,TRUE,N/A
8,3,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst, n = None):
    """"""
    This function calculates the average of a list of numbers using recursion.
    
    Parameters:
    lst (list): A list of numbers.
    n (int): The length of the list. Default is None.

    Returns:
    float: The average of the numbers in the list.
    """"""
    
    # If n is None, it means this is the first call to funcImp
    # So we initialize n to be len(lst)
    if n == None:
        n = len(lst)

    # Base case: if lst is empty, return 0
    if not lst:
        return 0

    # Recursive case: add lst[0] to funcImp called on lst[1:] and divide by n
    else:
        return (lst[0] + ((n - 1) * funcImp(lst[1:], n - 1))) / n


# Test cases to validate the solution

# Average of [2,4,6] should be 4.0
assert(funcImp([2,4,6]) == 4.0)

# Average of [5] should be 5.0
assert(funcImp([5]) == 5.0)

# Average of [] should be 0
assert(funcImp([]) == 0)

print(""All test cases passed"")
```",[],0,0,PASS,TRUE,N/A
9,1,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' to calculate the average of a list of numbers
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers without using any built-in functions or libraries.
    
    Parameters:
    numbers (list): A list of numbers

    Returns:
    float: The average of the numbers in the list
    """"""
    
    # Initialize a variable to store the sum of all numbers in the list
    total = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Add each number to 'total'
        total += num
    
    # Calculate and return the average by dividing 'total' by the length of 'numbers'
    return total / len(numbers)


# Test cases to verify that 'funcImp' works correctly

print(funcImp([1, 2, 3, 4, 5]))  # Expected output: 3.0
print(funcImp([10, 20, 30, 40]))  # Expected output: 25.0
print(funcImp([-1, -2, -3]))      # Expected output: -2.0
print(funcImp([0]))               # Expected output: 0.0
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,N/A
9,2,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' to calculate the average of a list of numbers
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers without using any built-in functions or libraries.
    
    Parameters:
    numbers (list): A list of numbers

    Returns:
    float: The average of the numbers in the list
    """"""
    
    # Initialize a variable to store the sum of all numbers in the list
    total = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Add each number to 'total'
        total += num
    
    # Calculate and return the average by dividing 'total' by the length of 'numbers'
    return total / len(numbers)


# Test cases to verify that 'funcImp' works correctly

print(funcImp([1, 2, 3, 4, 5]))  # Expected output: 3.0
print(funcImp([10, 20, 30, 40]))  # Expected output: 25.0
print(funcImp([-1, -2, -3]))      # Expected output: -2.0
print(funcImp([0]))               # Expected output: 0.0
```","[10, 20, 30, 40]",25,25,PASS,TRUE,N/A
9,3,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' to calculate the average of a list of numbers
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers without using any built-in functions or libraries.
    
    Parameters:
    numbers (list): A list of numbers

    Returns:
    float: The average of the numbers in the list
    """"""
    
    # Initialize a variable to store the sum of all numbers in the list
    total = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Add each number to 'total'
        total += num
    
    # Calculate and return the average by dividing 'total' by the length of 'numbers'
    return total / len(numbers)


# Test cases to verify that 'funcImp' works correctly

print(funcImp([1, 2, 3, 4, 5]))  # Expected output: 3.0
print(funcImp([10, 20, 30, 40]))  # Expected output: 25.0
print(funcImp([-1, -2, -3]))      # Expected output: -2.0
print(funcImp([0]))               # Expected output: 0.0
```","[-1, -2, -3]",-2,-2,PASS,TRUE,N/A
9,4,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' to calculate the average of a list of numbers
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers without using any built-in functions or libraries.
    
    Parameters:
    numbers (list): A list of numbers

    Returns:
    float: The average of the numbers in the list
    """"""
    
    # Initialize a variable to store the sum of all numbers in the list
    total = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Add each number to 'total'
        total += num
    
    # Calculate and return the average by dividing 'total' by the length of 'numbers'
    return total / len(numbers)


# Test cases to verify that 'funcImp' works correctly

print(funcImp([1, 2, 3, 4, 5]))  # Expected output: 3.0
print(funcImp([10, 20, 30, 40]))  # Expected output: 25.0
print(funcImp([-1, -2, -3]))      # Expected output: -2.0
print(funcImp([0]))               # Expected output: 0.0
```",[0],0,0,PASS,TRUE,N/A
10,1,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst):
    """"""
    This function calculates the average of a list of numbers. It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    lst (list): A list of numbers

    Returns:
    float: The average of the numbers in the list, or None if the list is empty or contains only invalid entries.
    """"""
    
    # Initialize sum and count variables to 0
    sum = 0
    count = 0
    
    # Iterate over each element in the list
    for num in lst:
        # Check if the element is a number (int or float)
        if isinstance(num, (int, float)):
            # If it's a number, add it to the sum and increment the count
            sum += num
            count += 1
            
    # If count is still 0, it means that there were no valid numbers in the list. Return None in this case.
    if count == 0:
        return None
    
    # Calculate and return the average
    return sum / count


# Test cases to verify correctness of funcImp function

print(funcImp([1,2,3]))       # Expected output: 2.0
print(funcImp([1,'a',3]))     # Expected output: 2.0
print(funcImp(['a','b','c'])) # Expected output: None
print(funcImp([]))            # Expected output: None
```","[1, 2, 3]",2,2,PASS,TRUE,N/A
10,2,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst):
    """"""
    This function calculates the average of a list of numbers. It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    lst (list): A list of numbers

    Returns:
    float: The average of the numbers in the list, or None if the list is empty or contains only invalid entries.
    """"""
    
    # Initialize sum and count variables to 0
    sum = 0
    count = 0
    
    # Iterate over each element in the list
    for num in lst:
        # Check if the element is a number (int or float)
        if isinstance(num, (int, float)):
            # If it's a number, add it to the sum and increment the count
            sum += num
            count += 1
            
    # If count is still 0, it means that there were no valid numbers in the list. Return None in this case.
    if count == 0:
        return None
    
    # Calculate and return the average
    return sum / count


# Test cases to verify correctness of funcImp function

print(funcImp([1,2,3]))       # Expected output: 2.0
print(funcImp([1,'a',3]))     # Expected output: 2.0
print(funcImp(['a','b','c'])) # Expected output: None
print(funcImp([]))            # Expected output: None
```","[1, 'a', 3]",2,2,PASS,TRUE,N/A
10,3,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst):
    """"""
    This function calculates the average of a list of numbers. It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    lst (list): A list of numbers

    Returns:
    float: The average of the numbers in the list, or None if the list is empty or contains only invalid entries.
    """"""
    
    # Initialize sum and count variables to 0
    sum = 0
    count = 0
    
    # Iterate over each element in the list
    for num in lst:
        # Check if the element is a number (int or float)
        if isinstance(num, (int, float)):
            # If it's a number, add it to the sum and increment the count
            sum += num
            count += 1
            
    # If count is still 0, it means that there were no valid numbers in the list. Return None in this case.
    if count == 0:
        return None
    
    # Calculate and return the average
    return sum / count


# Test cases to verify correctness of funcImp function

print(funcImp([1,2,3]))       # Expected output: 2.0
print(funcImp([1,'a',3]))     # Expected output: 2.0
print(funcImp(['a','b','c'])) # Expected output: None
print(funcImp([]))            # Expected output: None
```","['a', 'b', 'c']",,,PASS,TRUE,N/A
10,4,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst):
    """"""
    This function calculates the average of a list of numbers. It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    lst (list): A list of numbers

    Returns:
    float: The average of the numbers in the list, or None if the list is empty or contains only invalid entries.
    """"""
    
    # Initialize sum and count variables to 0
    sum = 0
    count = 0
    
    # Iterate over each element in the list
    for num in lst:
        # Check if the element is a number (int or float)
        if isinstance(num, (int, float)):
            # If it's a number, add it to the sum and increment the count
            sum += num
            count += 1
            
    # If count is still 0, it means that there were no valid numbers in the list. Return None in this case.
    if count == 0:
        return None
    
    # Calculate and return the average
    return sum / count


# Test cases to verify correctness of funcImp function

print(funcImp([1,2,3]))       # Expected output: 2.0
print(funcImp([1,'a',3]))     # Expected output: 2.0
print(funcImp(['a','b','c'])) # Expected output: None
print(funcImp([]))            # Expected output: None
```",[],,,PASS,TRUE,N/A
11,1,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    This function calculates the weighted average of a list of numbers.
    
    Parameters:
    numbers (list): A list of numbers.
    weights (list): A list of weights corresponding to each number in the 'numbers' list.

    Returns:
    float: The weighted average of the 'numbers' list.
    """"""
    
    # Check if lengths of both lists are equal
    if len(numbers) != len(weights):
        return ""Error: Lists must be of same length""
    
    # Calculate the sum product of numbers and their respective weights
    sum_product = sum([a*b for a,b in zip(numbers,weights)])
    
    # Calculate the sum of all weights
    total_weights = sum(weights)
    
    # Calculate and return the weighted average
    return sum_product / total_weights

# Test cases to verify the function

print(funcImp([1, 2, 3], [4, 5, 6]))  # Expected output: 2.3333333333333335
print(funcImp([10, 20, 30], [3, 3, 4]))  # Expected output: 22.5
print(funcImp([1.5, 2.5], [3, 3]))   # Expected output: 2.0
```","([1, 2, 3], [4, 5, 6])",2.333333333,2.133333333,FAIL,FALSE,N/A
11,2,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    This function calculates the weighted average of a list of numbers.
    
    Parameters:
    numbers (list): A list of numbers.
    weights (list): A list of weights corresponding to each number in the 'numbers' list.

    Returns:
    float: The weighted average of the 'numbers' list.
    """"""
    
    # Check if lengths of both lists are equal
    if len(numbers) != len(weights):
        return ""Error: Lists must be of same length""
    
    # Calculate the sum product of numbers and their respective weights
    sum_product = sum([a*b for a,b in zip(numbers,weights)])
    
    # Calculate the sum of all weights
    total_weights = sum(weights)
    
    # Calculate and return the weighted average
    return sum_product / total_weights

# Test cases to verify the function

print(funcImp([1, 2, 3], [4, 5, 6]))  # Expected output: 2.3333333333333335
print(funcImp([10, 20, 30], [3, 3, 4]))  # Expected output: 22.5
print(funcImp([1.5, 2.5], [3, 3]))   # Expected output: 2.0
```","([10, 20, 30], [3, 3, 4])",22.5,21,FAIL,FALSE,N/A
11,3,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    This function calculates the weighted average of a list of numbers.
    
    Parameters:
    numbers (list): A list of numbers.
    weights (list): A list of weights corresponding to each number in the 'numbers' list.

    Returns:
    float: The weighted average of the 'numbers' list.
    """"""
    
    # Check if lengths of both lists are equal
    if len(numbers) != len(weights):
        return ""Error: Lists must be of same length""
    
    # Calculate the sum product of numbers and their respective weights
    sum_product = sum([a*b for a,b in zip(numbers,weights)])
    
    # Calculate the sum of all weights
    total_weights = sum(weights)
    
    # Calculate and return the weighted average
    return sum_product / total_weights

# Test cases to verify the function

print(funcImp([1, 2, 3], [4, 5, 6]))  # Expected output: 2.3333333333333335
print(funcImp([10, 20, 30], [3, 3, 4]))  # Expected output: 22.5
print(funcImp([1.5, 2.5], [3, 3]))   # Expected output: 2.0
```","([1.5, 2.5], [3, 3])",2,2,PASS,TRUE,N/A
12,1,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median (middle value) of a list of numbers and then calculates 
    the average of all values greater than or equal to the median.
    
    Parameters:
        numbers (list): A list of numbers.

    Returns:
        float: The average of all values greater than or equal to the median.
    """"""
    
    # Sort the list in ascending order
    numbers.sort()
    
    # Find the length of the list
    n = len(numbers)
    
    # Check if length is even or odd and find the median accordingly
    if n % 2 == 0:
        median = (numbers[n//2 - 1] + numbers[n//2]) / 2
    else:
        median = numbers[n//2]
        
    # Filter out all values greater than or equal to median and calculate their average
    avg = sum(num for num in numbers if num >= median) / len([num for num in numbers if num >= median])
    
    return avg

# Test cases to verify the function

print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 4.0
print(funcImp([10, 20, 30, 40]))   # Expected output: 35.0
print(funcImp([-5, -4, -3, -2]))   # Expected output: -3.0
print(funcImp([1]))                # Expected output: 1.0
```","[1, 2, 3, 4, 5]",4,4,PASS,TRUE,N/A
12,2,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median (middle value) of a list of numbers and then calculates 
    the average of all values greater than or equal to the median.
    
    Parameters:
        numbers (list): A list of numbers.

    Returns:
        float: The average of all values greater than or equal to the median.
    """"""
    
    # Sort the list in ascending order
    numbers.sort()
    
    # Find the length of the list
    n = len(numbers)
    
    # Check if length is even or odd and find the median accordingly
    if n % 2 == 0:
        median = (numbers[n//2 - 1] + numbers[n//2]) / 2
    else:
        median = numbers[n//2]
        
    # Filter out all values greater than or equal to median and calculate their average
    avg = sum(num for num in numbers if num >= median) / len([num for num in numbers if num >= median])
    
    return avg

# Test cases to verify the function

print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 4.0
print(funcImp([10, 20, 30, 40]))   # Expected output: 35.0
print(funcImp([-5, -4, -3, -2]))   # Expected output: -3.0
print(funcImp([1]))                # Expected output: 1.0
```","[10, 20, 30, 40]",35,35,PASS,TRUE,N/A
12,3,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median (middle value) of a list of numbers and then calculates 
    the average of all values greater than or equal to the median.
    
    Parameters:
        numbers (list): A list of numbers.

    Returns:
        float: The average of all values greater than or equal to the median.
    """"""
    
    # Sort the list in ascending order
    numbers.sort()
    
    # Find the length of the list
    n = len(numbers)
    
    # Check if length is even or odd and find the median accordingly
    if n % 2 == 0:
        median = (numbers[n//2 - 1] + numbers[n//2]) / 2
    else:
        median = numbers[n//2]
        
    # Filter out all values greater than or equal to median and calculate their average
    avg = sum(num for num in numbers if num >= median) / len([num for num in numbers if num >= median])
    
    return avg

# Test cases to verify the function

print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 4.0
print(funcImp([10, 20, 30, 40]))   # Expected output: 35.0
print(funcImp([-5, -4, -3, -2]))   # Expected output: -3.0
print(funcImp([1]))                # Expected output: 1.0
```","[-5, -4, -3, -2]",-3,-2.5,FAIL,FALSE,N/A
12,4,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median (middle value) of a list of numbers and then calculates 
    the average of all values greater than or equal to the median.
    
    Parameters:
        numbers (list): A list of numbers.

    Returns:
        float: The average of all values greater than or equal to the median.
    """"""
    
    # Sort the list in ascending order
    numbers.sort()
    
    # Find the length of the list
    n = len(numbers)
    
    # Check if length is even or odd and find the median accordingly
    if n % 2 == 0:
        median = (numbers[n//2 - 1] + numbers[n//2]) / 2
    else:
        median = numbers[n//2]
        
    # Filter out all values greater than or equal to median and calculate their average
    avg = sum(num for num in numbers if num >= median) / len([num for num in numbers if num >= median])
    
    return avg

# Test cases to verify the function

print(funcImp([1, 2, 3, 4, 5]))   # Expected output: 4.0
print(funcImp([10, 20, 30, 40]))   # Expected output: 35.0
print(funcImp([-5, -4, -3, -2]))   # Expected output: -3.0
print(funcImp([1]))                # Expected output: 1.0
```",[1],1,1,PASS,TRUE,N/A
13,1,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst, window_size):
    """"""
    This function calculates the moving average of a given list.
    
    Parameters:
    lst (list): The input list.
    window_size (int): The size of the sliding window.

    Returns:
    list: A list containing the moving averages.
    """"""
    
    # Check if the window size is greater than the length of the list
    if window_size > len(lst):
        return ""Window size is greater than list length.""
    
    # Initialize an empty list to store the moving averages
    moving_averages = []
    
    # Iterate over the input list
    for i in range(len(lst) - window_size + 1):
        # Calculate the sum of current window
        this_window = lst[i : i + window_size]
        
        # Calculate and append the average of current window to 'moving_averages'
        moving_averages.append(sum(this_window) / window_size)
        
    return moving_averages

# Test cases
print(funcImp([3, 5, 7, 2, 8, 10, 11, 65, 72, 81, 99, 100, 150],3)) 
# Expected output: [5.0,4.666666666666667,5.666666666666667,
#                   6.666666666666667,9.666666666666668,
#                   28.666666666666668,
#                   49.333333333333336,
#                   72.666666666667,
#                   84.0,
#                  93.333333333334,
#                 116.333333333334]

print(funcImp([1],3)) 
# Expected output: ""Window size is greater than list length.""
```","([3, 5, 7, 2, 8, 10, 11, 65, 72, 81, 99, 100, 150], 3)","[5.0, 4.666666666666667, 5.666666666666667, 6.666666666666667, 9.666666666666668, 28.666666666666668, 49.333333333333336, 72.66, 84.0, 93.33, 116.33]","[5.0, 4.666666666666667, 5.666666666666667, 6.666666666666667, 9.666666666666666, 28.666666666666668, 49.333333333333336, 72.66666666666667, 84.0, 93.33333333333333, 116.33333333333333]",FAIL,FALSE,N/A
13,2,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst, window_size):
    """"""
    This function calculates the moving average of a given list.
    
    Parameters:
    lst (list): The input list.
    window_size (int): The size of the sliding window.

    Returns:
    list: A list containing the moving averages.
    """"""
    
    # Check if the window size is greater than the length of the list
    if window_size > len(lst):
        return ""Window size is greater than list length.""
    
    # Initialize an empty list to store the moving averages
    moving_averages = []
    
    # Iterate over the input list
    for i in range(len(lst) - window_size + 1):
        # Calculate the sum of current window
        this_window = lst[i : i + window_size]
        
        # Calculate and append the average of current window to 'moving_averages'
        moving_averages.append(sum(this_window) / window_size)
        
    return moving_averages

# Test cases
print(funcImp([3, 5, 7, 2, 8, 10, 11, 65, 72, 81, 99, 100, 150],3)) 
# Expected output: [5.0,4.666666666666667,5.666666666666667,
#                   6.666666666666667,9.666666666666668,
#                   28.666666666666668,
#                   49.333333333333336,
#                   72.666666666667,
#                   84.0,
#                  93.333333333334,
#                 116.333333333334]

print(funcImp([1],3)) 
# Expected output: ""Window size is greater than list length.""
```","([1], 3)",Window size is greater than list length.,Window size is greater than list length.,PASS,TRUE,N/A
14,1,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def running_average(arr):
    """"""
    This function takes a list of numbers as input and returns a list of running averages.
    
    Parameters:
    arr (list): A list of numbers.

    Returns:
    list: A list of running averages.
    """"""
    
    # Initialize an empty list to store the running averages
    running_avgs = []
    
    # Initialize a variable to keep track of the cumulative sum
    cum_sum = 0
    
    # Iterate over the input array
    for i in range(len(arr)):
        
        # Add the current element to the cumulative sum
        cum_sum += arr[i]
        
        # Calculate the running average and append it to the list
        running_avgs.append(cum_sum / (i+1))
        
    return running_avgs

# Test cases to verify the function

print(running_average([1, 2, 3, 4, 5])) 
# Expected output: [1.0, 1.5, 2.0, 2.5, 3.0]

print(running_average([10, 20, 30, 40])) 
# Expected output: [10.0, 15.0, 20.0, 25.0]

print(running_average([-1,-2,-3,-4,-5]))
# Expected output: [-1.0,-1.5,-2.0,-2.5,-3.0]
```","[1, 2, 3, 4, 5]","[1.0, 1.5, 2.0, 2.5, 3.0]","[1.0, 1.5, 2.0, 2.5, 3.0]",PASS,TRUE,N/A
14,2,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def running_average(arr):
    """"""
    This function takes a list of numbers as input and returns a list of running averages.
    
    Parameters:
    arr (list): A list of numbers.

    Returns:
    list: A list of running averages.
    """"""
    
    # Initialize an empty list to store the running averages
    running_avgs = []
    
    # Initialize a variable to keep track of the cumulative sum
    cum_sum = 0
    
    # Iterate over the input array
    for i in range(len(arr)):
        
        # Add the current element to the cumulative sum
        cum_sum += arr[i]
        
        # Calculate the running average and append it to the list
        running_avgs.append(cum_sum / (i+1))
        
    return running_avgs

# Test cases to verify the function

print(running_average([1, 2, 3, 4, 5])) 
# Expected output: [1.0, 1.5, 2.0, 2.5, 3.0]

print(running_average([10, 20, 30, 40])) 
# Expected output: [10.0, 15.0, 20.0, 25.0]

print(running_average([-1,-2,-3,-4,-5]))
# Expected output: [-1.0,-1.5,-2.0,-2.5,-3.0]
```","[10, 20, 30, 40]","[10.0, 15.0, 20.0, 25.0]","[10.0, 15.0, 20.0, 25.0]",PASS,TRUE,N/A
14,3,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def running_average(arr):
    """"""
    This function takes a list of numbers as input and returns a list of running averages.
    
    Parameters:
    arr (list): A list of numbers.

    Returns:
    list: A list of running averages.
    """"""
    
    # Initialize an empty list to store the running averages
    running_avgs = []
    
    # Initialize a variable to keep track of the cumulative sum
    cum_sum = 0
    
    # Iterate over the input array
    for i in range(len(arr)):
        
        # Add the current element to the cumulative sum
        cum_sum += arr[i]
        
        # Calculate the running average and append it to the list
        running_avgs.append(cum_sum / (i+1))
        
    return running_avgs

# Test cases to verify the function

print(running_average([1, 2, 3, 4, 5])) 
# Expected output: [1.0, 1.5, 2.0, 2.5, 3.0]

print(running_average([10, 20, 30, 40])) 
# Expected output: [10.0, 15.0, 20.0, 25.0]

print(running_average([-1,-2,-3,-4,-5]))
# Expected output: [-1.0,-1.5,-2.0,-2.5,-3.0]
```","[-1, -2, -3, -4, -5]","[-1.0, -1.5, -2.0, -2.5, -3.0]","[-1.0, -1.5, -2.0, -2.5, -3.0]",PASS,TRUE,N/A
15,1,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is prime or not.
    
    Parameters:
    n (int): The number to be checked.

    Returns:
    bool: True if the number is prime, False otherwise.
    """"""

    # A prime number is always greater than 1
    if n <= 1:
        return False

    # Check from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True


# Test cases to validate the solution

# Prime numbers
assert(funcImp(2) == True)
assert(funcImp(3) == True)
assert(funcImp(5) == True)
assert(funcImp(7) == True)

# Non-prime numbers
assert(funcImp(4) == False)
assert(funcImp(6) == False)
assert(funcImp(8) == False)
assert(funcImp(9) == False)

print(""All test cases passed"")
```",2,TRUE,TRUE,PASS,TRUE,N/A
15,2,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is prime or not.
    
    Parameters:
    n (int): The number to be checked.

    Returns:
    bool: True if the number is prime, False otherwise.
    """"""

    # A prime number is always greater than 1
    if n <= 1:
        return False

    # Check from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True


# Test cases to validate the solution

# Prime numbers
assert(funcImp(2) == True)
assert(funcImp(3) == True)
assert(funcImp(5) == True)
assert(funcImp(7) == True)

# Non-prime numbers
assert(funcImp(4) == False)
assert(funcImp(6) == False)
assert(funcImp(8) == False)
assert(funcImp(9) == False)

print(""All test cases passed"")
```",3,TRUE,TRUE,PASS,TRUE,N/A
15,3,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is prime or not.
    
    Parameters:
    n (int): The number to be checked.

    Returns:
    bool: True if the number is prime, False otherwise.
    """"""

    # A prime number is always greater than 1
    if n <= 1:
        return False

    # Check from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True


# Test cases to validate the solution

# Prime numbers
assert(funcImp(2) == True)
assert(funcImp(3) == True)
assert(funcImp(5) == True)
assert(funcImp(7) == True)

# Non-prime numbers
assert(funcImp(4) == False)
assert(funcImp(6) == False)
assert(funcImp(8) == False)
assert(funcImp(9) == False)

print(""All test cases passed"")
```",5,TRUE,TRUE,PASS,TRUE,N/A
15,4,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is prime or not.
    
    Parameters:
    n (int): The number to be checked.

    Returns:
    bool: True if the number is prime, False otherwise.
    """"""

    # A prime number is always greater than 1
    if n <= 1:
        return False

    # Check from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True


# Test cases to validate the solution

# Prime numbers
assert(funcImp(2) == True)
assert(funcImp(3) == True)
assert(funcImp(5) == True)
assert(funcImp(7) == True)

# Non-prime numbers
assert(funcImp(4) == False)
assert(funcImp(6) == False)
assert(funcImp(8) == False)
assert(funcImp(9) == False)

print(""All test cases passed"")
```",7,TRUE,TRUE,PASS,TRUE,N/A
15,5,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is prime or not.
    
    Parameters:
    n (int): The number to be checked.

    Returns:
    bool: True if the number is prime, False otherwise.
    """"""

    # A prime number is always greater than 1
    if n <= 1:
        return False

    # Check from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True


# Test cases to validate the solution

# Prime numbers
assert(funcImp(2) == True)
assert(funcImp(3) == True)
assert(funcImp(5) == True)
assert(funcImp(7) == True)

# Non-prime numbers
assert(funcImp(4) == False)
assert(funcImp(6) == False)
assert(funcImp(8) == False)
assert(funcImp(9) == False)

print(""All test cases passed"")
```",4,FALSE,FALSE,PASS,TRUE,N/A
15,6,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is prime or not.
    
    Parameters:
    n (int): The number to be checked.

    Returns:
    bool: True if the number is prime, False otherwise.
    """"""

    # A prime number is always greater than 1
    if n <= 1:
        return False

    # Check from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True


# Test cases to validate the solution

# Prime numbers
assert(funcImp(2) == True)
assert(funcImp(3) == True)
assert(funcImp(5) == True)
assert(funcImp(7) == True)

# Non-prime numbers
assert(funcImp(4) == False)
assert(funcImp(6) == False)
assert(funcImp(8) == False)
assert(funcImp(9) == False)

print(""All test cases passed"")
```",6,FALSE,FALSE,PASS,TRUE,N/A
15,7,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is prime or not.
    
    Parameters:
    n (int): The number to be checked.

    Returns:
    bool: True if the number is prime, False otherwise.
    """"""

    # A prime number is always greater than 1
    if n <= 1:
        return False

    # Check from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True


# Test cases to validate the solution

# Prime numbers
assert(funcImp(2) == True)
assert(funcImp(3) == True)
assert(funcImp(5) == True)
assert(funcImp(7) == True)

# Non-prime numbers
assert(funcImp(4) == False)
assert(funcImp(6) == False)
assert(funcImp(8) == False)
assert(funcImp(9) == False)

print(""All test cases passed"")
```",8,FALSE,FALSE,PASS,TRUE,N/A
15,8,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is prime or not.
    
    Parameters:
    n (int): The number to be checked.

    Returns:
    bool: True if the number is prime, False otherwise.
    """"""

    # A prime number is always greater than 1
    if n <= 1:
        return False

    # Check from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True


# Test cases to validate the solution

# Prime numbers
assert(funcImp(2) == True)
assert(funcImp(3) == True)
assert(funcImp(5) == True)
assert(funcImp(7) == True)

# Non-prime numbers
assert(funcImp(4) == False)
assert(funcImp(6) == False)
assert(funcImp(8) == False)
assert(funcImp(9) == False)

print(""All test cases passed"")
```",9,FALSE,FALSE,PASS,TRUE,N/A
16,1,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def next_prime(n):
    """"""
    This function takes an integer as input and returns the smallest prime number greater than the input.
    """"""
    def is_prime(num):
        """"""
        Nested helper function to check if a number is prime.
        """"""
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    # Start checking from the next number
    num = n + 1

    # Keep incrementing num until we find a prime
    while True:
        if is_prime(num):
            return num
        else:
            num += 1


# Testing the function with some test cases

print(next_prime(3))   # Expected output: 5
print(next_prime(11))  # Expected output: 13
print(next_prime(24))  # Expected output: 29
```",3,5,5,PASS,TRUE,N/A
16,2,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def next_prime(n):
    """"""
    This function takes an integer as input and returns the smallest prime number greater than the input.
    """"""
    def is_prime(num):
        """"""
        Nested helper function to check if a number is prime.
        """"""
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    # Start checking from the next number
    num = n + 1

    # Keep incrementing num until we find a prime
    while True:
        if is_prime(num):
            return num
        else:
            num += 1


# Testing the function with some test cases

print(next_prime(3))   # Expected output: 5
print(next_prime(11))  # Expected output: 13
print(next_prime(24))  # Expected output: 29
```",11,13,13,PASS,TRUE,N/A
16,3,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def next_prime(n):
    """"""
    This function takes an integer as input and returns the smallest prime number greater than the input.
    """"""
    def is_prime(num):
        """"""
        Nested helper function to check if a number is prime.
        """"""
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    # Start checking from the next number
    num = n + 1

    # Keep incrementing num until we find a prime
    while True:
        if is_prime(num):
            return num
        else:
            num += 1


# Testing the function with some test cases

print(next_prime(3))   # Expected output: 5
print(next_prime(11))  # Expected output: 13
print(next_prime(24))  # Expected output: 29
```",24,29,29,PASS,TRUE,N/A
17,1,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def print_prime_numbers(start, end):
    """"""
    This function prints all the prime numbers between start and end (both inclusive).
    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.
    The first few prime numbers are {2, 3, 5, 7, 11, ?}.
    """"""
    
    # Check if start is less than 2 and if so set it to 2
    if start < 2:
        start = 2

    for num in range(start, end + 1):
        # all prime numbers are greater than 1
        if num > 1:
            for i in range(2, num):
                # check for factors
                if (num % i) == 0:
                    # not a prime number so break inner loop and skip to next number
                    break
            else:
                print(num)

# Test the function with some test cases

print(""Prime numbers between 10 and 30 are:"")
print_prime_numbers(10,30)

print(""\nPrime numbers between -5 and 20 are:"")
print_prime_numbers(-5,20)
```","(10,30)","11
13
17
19
23
29","11
13
17
19
23
29",PASS,TRUE,N/A
17,2,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def print_prime_numbers(start, end):
    """"""
    This function prints all the prime numbers between start and end (both inclusive).
    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.
    The first few prime numbers are {2, 3, 5, 7, 11, ?}.
    """"""
    
    # Check if start is less than 2 and if so set it to 2
    if start < 2:
        start = 2

    for num in range(start, end + 1):
        # all prime numbers are greater than 1
        if num > 1:
            for i in range(2, num):
                # check for factors
                if (num % i) == 0:
                    # not a prime number so break inner loop and skip to next number
                    break
            else:
                print(num)

# Test the function with some test cases

print(""Prime numbers between 10 and 30 are:"")
print_prime_numbers(10,30)

print(""\nPrime numbers between -5 and 20 are:"")
print_prime_numbers(-5,20)
```","(-5,20)","2
3
5
7
11
13
17
19","2
3
5
7
11
13
17
19",PASS,TRUE,N/A
18,1,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range.
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.

    Returns:
    int: The sum of all prime numbers within the given range.
    """"""

    def is_prime(n):
        """"""Check if a number is prime.""""""
        if n <= 1:
            return False
        elif n <= 3:
            return True
        elif n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    # Calculate the sum of primes in the given range.
    sum_of_primes = sum(i for i in range(start, end + 1) if is_prime(i))
    
    return sum_of_primes


# Test cases to verify the function.

assert funcImp(1,10) == 17 # Prime numbers between 1 and 10 are [2,3,5,7] and their sum is 17.
assert funcImp(10,30) == 60 # Prime numbers between 10 and 30 are [11,13,17,19,23,29] and their sum is 60.
assert funcImp(100,200) ==1060 # Prime numbers between100 and200 are [101,103,...199] and their sum is1060. 
```","(1, 10)",17,17,PASS,TRUE,N/A
18,2,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range.
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.

    Returns:
    int: The sum of all prime numbers within the given range.
    """"""

    def is_prime(n):
        """"""Check if a number is prime.""""""
        if n <= 1:
            return False
        elif n <= 3:
            return True
        elif n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    # Calculate the sum of primes in the given range.
    sum_of_primes = sum(i for i in range(start, end + 1) if is_prime(i))
    
    return sum_of_primes


# Test cases to verify the function.

assert funcImp(1,10) == 17 # Prime numbers between 1 and 10 are [2,3,5,7] and their sum is 17.
assert funcImp(10,30) == 60 # Prime numbers between 10 and 30 are [11,13,17,19,23,29] and their sum is 60.
assert funcImp(100,200) ==1060 # Prime numbers between100 and200 are [101,103,...199] and their sum is1060. 
```","(10, 30)",60,112,FAIL,FALSE,N/A
18,3,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range.
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.

    Returns:
    int: The sum of all prime numbers within the given range.
    """"""

    def is_prime(n):
        """"""Check if a number is prime.""""""
        if n <= 1:
            return False
        elif n <= 3:
            return True
        elif n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    # Calculate the sum of primes in the given range.
    sum_of_primes = sum(i for i in range(start, end + 1) if is_prime(i))
    
    return sum_of_primes


# Test cases to verify the function.

assert funcImp(1,10) == 17 # Prime numbers between 1 and 10 are [2,3,5,7] and their sum is 17.
assert funcImp(10,30) == 60 # Prime numbers between 10 and 30 are [11,13,17,19,23,29] and their sum is 60.
assert funcImp(100,200) ==1060 # Prime numbers between100 and200 are [101,103,...199] and their sum is1060. 
```","(100, 200)",1060,3167,FAIL,FALSE,N/A
19,1,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function calculates the largest prime factor of a given number.
    It first checks if the number is even and divides it by 2 until it becomes odd.
    Then, it starts checking for factors from 3 up to square root of n. If a factor is found, 
    it divides the number by that factor until it can't be divided anymore.
    The last remaining value of n will be the largest prime factor.
    """"""
    
    # Check if n is even and divide by 2 until it becomes odd
    while n % 2 == 0:
        max_prime = 2
        n /= 2
    
    # Start checking for factors from 3 up to sqrt(n)
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n /= i
    
    # If n is still greater than 2, then it must be a prime number itself
    if n > 2:
        max_prime = n

    return max_prime


# Test cases to verify the correctness of the function

print(funcImp(10))   # Expected output: 5 (prime factors are: [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are: [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are: [3,7])
print(funcImp(100))   # Expected output: 5 (prime factors are: [2,5])
```",10,5,5,PASS,TRUE,N/A
19,2,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function calculates the largest prime factor of a given number.
    It first checks if the number is even and divides it by 2 until it becomes odd.
    Then, it starts checking for factors from 3 up to square root of n. If a factor is found, 
    it divides the number by that factor until it can't be divided anymore.
    The last remaining value of n will be the largest prime factor.
    """"""
    
    # Check if n is even and divide by 2 until it becomes odd
    while n % 2 == 0:
        max_prime = 2
        n /= 2
    
    # Start checking for factors from 3 up to sqrt(n)
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n /= i
    
    # If n is still greater than 2, then it must be a prime number itself
    if n > 2:
        max_prime = n

    return max_prime


# Test cases to verify the correctness of the function

print(funcImp(10))   # Expected output: 5 (prime factors are: [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are: [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are: [3,7])
print(funcImp(100))   # Expected output: 5 (prime factors are: [2,5])
```",15,5,5,PASS,TRUE,N/A
19,3,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function calculates the largest prime factor of a given number.
    It first checks if the number is even and divides it by 2 until it becomes odd.
    Then, it starts checking for factors from 3 up to square root of n. If a factor is found, 
    it divides the number by that factor until it can't be divided anymore.
    The last remaining value of n will be the largest prime factor.
    """"""
    
    # Check if n is even and divide by 2 until it becomes odd
    while n % 2 == 0:
        max_prime = 2
        n /= 2
    
    # Start checking for factors from 3 up to sqrt(n)
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n /= i
    
    # If n is still greater than 2, then it must be a prime number itself
    if n > 2:
        max_prime = n

    return max_prime


# Test cases to verify the correctness of the function

print(funcImp(10))   # Expected output: 5 (prime factors are: [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are: [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are: [3,7])
print(funcImp(100))   # Expected output: 5 (prime factors are: [2,5])
```",21,7,7,PASS,TRUE,N/A
19,4,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function calculates the largest prime factor of a given number.
    It first checks if the number is even and divides it by 2 until it becomes odd.
    Then, it starts checking for factors from 3 up to square root of n. If a factor is found, 
    it divides the number by that factor until it can't be divided anymore.
    The last remaining value of n will be the largest prime factor.
    """"""
    
    # Check if n is even and divide by 2 until it becomes odd
    while n % 2 == 0:
        max_prime = 2
        n /= 2
    
    # Start checking for factors from 3 up to sqrt(n)
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n /= i
    
    # If n is still greater than 2, then it must be a prime number itself
    if n > 2:
        max_prime = n

    return max_prime


# Test cases to verify the correctness of the function

print(funcImp(10))   # Expected output: 5 (prime factors are: [2,5])
print(funcImp(15))   # Expected output: 5 (prime factors are: [3,5])
print(funcImp(21))   # Expected output: 7 (prime factors are: [3,7])
print(funcImp(100))   # Expected output: 5 (prime factors are: [2,5])
```",100,5,5,PASS,TRUE,N/A
20,1,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is semiprime.
    A semiprime number is the product of exactly two prime numbers (which may be the same).
    """"""

    def is_prime(num):
        """"""
        This nested function checks if a given number is prime.
        A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.
        """"""
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    # Check for each integer i from 2 to sqrt(n)
    for i in range(2, int(n**0.5) + 1):

        # If i divides n and both are primes
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True

    # If no such pair of primes found, then it's not a semiprime
    return False


# Test cases to validate the solution

assert(funcImp(6))     # True, because 6 = 2 * 3 (both are primes)
assert(funcImp(49))    # True, because 49 = 7 * 7 (both are primes)
assert(not funcImp(8)) # False, because although 8 = 2 * 4, but only one of them (i.e., '2') is prime
assert(not funcImp(1)) # False, because '1' can't be expressed as product of two primes
```",6,TRUE,TRUE,PASS,TRUE,N/A
20,2,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is semiprime.
    A semiprime number is the product of exactly two prime numbers (which may be the same).
    """"""

    def is_prime(num):
        """"""
        This nested function checks if a given number is prime.
        A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.
        """"""
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    # Check for each integer i from 2 to sqrt(n)
    for i in range(2, int(n**0.5) + 1):

        # If i divides n and both are primes
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True

    # If no such pair of primes found, then it's not a semiprime
    return False


# Test cases to validate the solution

assert(funcImp(6))     # True, because 6 = 2 * 3 (both are primes)
assert(funcImp(49))    # True, because 49 = 7 * 7 (both are primes)
assert(not funcImp(8)) # False, because although 8 = 2 * 4, but only one of them (i.e., '2') is prime
assert(not funcImp(1)) # False, because '1' can't be expressed as product of two primes
```",49,TRUE,TRUE,PASS,TRUE,N/A
20,3,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is semiprime.
    A semiprime number is the product of exactly two prime numbers (which may be the same).
    """"""

    def is_prime(num):
        """"""
        This nested function checks if a given number is prime.
        A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.
        """"""
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    # Check for each integer i from 2 to sqrt(n)
    for i in range(2, int(n**0.5) + 1):

        # If i divides n and both are primes
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True

    # If no such pair of primes found, then it's not a semiprime
    return False


# Test cases to validate the solution

assert(funcImp(6))     # True, because 6 = 2 * 3 (both are primes)
assert(funcImp(49))    # True, because 49 = 7 * 7 (both are primes)
assert(not funcImp(8)) # False, because although 8 = 2 * 4, but only one of them (i.e., '2') is prime
assert(not funcImp(1)) # False, because '1' can't be expressed as product of two primes
```",8,FALSE,FALSE,PASS,TRUE,N/A
20,4,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    This function checks if a given number is semiprime.
    A semiprime number is the product of exactly two prime numbers (which may be the same).
    """"""

    def is_prime(num):
        """"""
        This nested function checks if a given number is prime.
        A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.
        """"""
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    # Check for each integer i from 2 to sqrt(n)
    for i in range(2, int(n**0.5) + 1):

        # If i divides n and both are primes
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True

    # If no such pair of primes found, then it's not a semiprime
    return False


# Test cases to validate the solution

assert(funcImp(6))     # True, because 6 = 2 * 3 (both are primes)
assert(funcImp(49))    # True, because 49 = 7 * 7 (both are primes)
assert(not funcImp(8)) # False, because although 8 = 2 * 4, but only one of them (i.e., '2') is prime
assert(not funcImp(1)) # False, because '1' can't be expressed as product of two primes
```",1,FALSE,FALSE,PASS,TRUE,N/A
21,1,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def bubble_sort(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    
    Parameters:
    arr (list): The list of integers to be sorted.

    Returns:
    arr (list): The sorted list of integers.
    """"""
    
    # Traverse through all array elements
    for i in range(len(arr)):
        # Last i elements are already in place
        for j in range(0, len(arr) - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
                
    return arr

# Test cases to verify the function
arr = [64, 34, 25, 12, 22, 11, 90]

start_time = time.time()
print(""Sorted array is:"", bubble_sort(arr))
end_time = time.time()

print(""Time complexity of Bubble Sort is: %s seconds"" % (end_time - start_time))
```","[64, 34, 25, 12, 22, 11, 90]","[11, 12, 22, 25, 34, 64, 90]","[11, 12, 22, 25, 34, 64, 90]",PASS,TRUE,N/A
21,2,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def bubble_sort(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    
    Parameters:
    arr (list): The list of integers to be sorted.

    Returns:
    arr (list): The sorted list of integers.
    """"""
    
    # Traverse through all array elements
    for i in range(len(arr)):
        # Last i elements are already in place
        for j in range(0, len(arr) - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
                
    return arr

# Test cases to verify the function
arr = [64, 34, 25, 12, 22, 11, 90]

start_time = time.time()
print(""Sorted array is:"", bubble_sort(arr))
end_time = time.time()

print(""Time complexity of Bubble Sort is: %s seconds"" % (end_time - start_time))
```","[9, 8, 7, 6, 5, 4, 3]","[3, 4, 5, 6, 7, 8, 9]","[3, 4, 5, 6, 7, 8, 9]",PASS,TRUE,N/A
21,3,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def bubble_sort(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    
    Parameters:
    arr (list): The list of integers to be sorted.

    Returns:
    arr (list): The sorted list of integers.
    """"""
    
    # Traverse through all array elements
    for i in range(len(arr)):
        # Last i elements are already in place
        for j in range(0, len(arr) - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
                
    return arr

# Test cases to verify the function
arr = [64, 34, 25, 12, 22, 11, 90]

start_time = time.time()
print(""Sorted array is:"", bubble_sort(arr))
end_time = time.time()

print(""Time complexity of Bubble Sort is: %s seconds"" % (end_time - start_time))
```","[15, 19, 70, 85, 34, 29, 48]","[15, 19, 29, 34, 48, 70, 85]","[15, 19, 29, 34, 48, 70, 85]",PASS,TRUE,N/A
22,1,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def insertion_sort(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
 
        key = arr[i]
 
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i-1
        while j >=0 and key < arr[j] :
                arr[j+1] = arr[j]
                j -= 1
        arr[j+1] = key
    
    return arr


# Test the function with some test cases

arr = [12, 11, 13, 5, 6]
print(""Original array is:"", arr)
start_time = time.time()
sorted_arr = insertion_sort(arr)
end_time = time.time()
print(""Sorted array is:"", sorted_arr)

# Calculate the average case time complexity
time_diff = end_time - start_time
print(""Average case time complexity for this input is: "", time_diff)
```","[12, 11, 13, 5, 6]","[5, 6, 11, 12, 13]","[5, 6, 11, 12, 13]",PASS,TRUE,N/A
22,2,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def insertion_sort(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
 
        key = arr[i]
 
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i-1
        while j >=0 and key < arr[j] :
                arr[j+1] = arr[j]
                j -= 1
        arr[j+1] = key
    
    return arr


# Test the function with some test cases

arr = [12, 11, 13, 5, 6]
print(""Original array is:"", arr)
start_time = time.time()
sorted_arr = insertion_sort(arr)
end_time = time.time()
print(""Sorted array is:"", sorted_arr)

# Calculate the average case time complexity
time_diff = end_time - start_time
print(""Average case time complexity for this input is: "", time_diff)
```","[64, 34, 25, 12, 22, 11, 90]","[11, 12, 22, 25, 34, 64, 90]","[11, 12, 22, 25, 34, 64, 90]",PASS,TRUE,N/A
22,3,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def insertion_sort(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
 
        key = arr[i]
 
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i-1
        while j >=0 and key < arr[j] :
                arr[j+1] = arr[j]
                j -= 1
        arr[j+1] = key
    
    return arr


# Test the function with some test cases

arr = [12, 11, 13, 5, 6]
print(""Original array is:"", arr)
start_time = time.time()
sorted_arr = insertion_sort(arr)
end_time = time.time()
print(""Sorted array is:"", sorted_arr)

# Calculate the average case time complexity
time_diff = end_time - start_time
print(""Average case time complexity for this input is: "", time_diff)
```","[9, 8, 7, 6, 5, 4, 3]","[3, 4, 5, 6, 7, 8, 9]","[3, 4, 5, 6, 7, 8, 9]",PASS,TRUE,N/A
22,4,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def insertion_sort(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
 
        key = arr[i]
 
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i-1
        while j >=0 and key < arr[j] :
                arr[j+1] = arr[j]
                j -= 1
        arr[j+1] = key
    
    return arr


# Test the function with some test cases

arr = [12, 11, 13, 5, 6]
print(""Original array is:"", arr)
start_time = time.time()
sorted_arr = insertion_sort(arr)
end_time = time.time()
print(""Sorted array is:"", sorted_arr)

# Calculate the average case time complexity
time_diff = end_time - start_time
print(""Average case time complexity for this input is: "", time_diff)
```","[15, 19, 70, 85, 34, 29, 48]","[15, 19, 29, 34, 48, 70, 85]","[15, 19, 29, 34, 48, 70, 85]",PASS,TRUE,N/A
23,1,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function takes an array of strings as input and returns the array sorted in lexicographical order.
    
    Parameters:
    arr (list): A list of strings

    Returns:
    list: The input list sorted in lexicographical order
    """"""
    
    # Use the built-in sorted() function to sort the array
    return sorted(arr)

# Test cases to verify the functionality of funcImp()

print(funcImp([""apple"", ""banana"", ""cherry""]))  # Expected output: ['apple', 'banana', 'cherry']
print(funcImp([""dog"", ""cat"", ""bird""]))  # Expected output: ['bird', 'cat', 'dog']
print(funcImp([""123"", ""456"", ""789""]))  # Expected output: ['123', '456', '789']
print(funcImp([""$"", ""%"", ""&""]))  # Expected output: ['$', '&', '%']
print(funcImp([]))  # Expected output: []
```","['apple', 'banana', 'cherry']","['apple', 'banana', 'cherry']","['apple', 'banana', 'cherry']",PASS,TRUE,N/A
23,2,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function takes an array of strings as input and returns the array sorted in lexicographical order.
    
    Parameters:
    arr (list): A list of strings

    Returns:
    list: The input list sorted in lexicographical order
    """"""
    
    # Use the built-in sorted() function to sort the array
    return sorted(arr)

# Test cases to verify the functionality of funcImp()

print(funcImp([""apple"", ""banana"", ""cherry""]))  # Expected output: ['apple', 'banana', 'cherry']
print(funcImp([""dog"", ""cat"", ""bird""]))  # Expected output: ['bird', 'cat', 'dog']
print(funcImp([""123"", ""456"", ""789""]))  # Expected output: ['123', '456', '789']
print(funcImp([""$"", ""%"", ""&""]))  # Expected output: ['$', '&', '%']
print(funcImp([]))  # Expected output: []
```","['dog', 'cat', 'bird']","['bird', 'cat', 'dog']","['bird', 'cat', 'dog']",PASS,TRUE,N/A
23,3,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function takes an array of strings as input and returns the array sorted in lexicographical order.
    
    Parameters:
    arr (list): A list of strings

    Returns:
    list: The input list sorted in lexicographical order
    """"""
    
    # Use the built-in sorted() function to sort the array
    return sorted(arr)

# Test cases to verify the functionality of funcImp()

print(funcImp([""apple"", ""banana"", ""cherry""]))  # Expected output: ['apple', 'banana', 'cherry']
print(funcImp([""dog"", ""cat"", ""bird""]))  # Expected output: ['bird', 'cat', 'dog']
print(funcImp([""123"", ""456"", ""789""]))  # Expected output: ['123', '456', '789']
print(funcImp([""$"", ""%"", ""&""]))  # Expected output: ['$', '&', '%']
print(funcImp([]))  # Expected output: []
```","['123', '456', '789']","['123', '456', '789']","['123', '456', '789']",PASS,TRUE,N/A
23,4,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function takes an array of strings as input and returns the array sorted in lexicographical order.
    
    Parameters:
    arr (list): A list of strings

    Returns:
    list: The input list sorted in lexicographical order
    """"""
    
    # Use the built-in sorted() function to sort the array
    return sorted(arr)

# Test cases to verify the functionality of funcImp()

print(funcImp([""apple"", ""banana"", ""cherry""]))  # Expected output: ['apple', 'banana', 'cherry']
print(funcImp([""dog"", ""cat"", ""bird""]))  # Expected output: ['bird', 'cat', 'dog']
print(funcImp([""123"", ""456"", ""789""]))  # Expected output: ['123', '456', '789']
print(funcImp([""$"", ""%"", ""&""]))  # Expected output: ['$', '&', '%']
print(funcImp([]))  # Expected output: []
```","['$', '%', '&']","['$', '&', '%']","['$', '%', '&']",FAIL,FALSE,N/A
23,5,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function takes an array of strings as input and returns the array sorted in lexicographical order.
    
    Parameters:
    arr (list): A list of strings

    Returns:
    list: The input list sorted in lexicographical order
    """"""
    
    # Use the built-in sorted() function to sort the array
    return sorted(arr)

# Test cases to verify the functionality of funcImp()

print(funcImp([""apple"", ""banana"", ""cherry""]))  # Expected output: ['apple', 'banana', 'cherry']
print(funcImp([""dog"", ""cat"", ""bird""]))  # Expected output: ['bird', 'cat', 'dog']
print(funcImp([""123"", ""456"", ""789""]))  # Expected output: ['123', '456', '789']
print(funcImp([""$"", ""%"", ""&""]))  # Expected output: ['$', '&', '%']
print(funcImp([]))  # Expected output: []
```",[],[],[],PASS,TRUE,N/A
24,1,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def selection_sort(arr):
    """"""
    This function implements the Selection Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
                
        # Swap the found minimum element with the first element of unsorted array       
        arr[i], arr[min_index] = arr[min_index], arr[i]
        
    return arr

# Testing the function
print(selection_sort([64, 25, 12, 22, 11]))  # Output: [11, 12, 22, 25, 64]
```","[64, 25, 12, 22, 11]","[11, 12, 22, 25, 64]","[11, 12, 22, 25, 64]",PASS,TRUE,N/A
24,2,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def selection_sort(arr):
    """"""
    This function implements the Selection Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
                
        # Swap the found minimum element with the first element of unsorted array       
        arr[i], arr[min_index] = arr[min_index], arr[i]
        
    return arr

# Testing the function
print(selection_sort([64, 25, 12, 22, 11]))  # Output: [11, 12, 22, 25, 64]
```","[12, 11, 13, 5, 6]","[5, 6, 11, 12, 13]","[5, 6, 11, 12, 13]",PASS,TRUE,N/A
24,3,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def selection_sort(arr):
    """"""
    This function implements the Selection Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
                
        # Swap the found minimum element with the first element of unsorted array       
        arr[i], arr[min_index] = arr[min_index], arr[i]
        
    return arr

# Testing the function
print(selection_sort([64, 25, 12, 22, 11]))  # Output: [11, 12, 22, 25, 64]
```","[64, 34, 25, 12, 22, 11, 90]","[11, 12, 22, 25, 34, 64, 90]","[11, 12, 22, 25, 34, 64, 90]",PASS,TRUE,N/A
24,4,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def selection_sort(arr):
    """"""
    This function implements the Selection Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
                
        # Swap the found minimum element with the first element of unsorted array       
        arr[i], arr[min_index] = arr[min_index], arr[i]
        
    return arr

# Testing the function
print(selection_sort([64, 25, 12, 22, 11]))  # Output: [11, 12, 22, 25, 64]
```","[9, 8, 7, 6, 5, 4, 3]","[3, 4, 5, 6, 7, 8, 9]","[3, 4, 5, 6, 7, 8, 9]",PASS,TRUE,N/A
24,5,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def selection_sort(arr):
    """"""
    This function implements the Selection Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    """"""
    
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
                
        # Swap the found minimum element with the first element of unsorted array       
        arr[i], arr[min_index] = arr[min_index], arr[i]
        
    return arr

# Testing the function
print(selection_sort([64, 25, 12, 22, 11]))  # Output: [11, 12, 22, 25, 64]
```","[15, 19, 70, 85, 34, 29, 48]","[15, 19, 29, 34, 48, 70, 85]","[15, 19, 29, 34, 48, 70, 85]",PASS,TRUE,N/A
25,1,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Node class
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Linked List class
class LinkedList:
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Function to print nodes in a given linked list 
    def printList(self, head):
        temp = head
        while temp:
            print(temp.data, end="" "")
            temp = temp.next

    # Function that uses merge sort algorithm to sort the linked list 
    def mergeSort(self, h):

        # Base case if head is None
        if h == None or h.next == None:
            return h

        # get the middle of the list 
        middle = self.getMiddle(h)
        nexttomiddle = middle.next

        # set the next of middle node to None 
        middle.next = None

        # Apply mergeSort on left list  
        left = self.mergeSort(h)

        # Apply mergeSort on right list 
        right = self.mergeSort(nexttomiddle)

         # Merge the left and right lists  
         sortedlist = self.sortedMerge(left, right)

         return sortedlist
    
     # Function to get the middle of  
     # the linked list 
     def getMiddle(self, head):
         if (head == None):
             return head
 
         slow = head
         fast = head
 
         while (fast.next != None and fast.next.next != None):
             slow = slow.next
             fast = fast.next.next
 
         return slow

     # Function to merge two sorted linked list. 
     def sortedMerge(self, a, b):
         result = None
 
         # Base cases 
         if a == None:
             return b
         if b == None:
             return a
 
         # pick either a or b and recur.. 
         if a.data <= b.data:
             result = a
             result.next = self.sortedMerge(a.next, b)
         else:
             result = b
             result.next = self.sortedMerge(a, b.next)
 
         return result

# Test the function with some test cases
llist = LinkedList()

# Inserting elements to the linked list
llist.push(15)
llist.push(10)
llist.push(5)
llist.push(20)
llist.push(3)
llist.push(2)

# Apply merge sort 
llist.head = llist.mergeSort(llist.head)

print (""Sorted Linked List is:"")
llist.printList(llist.head) 

```","[15, 10, 5, 20, 3, 2]","[2, 3, 5, 10, 15, 20]","[2, 3, 5, 10, 15, 20]",PASS,TRUE,N/A
26,1,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def counting_sort(arr, exp1):
    n = len(arr)
    output = [0] * (n)
    count = [0] * (10)

    # Store count of occurrences in count[]
    for i in range(0, n):
        index = (arr[i] // exp1)
        count[(index) % 10] += 1

    # Change count[i] so that count[i] now contains
    # actual position of this digit in output array
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build the output array
    i = n - 1
    while i >= 0:
        index = (arr[i] // exp1)
        output[count[(index) % 10] - 1] = arr[i]
        count[(index) % 10] -= 1
        i -= 1

    # Copying the output array to arr[],
    # so that arr now contains sorted numbers
    for i in range(0, len(arr)):
        arr[i] = output[i]


# Method to do Radix Sort
def radixsort(arr):
    
   # Find maximum number to know number of digits
   max1 = max(arr)

   # Do counting sort for every digit. Note that instead of passing digit number,
   # exp is passed. exp is 10^i where i is current digit number.
   exp = 1
   while max1 / exp > 0:
       counting_sort(arr, exp)
       exp *= 10


# Test the function with some test cases

data_list = [121,432,564,23,1,45,788]
print(""Original List: "",data_list)
radixsort(data_list)
print(""Sorted List: "",data_list)

```","[121,432,564,23,1,45,788]","[1, 23, 45, 121, 432, 564, 788]","[1, 23, 45, 121, 432, 564, 788]",PASS,TRUE,N/A
26,2,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def counting_sort(arr, exp1):
    n = len(arr)
    output = [0] * (n)
    count = [0] * (10)

    # Store count of occurrences in count[]
    for i in range(0, n):
        index = (arr[i] // exp1)
        count[(index) % 10] += 1

    # Change count[i] so that count[i] now contains
    # actual position of this digit in output array
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build the output array
    i = n - 1
    while i >= 0:
        index = (arr[i] // exp1)
        output[count[(index) % 10] - 1] = arr[i]
        count[(index) % 10] -= 1
        i -= 1

    # Copying the output array to arr[],
    # so that arr now contains sorted numbers
    for i in range(0, len(arr)):
        arr[i] = output[i]


# Method to do Radix Sort
def radixsort(arr):
    
   # Find maximum number to know number of digits
   max1 = max(arr)

   # Do counting sort for every digit. Note that instead of passing digit number,
   # exp is passed. exp is 10^i where i is current digit number.
   exp = 1
   while max1 / exp > 0:
       counting_sort(arr, exp)
       exp *= 10


# Test the function with some test cases

data_list = [121,432,564,23,1,45,788]
print(""Original List: "",data_list)
radixsort(data_list)
print(""Sorted List: "",data_list)

```","[64, 25, 12, 22, 11]","[11, 12, 22, 25, 64]","[11, 12, 22, 25, 64]",PASS,TRUE,N/A
26,3,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def counting_sort(arr, exp1):
    n = len(arr)
    output = [0] * (n)
    count = [0] * (10)

    # Store count of occurrences in count[]
    for i in range(0, n):
        index = (arr[i] // exp1)
        count[(index) % 10] += 1

    # Change count[i] so that count[i] now contains
    # actual position of this digit in output array
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build the output array
    i = n - 1
    while i >= 0:
        index = (arr[i] // exp1)
        output[count[(index) % 10] - 1] = arr[i]
        count[(index) % 10] -= 1
        i -= 1

    # Copying the output array to arr[],
    # so that arr now contains sorted numbers
    for i in range(0, len(arr)):
        arr[i] = output[i]


# Method to do Radix Sort
def radixsort(arr):
    
   # Find maximum number to know number of digits
   max1 = max(arr)

   # Do counting sort for every digit. Note that instead of passing digit number,
   # exp is passed. exp is 10^i where i is current digit number.
   exp = 1
   while max1 / exp > 0:
       counting_sort(arr, exp)
       exp *= 10


# Test the function with some test cases

data_list = [121,432,564,23,1,45,788]
print(""Original List: "",data_list)
radixsort(data_list)
print(""Sorted List: "",data_list)

```","[12, 11, 13, 5, 6]","[5, 6, 11, 12, 13]","[5, 6, 11, 12, 13]",PASS,TRUE,N/A
27,1,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def counting_sort(arr):
    """"""
    This function implements the counting sort algorithm, which is efficient for sorting arrays with many duplicate elements.
    It first finds the maximum element in the array to determine the range of counts.
    Then it initializes a count array of zeros with length equal to this maximum plus one.
    It then iterates over the input array, incrementing the count for each element.
    Finally, it constructs the sorted output array by iterating over the count array and adding indices (representing elements from 
    the input array) times their counts.
    """"""
    
    # Find maximum element in arr[]
    max_val = max(arr)
  
    # Initialize count array with all zeros
    count = [0 for _ in range(max_val+1)]
  
    # Store count of each character
    for num in arr:
        count[num] += 1
  
    # Change count[i] so that count[i] now contains actual position of this character in output array
    i = 0
    for j in range(max_val+1):
        for k in range(count[j]):
            arr[i] = j
            i += 1

# Test cases to verify correctness of function

arr = [4, 2, 2, 8, 3, 3, 1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = [9, 8, 7, 6, 5, 4, 3, 2 ,1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = [1, 1, 1, 1, 1, 1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = []
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)
```","[4, 2, 2, 8, 3, 3, 1]","[1, 2, 2, 3, 3, 4, 8]","[1, 2, 2, 3, 3, 4, 8]",PASS,TRUE,N/A
27,2,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def counting_sort(arr):
    """"""
    This function implements the counting sort algorithm, which is efficient for sorting arrays with many duplicate elements.
    It first finds the maximum element in the array to determine the range of counts.
    Then it initializes a count array of zeros with length equal to this maximum plus one.
    It then iterates over the input array, incrementing the count for each element.
    Finally, it constructs the sorted output array by iterating over the count array and adding indices (representing elements from 
    the input array) times their counts.
    """"""
    
    # Find maximum element in arr[]
    max_val = max(arr)
  
    # Initialize count array with all zeros
    count = [0 for _ in range(max_val+1)]
  
    # Store count of each character
    for num in arr:
        count[num] += 1
  
    # Change count[i] so that count[i] now contains actual position of this character in output array
    i = 0
    for j in range(max_val+1):
        for k in range(count[j]):
            arr[i] = j
            i += 1

# Test cases to verify correctness of function

arr = [4, 2, 2, 8, 3, 3, 1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = [9, 8, 7, 6, 5, 4, 3, 2 ,1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = [1, 1, 1, 1, 1, 1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = []
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)
```","[9, 8, 7, 6, 5, 4, 3 ,2 ,1]","[1, 2, 3, 4, 5, 6, 7, 8, 9]","[1, 2, 3, 4, 5, 6, 7, 8, 9]",PASS,TRUE,N/A
27,3,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def counting_sort(arr):
    """"""
    This function implements the counting sort algorithm, which is efficient for sorting arrays with many duplicate elements.
    It first finds the maximum element in the array to determine the range of counts.
    Then it initializes a count array of zeros with length equal to this maximum plus one.
    It then iterates over the input array, incrementing the count for each element.
    Finally, it constructs the sorted output array by iterating over the count array and adding indices (representing elements from 
    the input array) times their counts.
    """"""
    
    # Find maximum element in arr[]
    max_val = max(arr)
  
    # Initialize count array with all zeros
    count = [0 for _ in range(max_val+1)]
  
    # Store count of each character
    for num in arr:
        count[num] += 1
  
    # Change count[i] so that count[i] now contains actual position of this character in output array
    i = 0
    for j in range(max_val+1):
        for k in range(count[j]):
            arr[i] = j
            i += 1

# Test cases to verify correctness of function

arr = [4, 2, 2, 8, 3, 3, 1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = [9, 8, 7, 6, 5, 4, 3, 2 ,1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = [1, 1, 1, 1, 1, 1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = []
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)
```","[1, 1, 1, 1]","[1, 1, 1, 1]","[1, 1, 1, 1]",PASS,TRUE,N/A
27,4,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def counting_sort(arr):
    """"""
    This function implements the counting sort algorithm, which is efficient for sorting arrays with many duplicate elements.
    It first finds the maximum element in the array to determine the range of counts.
    Then it initializes a count array of zeros with length equal to this maximum plus one.
    It then iterates over the input array, incrementing the count for each element.
    Finally, it constructs the sorted output array by iterating over the count array and adding indices (representing elements from 
    the input array) times their counts.
    """"""
    
    # Find maximum element in arr[]
    max_val = max(arr)
  
    # Initialize count array with all zeros
    count = [0 for _ in range(max_val+1)]
  
    # Store count of each character
    for num in arr:
        count[num] += 1
  
    # Change count[i] so that count[i] now contains actual position of this character in output array
    i = 0
    for j in range(max_val+1):
        for k in range(count[j]):
            arr[i] = j
            i += 1

# Test cases to verify correctness of function

arr = [4, 2, 2, 8, 3, 3, 1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = [9, 8, 7, 6, 5, 4, 3, 2 ,1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = [1, 1, 1, 1, 1, 1]
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)

arr = []
print(""Original Array: "", arr)
counting_sort(arr)
print(""Sorted Array: "", arr)
```",[],[],[],PASS,TRUE,N/A
28,1,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2
 
    if l < n and arr[i] < arr[l]:
        largest = l
 
    if r < n and arr[largest] < arr[r]:
        largest = r
 
    if largest != i:
        arr[i],arr[largest] = arr[largest],arr[i]  
 
        heapify(arr, n, largest)
 
def heapSort(arr):
    n = len(arr)
 
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)
 
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# Test the function with some test cases
arr = [12,11,-13,-5,-6]
heapSort(arr)
print (""Sorted array is"", str(arr))

# Time complexity evaluation
start_time = time.time()
heapSort([i for i in range(10000)])
print(""Best case scenario took %s seconds"" % (time.time() - start_time))

start_time = time.time()
heapSort([i for i in range(10000)][::-1])
print(""Worst case scenario took %s seconds"" % (time.time() - start_time))
```","[12,11,-13,-5,-6]","[-13, -6, -5, 11, 12]","[-13, -6, -5, 11, 12]",PASS,TRUE,N/A
28,2,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2
 
    if l < n and arr[i] < arr[l]:
        largest = l
 
    if r < n and arr[largest] < arr[r]:
        largest = r
 
    if largest != i:
        arr[i],arr[largest] = arr[largest],arr[i]  
 
        heapify(arr, n, largest)
 
def heapSort(arr):
    n = len(arr)
 
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)
 
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# Test the function with some test cases
arr = [12,11,-13,-5,-6]
heapSort(arr)
print (""Sorted array is"", str(arr))

# Time complexity evaluation
start_time = time.time()
heapSort([i for i in range(10000)])
print(""Best case scenario took %s seconds"" % (time.time() - start_time))

start_time = time.time()
heapSort([i for i in range(10000)][::-1])
print(""Worst case scenario took %s seconds"" % (time.time() - start_time))
```","[9, 8, 7, 6, 5, 4, 3]","[3, 4, 5, 6, 7, 8, 9]","[3, 4, 5, 6, 7, 8, 9]",PASS,TRUE,N/A
28,3,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import time

def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2
 
    if l < n and arr[i] < arr[l]:
        largest = l
 
    if r < n and arr[largest] < arr[r]:
        largest = r
 
    if largest != i:
        arr[i],arr[largest] = arr[largest],arr[i]  
 
        heapify(arr, n, largest)
 
def heapSort(arr):
    n = len(arr)
 
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)
 
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# Test the function with some test cases
arr = [12,11,-13,-5,-6]
heapSort(arr)
print (""Sorted array is"", str(arr))

# Time complexity evaluation
start_time = time.time()
heapSort([i for i in range(10000)])
print(""Best case scenario took %s seconds"" % (time.time() - start_time))

start_time = time.time()
heapSort([i for i in range(10000)][::-1])
print(""Worst case scenario took %s seconds"" % (time.time() - start_time))
```","[15, 19, -70, -85, 34, 29, 48]","[-85, -70, 15, 19, 29, 34, 48]","[-70, -85, 15, 19, 29, 34, 48]",FAIL,FALSE,N/A
29,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def shortest_path(graph, start, end):
    """"""
    This function finds the shortest path in the graph using BFS strategy
    :param graph: adjacency list of the graph
    :param start: starting node
    :param end: ending node
    :return: shortest path from start to end node
    """"""
    
    # Create a queue for BFS and enqueue the first path into it
    queue = deque([[start]])
    
    while queue:
        # Get the first path from the queue
        path = queue.popleft()
        
        # Get the last node from this path
        node = path[-1]
        
        # Path found 
        if node == end:
            return path
        
        # Enumerate all adjacent nodes, construct a new path and push it into the queue
        for adjacent in graph.get(node, []):
            new_path = list(path)
            new_path.append(adjacent)
            queue.append(new_path)

# Test case:
graph = {'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}
print(shortest_path(graph, 'A', 'F'))  # Output: ['A', 'C', 'F']
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'F')","['A', 'C', 'F']","['A', 'C', 'F']",PASS,TRUE,N/A
30,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_cyclic(n, adj_list):
    """"""
    Function to check if a directed graph contains a cycle using depth-first search.
    :param n: Number of vertices in the graph.
    :param adj_list: Adjacency list representing the graph.
    :return: True if there is a cycle, False otherwise.
    """"""
    
    # Create visited and recursion stack arrays
    visited = [False] * (n + 1)
    rec_stack = [False] * (n + 1)

    # Call recursive helper function to detect cycle in different DFS trees
    for node in range(n):
        if not visited[node]:
            if dfs(node, visited, rec_stack, adj_list):
                return True

    return False


def dfs(v, visited, rec_stack, adj_list):
    """"""
    Recursive helper function for detecting cycles.
    :param v: Current vertex.
    :param visited: List of already visited vertices.
    :param rec_stack: Recursion stack of vertices.
    :param adj_list: Adjacency list representing the graph.
    :return: True if there is a cycle, False otherwise.
    """"""

     # Mark current node as visited and add it to recursion stack
     visited[v] = True
     rec_stack[v] = True

     # Check all neighbors. If any neighbor is visited and in recursion stack then graph has a cycle
     for neighbor in adj_list[v]:
         if not visited[neighbor]:
             if dfs(neighbor, visited, rec_stack, adj_list):
                 return True
         elif rec_stack[neighbor]:
             return True

     # Remove the vertex from recursion stack
     rec_stack[v] = False
     return False


# Test cases
print(is_cyclic(4, [[1], [2], [3], [0]]))  # True, there is a cycle
print(is_cyclic(3, [[1], [2], []]))  # False, no cycle in the graph
```","(4, [[1], [2], [3], [0]])",TRUE,TRUE,PASS,TRUE,N/A
30,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_cyclic(n, adj_list):
    """"""
    Function to check if a directed graph contains a cycle using depth-first search.
    :param n: Number of vertices in the graph.
    :param adj_list: Adjacency list representing the graph.
    :return: True if there is a cycle, False otherwise.
    """"""
    
    # Create visited and recursion stack arrays
    visited = [False] * (n + 1)
    rec_stack = [False] * (n + 1)

    # Call recursive helper function to detect cycle in different DFS trees
    for node in range(n):
        if not visited[node]:
            if dfs(node, visited, rec_stack, adj_list):
                return True

    return False


def dfs(v, visited, rec_stack, adj_list):
    """"""
    Recursive helper function for detecting cycles.
    :param v: Current vertex.
    :param visited: List of already visited vertices.
    :param rec_stack: Recursion stack of vertices.
    :param adj_list: Adjacency list representing the graph.
    :return: True if there is a cycle, False otherwise.
    """"""

     # Mark current node as visited and add it to recursion stack
     visited[v] = True
     rec_stack[v] = True

     # Check all neighbors. If any neighbor is visited and in recursion stack then graph has a cycle
     for neighbor in adj_list[v]:
         if not visited[neighbor]:
             if dfs(neighbor, visited, rec_stack, adj_list):
                 return True
         elif rec_stack[neighbor]:
             return True

     # Remove the vertex from recursion stack
     rec_stack[v] = False
     return False


# Test cases
print(is_cyclic(4, [[1], [2], [3], [0]]))  # True, there is a cycle
print(is_cyclic(3, [[1], [2], []]))  # False, no cycle in the graph
```","(3, [[1], [2], []])",FALSE,FALSE,PASS,TRUE,N/A
31,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import sys

def funcImp(graph, start_node):
    # Initialize the shortest paths dictionary with infinite distances for all nodes except the start node
    shortest_paths = {node: (None, sys.maxsize) for node in graph}
    shortest_paths[start_node] = (None, 0)

    # Create a set of unvisited nodes
    unvisited_nodes = set(graph)

    current_node = start_node

    while unvisited_nodes:
        # Find the nearest neighbour of the current node
        neighbours = graph[current_node]
        for neighbour, distance in neighbours.items():
            old_distance = shortest_paths[neighbour][1]
            new_distance = shortest_paths[current_node][1] + distance
            if new_distance < old_distance:
                shortest_paths[neighbour] = (current_node, new_distance)

        # Mark the current node as visited
        unvisited_nodes.remove(current_node)

        # Select the next node to visit
        candidates = {node: shortest_paths[node] for node in unvisited_nodes}
        if not candidates:
            break

        # Choose the node with the smallest distance as the next node
        current_node = min(candidates, key=lambda k: candidates[k][1])

    return shortest_paths


# Test case: A simple weighted graph with 3 nodes and positive weights.
graph = {
    'A': {'B': 1, 'C': 3},
    'B': {'A': 2, 'C': 2},
    'C': {'A': 4, 'B': 5}
}

print(funcImp(graph, 'A'))  
# Expected output: {'A': (None, 0), 'B': ('A', 1), 'C': ('B', 3)}
```","({'A': {'B': 1, 'C': 3}, 'B': {'A': 2, 'C': 2}, 'C': {'A': 4, 'B': 5}}, 'A')","{'A': (None, 0), 'B': ('A', 1), 'C': ('B', 3)}","{'A': (None, 0), 'B': ('A', 1), 'C': ('A', 3)}",FAIL,FALSE,N/A
32,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to check if a graph is connected
def funcImp(graph):
    """"""
    This function uses depth-first search to check if an undirected graph is connected.
    
    Parameters:
    graph (dict): A dictionary representing the adjacency list of the graph.

    Returns:
    bool: True if the graph is connected, False otherwise.
    """"""

    # Initialize visited list and stack for DFS
    visited = []
    stack = []

    # Choose an arbitrary node to start from
    start_node = list(graph.keys())[0]
    
    # Add the start node to the stack
    stack.append(start_node)

    while len(stack) > 0:
        # Pop a node from the stack
        node = stack.pop()

        # If this node has not been visited yet, mark it as visited and add its neighbors to the stack
        if node not in visited:
            visited.append(node)
            for neighbor in graph[node]:
                stack.append(neighbor)

     # If all nodes have been visited, then the graph is connected. Otherwise, it's not.
     return len(visited) == len(graph)


# Test cases

graph1 = {
  'A': ['B', 'C'],
  'B': ['A', 'D', 'E'],
  'C': ['A', 'F'],
  'D': ['B'],
  'E': ['B', 'F'],
  'F': ['C', 'E']
}

print(funcImp(graph1))  # Expected output: True

graph2 = {
  'A': ['B'],
  'B': ['A'],
  'C': [],
}

print(funcImp(graph2))  # Expected output: False

```","{'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}",TRUE,TRUE,PASS,TRUE,N/A
32,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to check if a graph is connected
def funcImp(graph):
    """"""
    This function uses depth-first search to check if an undirected graph is connected.
    
    Parameters:
    graph (dict): A dictionary representing the adjacency list of the graph.

    Returns:
    bool: True if the graph is connected, False otherwise.
    """"""

    # Initialize visited list and stack for DFS
    visited = []
    stack = []

    # Choose an arbitrary node to start from
    start_node = list(graph.keys())[0]
    
    # Add the start node to the stack
    stack.append(start_node)

    while len(stack) > 0:
        # Pop a node from the stack
        node = stack.pop()

        # If this node has not been visited yet, mark it as visited and add its neighbors to the stack
        if node not in visited:
            visited.append(node)
            for neighbor in graph[node]:
                stack.append(neighbor)

     # If all nodes have been visited, then the graph is connected. Otherwise, it's not.
     return len(visited) == len(graph)


# Test cases

graph1 = {
  'A': ['B', 'C'],
  'B': ['A', 'D', 'E'],
  'C': ['A', 'F'],
  'D': ['B'],
  'E': ['B', 'F'],
  'F': ['C', 'E']
}

print(funcImp(graph1))  # Expected output: True

graph2 = {
  'A': ['B'],
  'B': ['A'],
  'C': [],
}

print(funcImp(graph2))  # Expected output: False

```","{'A': ['B'], 'B': ['A'], 'C': []}",FALSE,FALSE,PASS,TRUE,N/A
33,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to perform topological sort
def funcImp(graph):
    # Create an empty list to store the sorted elements
    sorted_list = []
    
    # Create a set to store visited nodes
    visited = set()

    # Define the helper function for DFS
    def dfs(node):
        # Mark the node as visited
        visited.add(node)
        
        # Visit all the neighbors of this node that have not been visited yet
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
        
        # After visiting all the neighbors, add this node to the sorted list
        sorted_list.append(node)

    # Perform DFS from each node that has not been visited yet
    for node in graph:
        if node not in visited:
            dfs(node)

    # Reverse the list because we want to return it in descending order of finishing times
    sorted_list.reverse()
    
    return sorted_list

# Test cases to verify the function

graph1 = {
  'A': ['B', 'C'],
  'B': ['D', 'E'],
  'C': [],
  'D': [],
  'E': []
}

print(funcImp(graph1))  # Expected output: ['A', 'C', 'B', 'E', 'D']

graph2 = {
  'A': ['B'],
  'B': ['C'],
  'C': ['D'],
  'D': []
}

print(funcImp(graph2))  # Expected output: ['A', 'B', 'C', 'D']
```","{'A': ['B', 'C'], 'B': ['D', 'E'], 'C': [], 'D': [], 'E': []}","['A', 'C', 'B', 'E', 'D']","['A', 'C', 'B', 'E', 'D']",PASS,TRUE,N/A
33,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to perform topological sort
def funcImp(graph):
    # Create an empty list to store the sorted elements
    sorted_list = []
    
    # Create a set to store visited nodes
    visited = set()

    # Define the helper function for DFS
    def dfs(node):
        # Mark the node as visited
        visited.add(node)
        
        # Visit all the neighbors of this node that have not been visited yet
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
        
        # After visiting all the neighbors, add this node to the sorted list
        sorted_list.append(node)

    # Perform DFS from each node that has not been visited yet
    for node in graph:
        if node not in visited:
            dfs(node)

    # Reverse the list because we want to return it in descending order of finishing times
    sorted_list.reverse()
    
    return sorted_list

# Test cases to verify the function

graph1 = {
  'A': ['B', 'C'],
  'B': ['D', 'E'],
  'C': [],
  'D': [],
  'E': []
}

print(funcImp(graph1))  # Expected output: ['A', 'C', 'B', 'E', 'D']

graph2 = {
  'A': ['B'],
  'B': ['C'],
  'C': ['D'],
  'D': []
}

print(funcImp(graph2))  # Expected output: ['A', 'B', 'C', 'D']
```","{'A': ['B'], 'B': ['C'], 'C': ['D'], 'D': []}","['A', 'B', 'C', 'D']","['A', 'B', 'C', 'D']",PASS,TRUE,N/A
34,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to find all paths
def find_paths(graph, start, end, path=[]):
    """"""
    This function finds all possible paths between two nodes in an undirected graph using depth-first search.
    
    Parameters:
    graph (dict): The graph represented as an adjacency list.
    start (str): The starting node.
    end (str): The ending node.
    path (list): A list representing the current path. Default is an empty list.

    Returns:
    list: A list of lists where each inner list represents a possible path from start to end.
    """"""
    
    # Add the starting node to the current path
    path = path + [start]
    
    # If the starting node is the ending node, return the current path
    if start == end:
        return [path]
    
    # If the starting node is not in the graph, return an empty list
    if start not in graph:
        return []
    
    # Initialize an empty list to store all paths
    paths = []
    
    # For each neighbor of the starting node,
    for node in graph[start]:
        # If this neighbor has not been visited yet,
        if node not in path:
            # Recursively call this function with this neighbor as new starting point and add returned paths to 'paths'
            newpaths = find_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
                
     # Return all found paths           
     return paths

# Test cases

graph = {'A': ['B', 'C'],
         'B': ['A', 'D', 'E'],
         'C': ['A', 'F'],
         'D': ['B'],
         'E': ['B', 'F'],
         'F': ['C', 'E']}

print(find_paths(graph, 'A', 'F'))  # Expected output: [['A', 'B', 'E', 'F'], ['A', 'C', 'F']]
print(find_paths(graph, 'D', 'F'))  # Expected output: [['D', 'B', 'A', 'C', 'F'], ['D', 'B', 'E', 'F']]
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'F')","[['A', 'B', 'E', 'F'], ['A', 'C', 'F']]","[['A', 'B', 'E', 'F'], ['A', 'C', 'F']]",PASS,TRUE,N/A
34,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to find all paths
def find_paths(graph, start, end, path=[]):
    """"""
    This function finds all possible paths between two nodes in an undirected graph using depth-first search.
    
    Parameters:
    graph (dict): The graph represented as an adjacency list.
    start (str): The starting node.
    end (str): The ending node.
    path (list): A list representing the current path. Default is an empty list.

    Returns:
    list: A list of lists where each inner list represents a possible path from start to end.
    """"""
    
    # Add the starting node to the current path
    path = path + [start]
    
    # If the starting node is the ending node, return the current path
    if start == end:
        return [path]
    
    # If the starting node is not in the graph, return an empty list
    if start not in graph:
        return []
    
    # Initialize an empty list to store all paths
    paths = []
    
    # For each neighbor of the starting node,
    for node in graph[start]:
        # If this neighbor has not been visited yet,
        if node not in path:
            # Recursively call this function with this neighbor as new starting point and add returned paths to 'paths'
            newpaths = find_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
                
     # Return all found paths           
     return paths

# Test cases

graph = {'A': ['B', 'C'],
         'B': ['A', 'D', 'E'],
         'C': ['A', 'F'],
         'D': ['B'],
         'E': ['B', 'F'],
         'F': ['C', 'E']}

print(find_paths(graph, 'A', 'F'))  # Expected output: [['A', 'B', 'E', 'F'], ['A', 'C', 'F']]
print(find_paths(graph, 'D', 'F'))  # Expected output: [['D', 'B', 'A', 'C', 'F'], ['D', 'B', 'E', 'F']]
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'D', 'F')","[['D', 'B', 'A', 'C', 'F'], ['D', 'B', 'E', 'F']]","[['D', 'B', 'A', 'C', 'F'], ['D', 'B', 'E', 'F']]",PASS,TRUE,N/A
35,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to find cycles in an undirected graph
def findCycles(graph):
    # Initialize variables
    visited = [False] * len(graph)
    parent = [-1] * len(graph)

    # Function to perform DFS on the graph
    def dfs(v, p):
        visited[v] = True
        parent[v] = p

        for u in graph[v]:
            if not visited[u]:
                if dfs(u, v):
                    return True
            elif u != p:
                return True

        return False

    # Check each vertex for cycle
    for i in range(len(graph)):
        if not visited[i]:
            if dfs(i, -1):
                print(""Cycle detected"")
                return

    print(""No cycle detected"")

# Test the function with a simple graph
graph = [[1], [0, 2], [1, 3], [2]]
findCycles(graph)

# Test the function with a complex graph with multiple cycles
graph = [[1, 2], [0, 2], [0, 1, 3], [2]]
findCycles(graph)
```","[[1], [0, 2], [1, 3], [2]]",No cycle detected,No cycle detected,PASS,TRUE,N/A
35,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to find cycles in an undirected graph
def findCycles(graph):
    # Initialize variables
    visited = [False] * len(graph)
    parent = [-1] * len(graph)

    # Function to perform DFS on the graph
    def dfs(v, p):
        visited[v] = True
        parent[v] = p

        for u in graph[v]:
            if not visited[u]:
                if dfs(u, v):
                    return True
            elif u != p:
                return True

        return False

    # Check each vertex for cycle
    for i in range(len(graph)):
        if not visited[i]:
            if dfs(i, -1):
                print(""Cycle detected"")
                return

    print(""No cycle detected"")

# Test the function with a simple graph
graph = [[1], [0, 2], [1, 3], [2]]
findCycles(graph)

# Test the function with a complex graph with multiple cycles
graph = [[1, 2], [0, 2], [0, 1, 3], [2]]
findCycles(graph)
```","[[1, 2], [0, 2], [0, 1, 3], [2]]",Cycle detected,Cycle detected,PASS,TRUE,N/A
36,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    This function determines if there exists a path between two nodes in an undirected graph using breadth-first search.
    
    Parameters:
    graph (dict): A dictionary representing the adjacency list of the graph.
    start (str): The starting node.
    end (str): The ending node.

    Returns:
    bool: True if there is a path from start to end, False otherwise.
    """"""

    # Create a queue for BFS and enqueue the start node
    queue = deque([start])

    # Create a set to store visited nodes
    visited = set([start])

    while queue:
        # Dequeue a vertex from queue 
        vertex = queue.popleft()

        # If this adjacent node is the destination node, then return true
        if vertex == end:
            return True

        # Else, continue to do BFS
        for neighbour in graph[vertex]:
            if neighbour not in visited:
                queue.append(neighbour)
                visited.add(neighbour)

    return False


# Test cases
graph = {
  'A': ['B', 'C'],
  'B': ['A', 'D', 'E'],
  'C': ['A', 'F'],
  'D': ['B'],
  'E': ['B', 'F'],
  'F': ['C', 'E']
}

print(funcImp(graph, ""A"", ""E""))  # Expected output: True
print(funcImp(graph, ""A"", ""Z""))  # Expected output: False
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'E')",TRUE,TRUE,PASS,TRUE,N/A
36,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    This function determines if there exists a path between two nodes in an undirected graph using breadth-first search.
    
    Parameters:
    graph (dict): A dictionary representing the adjacency list of the graph.
    start (str): The starting node.
    end (str): The ending node.

    Returns:
    bool: True if there is a path from start to end, False otherwise.
    """"""

    # Create a queue for BFS and enqueue the start node
    queue = deque([start])

    # Create a set to store visited nodes
    visited = set([start])

    while queue:
        # Dequeue a vertex from queue 
        vertex = queue.popleft()

        # If this adjacent node is the destination node, then return true
        if vertex == end:
            return True

        # Else, continue to do BFS
        for neighbour in graph[vertex]:
            if neighbour not in visited:
                queue.append(neighbour)
                visited.add(neighbour)

    return False


# Test cases
graph = {
  'A': ['B', 'C'],
  'B': ['A', 'D', 'E'],
  'C': ['A', 'F'],
  'D': ['B'],
  'E': ['B', 'F'],
  'F': ['C', 'E']
}

print(funcImp(graph, ""A"", ""E""))  # Expected output: True
print(funcImp(graph, ""A"", ""Z""))  # Expected output: False
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'Z')",FALSE,FALSE,PASS,TRUE,N/A
37,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)","Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.","## Problem Statement
- Develop a Python script to solve the problem: 'Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level

def funcImp(graph):
    # Sort all the edges in non-decreasing order of their weight.
    graph = sorted(graph, key=lambda item: item[2])

    parent = [i for i in range(len(graph))]

    def find_parent(i):
        if i != parent[i]:
            parent[i] = find_parent(parent[i])
        return parent[i]

    def union(i, j):
        ri = find_parent(i)
        rj = find_parent(j)
        if ri != rj:
            parent[rj] = ri

    mst = []
    for edge in graph:
        v1, v2, weight = edge
        if find_parent(v1) != find_parent(v2):
            union(v1, v2)
            mst.append(edge)

    return mst


# Test the function with some test cases
graph = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]
print(funcImp(graph)) # Expected output: [(2, 3, 4), (0, 3, 5), (0, 1, 10)]
```","[(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]","[(2, 3, 4), (0, 3, 5), (0, 1, 10)]","[(2, 3, 4), (0, 3, 5), (0, 1, 10)]",PASS,TRUE,N/A
38,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to perform DFS on the graph
def dfs(graph, start, visited):
    # Mark the node as visited
    visited[start] = True

    # Visit all the nodes connected to this node
    for i in graph[start]:
        if visited[i] == False:
            dfs(graph, i, visited)

# Define the function to count connected components
def count_connected_components(graph):
    # Initialize a list to keep track of visited nodes
    visited = [False] * (max(graph) + 1)

    # Initialize counter for connected components
    count = 0

    # Iterate over all nodes in the graph
    for node in graph:
        if visited[node] == False:
            dfs(graph, node, visited)
            count += 1

    return count

# Test cases
graph = {0: [1,2], 1: [0], 2: [0], 3: [4], 4: [3]}
print(count_connected_components(graph))  # Output: 2

graph = {0: [1], 1: [0,2], 2: [1]}
print(count_connected_components(graph))  # Output: 1

graph = {0: [], 1: [], 2: []}
print(count_connected_components(graph))  # Output: 3
```","{0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3]}",2,2,PASS,TRUE,N/A
38,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to perform DFS on the graph
def dfs(graph, start, visited):
    # Mark the node as visited
    visited[start] = True

    # Visit all the nodes connected to this node
    for i in graph[start]:
        if visited[i] == False:
            dfs(graph, i, visited)

# Define the function to count connected components
def count_connected_components(graph):
    # Initialize a list to keep track of visited nodes
    visited = [False] * (max(graph) + 1)

    # Initialize counter for connected components
    count = 0

    # Iterate over all nodes in the graph
    for node in graph:
        if visited[node] == False:
            dfs(graph, node, visited)
            count += 1

    return count

# Test cases
graph = {0: [1,2], 1: [0], 2: [0], 3: [4], 4: [3]}
print(count_connected_components(graph))  # Output: 2

graph = {0: [1], 1: [0,2], 2: [1]}
print(count_connected_components(graph))  # Output: 1

graph = {0: [], 1: [], 2: []}
print(count_connected_components(graph))  # Output: 3
```","{0: [1], 1: [0, 2], 2: [1]}",1,1,PASS,TRUE,N/A
38,3,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to perform DFS on the graph
def dfs(graph, start, visited):
    # Mark the node as visited
    visited[start] = True

    # Visit all the nodes connected to this node
    for i in graph[start]:
        if visited[i] == False:
            dfs(graph, i, visited)

# Define the function to count connected components
def count_connected_components(graph):
    # Initialize a list to keep track of visited nodes
    visited = [False] * (max(graph) + 1)

    # Initialize counter for connected components
    count = 0

    # Iterate over all nodes in the graph
    for node in graph:
        if visited[node] == False:
            dfs(graph, node, visited)
            count += 1

    return count

# Test cases
graph = {0: [1,2], 1: [0], 2: [0], 3: [4], 4: [3]}
print(count_connected_components(graph))  # Output: 2

graph = {0: [1], 1: [0,2], 2: [1]}
print(count_connected_components(graph))  # Output: 1

graph = {0: [], 1: [], 2: []}
print(count_connected_components(graph))  # Output: 3
```","{0: [], 1: [], 2: []}",3,3,PASS,TRUE,N/A
39,1,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function takes in two parameters: arr (a sorted list of integers) and target (an integer).
    It returns the index of the target if it's found in the list, otherwise it returns -1.
    """"""
    
    # Define start and end indices
    start = 0
    end = len(arr) - 1

    while start <= end:
        # Calculate mid point
        mid = (start + end) // 2

        # If target is at mid point, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid point, move end to mid - 1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid point, move start to mid + 1
        else:
            start = mid + 1

    # If we reach here, then the element was not present in the array.
    return -1


# Test cases to validate the solution

# Test case 1: Element exists in the array
arr = [2,3,4,10,40]
target = 10
print(binary_search(arr,target))   # Expected output: 3

# Test case 2: Element does not exist in the array
arr = [2,3,4,10,40]
target = 50
print(binary_search(arr,target))   # Expected output: -1

# Test case 3: Array has only one element which is equal to target 
arr = [10]
target = 10
print(binary_search(arr,target))   # Expected output: 0

# Test case 4: Array has only one element which is not equal to target 
arr = [10]
target = 20
print(binary_search(arr,target))   # Expected output: -1

# Test case 5: Target is the first element in the array
arr = [2,3,4,10,40]
target = 2
print(binary_search(arr,target))   # Expected output: 0

# Test case 6: Target is the last element in the array
arr = [2,3,4,10,40]
target = 40
print(binary_search(arr,target))   # Expected output: 4
```","([2, 3, 4, 10, 40], 10)",3,3,PASS,TRUE,N/A
39,2,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function takes in two parameters: arr (a sorted list of integers) and target (an integer).
    It returns the index of the target if it's found in the list, otherwise it returns -1.
    """"""
    
    # Define start and end indices
    start = 0
    end = len(arr) - 1

    while start <= end:
        # Calculate mid point
        mid = (start + end) // 2

        # If target is at mid point, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid point, move end to mid - 1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid point, move start to mid + 1
        else:
            start = mid + 1

    # If we reach here, then the element was not present in the array.
    return -1


# Test cases to validate the solution

# Test case 1: Element exists in the array
arr = [2,3,4,10,40]
target = 10
print(binary_search(arr,target))   # Expected output: 3

# Test case 2: Element does not exist in the array
arr = [2,3,4,10,40]
target = 50
print(binary_search(arr,target))   # Expected output: -1

# Test case 3: Array has only one element which is equal to target 
arr = [10]
target = 10
print(binary_search(arr,target))   # Expected output: 0

# Test case 4: Array has only one element which is not equal to target 
arr = [10]
target = 20
print(binary_search(arr,target))   # Expected output: -1

# Test case 5: Target is the first element in the array
arr = [2,3,4,10,40]
target = 2
print(binary_search(arr,target))   # Expected output: 0

# Test case 6: Target is the last element in the array
arr = [2,3,4,10,40]
target = 40
print(binary_search(arr,target))   # Expected output: 4
```","([2, 3, 4, 10, 40], 50)",-1,-1,PASS,TRUE,N/A
39,3,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function takes in two parameters: arr (a sorted list of integers) and target (an integer).
    It returns the index of the target if it's found in the list, otherwise it returns -1.
    """"""
    
    # Define start and end indices
    start = 0
    end = len(arr) - 1

    while start <= end:
        # Calculate mid point
        mid = (start + end) // 2

        # If target is at mid point, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid point, move end to mid - 1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid point, move start to mid + 1
        else:
            start = mid + 1

    # If we reach here, then the element was not present in the array.
    return -1


# Test cases to validate the solution

# Test case 1: Element exists in the array
arr = [2,3,4,10,40]
target = 10
print(binary_search(arr,target))   # Expected output: 3

# Test case 2: Element does not exist in the array
arr = [2,3,4,10,40]
target = 50
print(binary_search(arr,target))   # Expected output: -1

# Test case 3: Array has only one element which is equal to target 
arr = [10]
target = 10
print(binary_search(arr,target))   # Expected output: 0

# Test case 4: Array has only one element which is not equal to target 
arr = [10]
target = 20
print(binary_search(arr,target))   # Expected output: -1

# Test case 5: Target is the first element in the array
arr = [2,3,4,10,40]
target = 2
print(binary_search(arr,target))   # Expected output: 0

# Test case 6: Target is the last element in the array
arr = [2,3,4,10,40]
target = 40
print(binary_search(arr,target))   # Expected output: 4
```","([10], 10)",0,0,PASS,TRUE,N/A
39,4,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function takes in two parameters: arr (a sorted list of integers) and target (an integer).
    It returns the index of the target if it's found in the list, otherwise it returns -1.
    """"""
    
    # Define start and end indices
    start = 0
    end = len(arr) - 1

    while start <= end:
        # Calculate mid point
        mid = (start + end) // 2

        # If target is at mid point, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid point, move end to mid - 1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid point, move start to mid + 1
        else:
            start = mid + 1

    # If we reach here, then the element was not present in the array.
    return -1


# Test cases to validate the solution

# Test case 1: Element exists in the array
arr = [2,3,4,10,40]
target = 10
print(binary_search(arr,target))   # Expected output: 3

# Test case 2: Element does not exist in the array
arr = [2,3,4,10,40]
target = 50
print(binary_search(arr,target))   # Expected output: -1

# Test case 3: Array has only one element which is equal to target 
arr = [10]
target = 10
print(binary_search(arr,target))   # Expected output: 0

# Test case 4: Array has only one element which is not equal to target 
arr = [10]
target = 20
print(binary_search(arr,target))   # Expected output: -1

# Test case 5: Target is the first element in the array
arr = [2,3,4,10,40]
target = 2
print(binary_search(arr,target))   # Expected output: 0

# Test case 6: Target is the last element in the array
arr = [2,3,4,10,40]
target = 40
print(binary_search(arr,target))   # Expected output: 4
```","([10], 20)",-1,-1,PASS,TRUE,N/A
39,5,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function takes in two parameters: arr (a sorted list of integers) and target (an integer).
    It returns the index of the target if it's found in the list, otherwise it returns -1.
    """"""
    
    # Define start and end indices
    start = 0
    end = len(arr) - 1

    while start <= end:
        # Calculate mid point
        mid = (start + end) // 2

        # If target is at mid point, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid point, move end to mid - 1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid point, move start to mid + 1
        else:
            start = mid + 1

    # If we reach here, then the element was not present in the array.
    return -1


# Test cases to validate the solution

# Test case 1: Element exists in the array
arr = [2,3,4,10,40]
target = 10
print(binary_search(arr,target))   # Expected output: 3

# Test case 2: Element does not exist in the array
arr = [2,3,4,10,40]
target = 50
print(binary_search(arr,target))   # Expected output: -1

# Test case 3: Array has only one element which is equal to target 
arr = [10]
target = 10
print(binary_search(arr,target))   # Expected output: 0

# Test case 4: Array has only one element which is not equal to target 
arr = [10]
target = 20
print(binary_search(arr,target))   # Expected output: -1

# Test case 5: Target is the first element in the array
arr = [2,3,4,10,40]
target = 2
print(binary_search(arr,target))   # Expected output: 0

# Test case 6: Target is the last element in the array
arr = [2,3,4,10,40]
target = 40
print(binary_search(arr,target))   # Expected output: 4
```","([2, 3, 4, 10, 40], 2)",0,0,PASS,TRUE,N/A
39,6,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function takes in two parameters: arr (a sorted list of integers) and target (an integer).
    It returns the index of the target if it's found in the list, otherwise it returns -1.
    """"""
    
    # Define start and end indices
    start = 0
    end = len(arr) - 1

    while start <= end:
        # Calculate mid point
        mid = (start + end) // 2

        # If target is at mid point, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid point, move end to mid - 1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid point, move start to mid + 1
        else:
            start = mid + 1

    # If we reach here, then the element was not present in the array.
    return -1


# Test cases to validate the solution

# Test case 1: Element exists in the array
arr = [2,3,4,10,40]
target = 10
print(binary_search(arr,target))   # Expected output: 3

# Test case 2: Element does not exist in the array
arr = [2,3,4,10,40]
target = 50
print(binary_search(arr,target))   # Expected output: -1

# Test case 3: Array has only one element which is equal to target 
arr = [10]
target = 10
print(binary_search(arr,target))   # Expected output: 0

# Test case 4: Array has only one element which is not equal to target 
arr = [10]
target = 20
print(binary_search(arr,target))   # Expected output: -1

# Test case 5: Target is the first element in the array
arr = [2,3,4,10,40]
target = 2
print(binary_search(arr,target))   # Expected output: 0

# Test case 6: Target is the last element in the array
arr = [2,3,4,10,40]
target = 40
print(binary_search(arr,target))   # Expected output: 4
```","([2, 3, 4, 10, 40], 40)",4,4,PASS,TRUE,N/A
40,1,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function uses binary search to find the first occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): A sorted list of integers.
    target (int): The target integer to find.

    Returns:
    int: The index of the first occurrence of the target element. If not found, returns -1.
    """"""
    
    # Initialize left and right pointers
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2

        # Check if mid element is less than target. If yes, ignore left half
        if arr[mid] < target:
            left = mid + 1

        # If arr[mid] is greater or equal, then the required element can either be in the left half or at mid
        else:
            right = mid - 1

    # If we reach here, then the element was not present
    return left if left < len(arr) and arr[left] == target else -1


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of target
assert(funcImp([1,2,3,4,5,5,5,6], 5) == 4)

# Test case 2: Normal case with single occurrence of target
assert(funcImp([1,2,3,4,5], 3) == 2)

# Test case 3: Edge case where array does not contain target
assert(funcImp([1,2,3], 4) == -1)

# Test case 4: Edge case where array is empty
assert(funcImp([], 1) == -1)

print(""All test cases passed!"")
```","([1, 2, 3, 4, 5, 5, 5, 6], 5)",4,4,PASS,TRUE,N/A
40,2,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function uses binary search to find the first occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): A sorted list of integers.
    target (int): The target integer to find.

    Returns:
    int: The index of the first occurrence of the target element. If not found, returns -1.
    """"""
    
    # Initialize left and right pointers
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2

        # Check if mid element is less than target. If yes, ignore left half
        if arr[mid] < target:
            left = mid + 1

        # If arr[mid] is greater or equal, then the required element can either be in the left half or at mid
        else:
            right = mid - 1

    # If we reach here, then the element was not present
    return left if left < len(arr) and arr[left] == target else -1


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of target
assert(funcImp([1,2,3,4,5,5,5,6], 5) == 4)

# Test case 2: Normal case with single occurrence of target
assert(funcImp([1,2,3,4,5], 3) == 2)

# Test case 3: Edge case where array does not contain target
assert(funcImp([1,2,3], 4) == -1)

# Test case 4: Edge case where array is empty
assert(funcImp([], 1) == -1)

print(""All test cases passed!"")
```","([1, 2, 3, 4, 5], 3)",2,2,PASS,TRUE,N/A
40,3,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function uses binary search to find the first occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): A sorted list of integers.
    target (int): The target integer to find.

    Returns:
    int: The index of the first occurrence of the target element. If not found, returns -1.
    """"""
    
    # Initialize left and right pointers
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2

        # Check if mid element is less than target. If yes, ignore left half
        if arr[mid] < target:
            left = mid + 1

        # If arr[mid] is greater or equal, then the required element can either be in the left half or at mid
        else:
            right = mid - 1

    # If we reach here, then the element was not present
    return left if left < len(arr) and arr[left] == target else -1


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of target
assert(funcImp([1,2,3,4,5,5,5,6], 5) == 4)

# Test case 2: Normal case with single occurrence of target
assert(funcImp([1,2,3,4,5], 3) == 2)

# Test case 3: Edge case where array does not contain target
assert(funcImp([1,2,3], 4) == -1)

# Test case 4: Edge case where array is empty
assert(funcImp([], 1) == -1)

print(""All test cases passed!"")
```","([1, 2, 3], 4)",-1,-1,PASS,TRUE,N/A
40,4,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function uses binary search to find the first occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): A sorted list of integers.
    target (int): The target integer to find.

    Returns:
    int: The index of the first occurrence of the target element. If not found, returns -1.
    """"""
    
    # Initialize left and right pointers
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2

        # Check if mid element is less than target. If yes, ignore left half
        if arr[mid] < target:
            left = mid + 1

        # If arr[mid] is greater or equal, then the required element can either be in the left half or at mid
        else:
            right = mid - 1

    # If we reach here, then the element was not present
    return left if left < len(arr) and arr[left] == target else -1


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of target
assert(funcImp([1,2,3,4,5,5,5,6], 5) == 4)

# Test case 2: Normal case with single occurrence of target
assert(funcImp([1,2,3,4,5], 3) == 2)

# Test case 3: Edge case where array does not contain target
assert(funcImp([1,2,3], 4) == -1)

# Test case 4: Edge case where array is empty
assert(funcImp([], 1) == -1)

print(""All test cases passed!"")
```","([], 1)",-1,-1,PASS,TRUE,N/A
41,1,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def find_last_occurrence(arr, target):
    """"""
    This function uses binary search to find the last occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): The sorted array.
    target (int): The target element to find.

    Returns:
    int: The index of the last occurrence of the target element. If not found, returns -1.
    """"""

    left = 0
    right = len(arr) - 1
    result = -1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            result = mid  # update result because we found an occurrence
            left = mid + 1  # but continue searching on the right side for possible later occurrences
        elif arr[mid] < target:
            left = mid + 1
        else: 
            right = mid - 1

    return result


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of the target
arr = [2,4,10,10,10,18,20]
target = 10
print(find_last_occurrence(arr,target)) # Expected output: 4

# Test case 2: Case where the target does not exist in the array
arr = [2,4,10,10,10,18,20]
target = 5
print(find_last_occurrence(arr,target)) # Expected output: -1

# Test case 3: Case where all elements are same as the target 
arr=[7]*1000 
target=7 
print(find_last_occurrence(arr,target)) # Expected output: 999

# Test case 4: Case where the target is at the end of the array
arr = [2,4,10,10,10,18,20]
target = 20
print(find_last_occurrence(arr,target)) # Expected output: 6

# Test case 5: Case where the target is at the beginning of the array
arr = [2,4,10,10,10,18,20]
target = 2
print(find_last_occurrence(arr,target)) # Expected output: 0
```","([2, 4, 10, 10, 10, 18, 20], 10)",4,4,PASS,TRUE,N/A
41,2,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def find_last_occurrence(arr, target):
    """"""
    This function uses binary search to find the last occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): The sorted array.
    target (int): The target element to find.

    Returns:
    int: The index of the last occurrence of the target element. If not found, returns -1.
    """"""

    left = 0
    right = len(arr) - 1
    result = -1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            result = mid  # update result because we found an occurrence
            left = mid + 1  # but continue searching on the right side for possible later occurrences
        elif arr[mid] < target:
            left = mid + 1
        else: 
            right = mid - 1

    return result


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of the target
arr = [2,4,10,10,10,18,20]
target = 10
print(find_last_occurrence(arr,target)) # Expected output: 4

# Test case 2: Case where the target does not exist in the array
arr = [2,4,10,10,10,18,20]
target = 5
print(find_last_occurrence(arr,target)) # Expected output: -1

# Test case 3: Case where all elements are same as the target 
arr=[7]*1000 
target=7 
print(find_last_occurrence(arr,target)) # Expected output: 999

# Test case 4: Case where the target is at the end of the array
arr = [2,4,10,10,10,18,20]
target = 20
print(find_last_occurrence(arr,target)) # Expected output: 6

# Test case 5: Case where the target is at the beginning of the array
arr = [2,4,10,10,10,18,20]
target = 2
print(find_last_occurrence(arr,target)) # Expected output: 0
```","([2, 4, 10, 10, 10, 18, 20], 5)",-1,-1,PASS,TRUE,N/A
41,3,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def find_last_occurrence(arr, target):
    """"""
    This function uses binary search to find the last occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): The sorted array.
    target (int): The target element to find.

    Returns:
    int: The index of the last occurrence of the target element. If not found, returns -1.
    """"""

    left = 0
    right = len(arr) - 1
    result = -1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            result = mid  # update result because we found an occurrence
            left = mid + 1  # but continue searching on the right side for possible later occurrences
        elif arr[mid] < target:
            left = mid + 1
        else: 
            right = mid - 1

    return result


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of the target
arr = [2,4,10,10,10,18,20]
target = 10
print(find_last_occurrence(arr,target)) # Expected output: 4

# Test case 2: Case where the target does not exist in the array
arr = [2,4,10,10,10,18,20]
target = 5
print(find_last_occurrence(arr,target)) # Expected output: -1

# Test case 3: Case where all elements are same as the target 
arr=[7]*1000 
target=7 
print(find_last_occurrence(arr,target)) # Expected output: 999

# Test case 4: Case where the target is at the end of the array
arr = [2,4,10,10,10,18,20]
target = 20
print(find_last_occurrence(arr,target)) # Expected output: 6

# Test case 5: Case where the target is at the beginning of the array
arr = [2,4,10,10,10,18,20]
target = 2
print(find_last_occurrence(arr,target)) # Expected output: 0
```","([7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], 7)",999,999,PASS,TRUE,N/A
41,4,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def find_last_occurrence(arr, target):
    """"""
    This function uses binary search to find the last occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): The sorted array.
    target (int): The target element to find.

    Returns:
    int: The index of the last occurrence of the target element. If not found, returns -1.
    """"""

    left = 0
    right = len(arr) - 1
    result = -1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            result = mid  # update result because we found an occurrence
            left = mid + 1  # but continue searching on the right side for possible later occurrences
        elif arr[mid] < target:
            left = mid + 1
        else: 
            right = mid - 1

    return result


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of the target
arr = [2,4,10,10,10,18,20]
target = 10
print(find_last_occurrence(arr,target)) # Expected output: 4

# Test case 2: Case where the target does not exist in the array
arr = [2,4,10,10,10,18,20]
target = 5
print(find_last_occurrence(arr,target)) # Expected output: -1

# Test case 3: Case where all elements are same as the target 
arr=[7]*1000 
target=7 
print(find_last_occurrence(arr,target)) # Expected output: 999

# Test case 4: Case where the target is at the end of the array
arr = [2,4,10,10,10,18,20]
target = 20
print(find_last_occurrence(arr,target)) # Expected output: 6

# Test case 5: Case where the target is at the beginning of the array
arr = [2,4,10,10,10,18,20]
target = 2
print(find_last_occurrence(arr,target)) # Expected output: 0
```","([2, 4, 10, 10, 10, 18, 20], 20)",6,6,PASS,TRUE,N/A
41,5,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def find_last_occurrence(arr, target):
    """"""
    This function uses binary search to find the last occurrence of a target element in a sorted array.
    
    Parameters:
    arr (list): The sorted array.
    target (int): The target element to find.

    Returns:
    int: The index of the last occurrence of the target element. If not found, returns -1.
    """"""

    left = 0
    right = len(arr) - 1
    result = -1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            result = mid  # update result because we found an occurrence
            left = mid + 1  # but continue searching on the right side for possible later occurrences
        elif arr[mid] < target:
            left = mid + 1
        else: 
            right = mid - 1

    return result


# Test cases to validate the solution

# Test case 1: Normal case with multiple occurrences of the target
arr = [2,4,10,10,10,18,20]
target = 10
print(find_last_occurrence(arr,target)) # Expected output: 4

# Test case 2: Case where the target does not exist in the array
arr = [2,4,10,10,10,18,20]
target = 5
print(find_last_occurrence(arr,target)) # Expected output: -1

# Test case 3: Case where all elements are same as the target 
arr=[7]*1000 
target=7 
print(find_last_occurrence(arr,target)) # Expected output: 999

# Test case 4: Case where the target is at the end of the array
arr = [2,4,10,10,10,18,20]
target = 20
print(find_last_occurrence(arr,target)) # Expected output: 6

# Test case 5: Case where the target is at the beginning of the array
arr = [2,4,10,10,10,18,20]
target = 2
print(find_last_occurrence(arr,target)) # Expected output: 0
```","([2, 4, 10, 10, 10, 18, 20], 2)",0,0,PASS,TRUE,N/A
42,1,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function performs a binary search on a sorted array and returns the index of the target element if found.
    If not found, it returns -1.

    Parameters:
    arr (list): The sorted list to be searched.
    target (int/float): The number to be searched in the list.

    Returns:
    int: The index of the target if found, else -1.
    """"""

    # Define start and end indices
    start = 0
    end = len(arr) - 1

    # Iterate while start index is less than or equal to end index
    while start <= end:
        # Calculate mid index
        mid = (start + end) // 2

        # If target is at mid index, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid, move end to mid-1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid, move start to mid+1
        else:
            start = mid + 1

    # Return -1 if element not found in array
    return -1


# Test cases to validate the solution

# Test case 1: Element present in array
arr = [2, 3, 4, 10, 40]
target = 10
print(binary_search(arr, target))   # Expected output: 3

# Test case 2: Element not present in array
arr = [2, 3, 4, 10, 40]
target = -5
print(binary_search(arr, target))   # Expected output: -1

# Test case 3: Element is the first in array
arr = [2, 3, 4, 10, 40]
target = 2
print(binary_search(arr, target))   # Expected output: 0

# Test case 4: Element is the last in array
arr = [2, 3, 4, 10, 40]
target = 40
print(binary_search(arr, target))   # Expected output: 4

# Test case 5: Array is empty
arr = []
target = -5
print(binary_search(arr, target))   # Expected output: -1
```","([2, 3, 4, 10, 40], 10)",3,3,PASS,TRUE,N/A
42,2,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function performs a binary search on a sorted array and returns the index of the target element if found.
    If not found, it returns -1.

    Parameters:
    arr (list): The sorted list to be searched.
    target (int/float): The number to be searched in the list.

    Returns:
    int: The index of the target if found, else -1.
    """"""

    # Define start and end indices
    start = 0
    end = len(arr) - 1

    # Iterate while start index is less than or equal to end index
    while start <= end:
        # Calculate mid index
        mid = (start + end) // 2

        # If target is at mid index, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid, move end to mid-1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid, move start to mid+1
        else:
            start = mid + 1

    # Return -1 if element not found in array
    return -1


# Test cases to validate the solution

# Test case 1: Element present in array
arr = [2, 3, 4, 10, 40]
target = 10
print(binary_search(arr, target))   # Expected output: 3

# Test case 2: Element not present in array
arr = [2, 3, 4, 10, 40]
target = -5
print(binary_search(arr, target))   # Expected output: -1

# Test case 3: Element is the first in array
arr = [2, 3, 4, 10, 40]
target = 2
print(binary_search(arr, target))   # Expected output: 0

# Test case 4: Element is the last in array
arr = [2, 3, 4, 10, 40]
target = 40
print(binary_search(arr, target))   # Expected output: 4

# Test case 5: Array is empty
arr = []
target = -5
print(binary_search(arr, target))   # Expected output: -1
```","([2, 3, 4, 10, 40], -5)",-1,-1,PASS,TRUE,N/A
42,3,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function performs a binary search on a sorted array and returns the index of the target element if found.
    If not found, it returns -1.

    Parameters:
    arr (list): The sorted list to be searched.
    target (int/float): The number to be searched in the list.

    Returns:
    int: The index of the target if found, else -1.
    """"""

    # Define start and end indices
    start = 0
    end = len(arr) - 1

    # Iterate while start index is less than or equal to end index
    while start <= end:
        # Calculate mid index
        mid = (start + end) // 2

        # If target is at mid index, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid, move end to mid-1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid, move start to mid+1
        else:
            start = mid + 1

    # Return -1 if element not found in array
    return -1


# Test cases to validate the solution

# Test case 1: Element present in array
arr = [2, 3, 4, 10, 40]
target = 10
print(binary_search(arr, target))   # Expected output: 3

# Test case 2: Element not present in array
arr = [2, 3, 4, 10, 40]
target = -5
print(binary_search(arr, target))   # Expected output: -1

# Test case 3: Element is the first in array
arr = [2, 3, 4, 10, 40]
target = 2
print(binary_search(arr, target))   # Expected output: 0

# Test case 4: Element is the last in array
arr = [2, 3, 4, 10, 40]
target = 40
print(binary_search(arr, target))   # Expected output: 4

# Test case 5: Array is empty
arr = []
target = -5
print(binary_search(arr, target))   # Expected output: -1
```","([2, 3, 4, 10, 40], 2)",0,0,PASS,TRUE,N/A
42,4,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function performs a binary search on a sorted array and returns the index of the target element if found.
    If not found, it returns -1.

    Parameters:
    arr (list): The sorted list to be searched.
    target (int/float): The number to be searched in the list.

    Returns:
    int: The index of the target if found, else -1.
    """"""

    # Define start and end indices
    start = 0
    end = len(arr) - 1

    # Iterate while start index is less than or equal to end index
    while start <= end:
        # Calculate mid index
        mid = (start + end) // 2

        # If target is at mid index, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid, move end to mid-1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid, move start to mid+1
        else:
            start = mid + 1

    # Return -1 if element not found in array
    return -1


# Test cases to validate the solution

# Test case 1: Element present in array
arr = [2, 3, 4, 10, 40]
target = 10
print(binary_search(arr, target))   # Expected output: 3

# Test case 2: Element not present in array
arr = [2, 3, 4, 10, 40]
target = -5
print(binary_search(arr, target))   # Expected output: -1

# Test case 3: Element is the first in array
arr = [2, 3, 4, 10, 40]
target = 2
print(binary_search(arr, target))   # Expected output: 0

# Test case 4: Element is the last in array
arr = [2, 3, 4, 10, 40]
target = 40
print(binary_search(arr, target))   # Expected output: 4

# Test case 5: Array is empty
arr = []
target = -5
print(binary_search(arr, target))   # Expected output: -1
```","([2, 3, 4, 10, 40], 40)",4,4,PASS,TRUE,N/A
42,5,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    """"""
    This function performs a binary search on a sorted array and returns the index of the target element if found.
    If not found, it returns -1.

    Parameters:
    arr (list): The sorted list to be searched.
    target (int/float): The number to be searched in the list.

    Returns:
    int: The index of the target if found, else -1.
    """"""

    # Define start and end indices
    start = 0
    end = len(arr) - 1

    # Iterate while start index is less than or equal to end index
    while start <= end:
        # Calculate mid index
        mid = (start + end) // 2

        # If target is at mid index, return mid
        if arr[mid] == target:
            return mid

        # If target is less than element at mid, move end to mid-1
        elif arr[mid] > target:
            end = mid - 1

        # If target is greater than element at mid, move start to mid+1
        else:
            start = mid + 1

    # Return -1 if element not found in array
    return -1


# Test cases to validate the solution

# Test case 1: Element present in array
arr = [2, 3, 4, 10, 40]
target = 10
print(binary_search(arr, target))   # Expected output: 3

# Test case 2: Element not present in array
arr = [2, 3, 4, 10, 40]
target = -5
print(binary_search(arr, target))   # Expected output: -1

# Test case 3: Element is the first in array
arr = [2, 3, 4, 10, 40]
target = 2
print(binary_search(arr, target))   # Expected output: 0

# Test case 4: Element is the last in array
arr = [2, 3, 4, 10, 40]
target = 40
print(binary_search(arr, target))   # Expected output: 4

# Test case 5: Array is empty
arr = []
target = -5
print(binary_search(arr, target))   # Expected output: -1
```","([], -5)",-1,-1,PASS,TRUE,N/A
43,1,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def find_min_in_rotated_sorted_array(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    :param nums: List[int], rotated sorted array
    :return: int, minimum element in the array
    """"""
    
    # If the list has just one element then return this element.
    if len(nums) == 1:
        return nums[0]

    # left pointer
    left = 0
    # right pointer
    right = len(nums) - 1

    # if the last element is greater than the first element then there is no rotation.
    # e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.
    # Hence the smallest element is first element. A[0]
    if nums[right] > nums[0]:
        return nums[0]

    # Binary search way
    while right >= left:
        # Find mid
        mid = left + (right - left) // 2
        # if the mid element is greater than its next element then mid+1 element is the smallest
        # This point would be the point of change. From higher to lower value.
        if nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        # if the mid element is lesser than its previous element then mid element is the smallest
        if nums[mid - 1] > nums[mid]:
            return nums[mid]

        # if the mid elements value is greater than the 0th element this means
        # the least value is still somewhere to the right as we are still dealing with elements greater than nums[0]
        if nums[mid] > nums[0]:
            left = mid + 1
        # if nums[0] is greater than the mid value then this means the smallest value is somewhere to the left
        else:
            right = mid - 1

# Test cases
print(find_min_in_rotated_sorted_array([3,4,5,1,2])) # Expected output: 1
print(find_min_in_rotated_sorted_array([4,5,6,7,0,1,2])) # Expected output: 0
print(find_min_in_rotated_sorted_array([11,13,15,17])) # Expected output: 11
```","[3, 4, 5, 1, 2]",1,1,PASS,TRUE,N/A
43,2,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def find_min_in_rotated_sorted_array(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    :param nums: List[int], rotated sorted array
    :return: int, minimum element in the array
    """"""
    
    # If the list has just one element then return this element.
    if len(nums) == 1:
        return nums[0]

    # left pointer
    left = 0
    # right pointer
    right = len(nums) - 1

    # if the last element is greater than the first element then there is no rotation.
    # e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.
    # Hence the smallest element is first element. A[0]
    if nums[right] > nums[0]:
        return nums[0]

    # Binary search way
    while right >= left:
        # Find mid
        mid = left + (right - left) // 2
        # if the mid element is greater than its next element then mid+1 element is the smallest
        # This point would be the point of change. From higher to lower value.
        if nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        # if the mid element is lesser than its previous element then mid element is the smallest
        if nums[mid - 1] > nums[mid]:
            return nums[mid]

        # if the mid elements value is greater than the 0th element this means
        # the least value is still somewhere to the right as we are still dealing with elements greater than nums[0]
        if nums[mid] > nums[0]:
            left = mid + 1
        # if nums[0] is greater than the mid value then this means the smallest value is somewhere to the left
        else:
            right = mid - 1

# Test cases
print(find_min_in_rotated_sorted_array([3,4,5,1,2])) # Expected output: 1
print(find_min_in_rotated_sorted_array([4,5,6,7,0,1,2])) # Expected output: 0
print(find_min_in_rotated_sorted_array([11,13,15,17])) # Expected output: 11
```","[4, 5, 6, 7, 0, 1, 2]",0,0,PASS,TRUE,N/A
43,3,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def find_min_in_rotated_sorted_array(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    :param nums: List[int], rotated sorted array
    :return: int, minimum element in the array
    """"""
    
    # If the list has just one element then return this element.
    if len(nums) == 1:
        return nums[0]

    # left pointer
    left = 0
    # right pointer
    right = len(nums) - 1

    # if the last element is greater than the first element then there is no rotation.
    # e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.
    # Hence the smallest element is first element. A[0]
    if nums[right] > nums[0]:
        return nums[0]

    # Binary search way
    while right >= left:
        # Find mid
        mid = left + (right - left) // 2
        # if the mid element is greater than its next element then mid+1 element is the smallest
        # This point would be the point of change. From higher to lower value.
        if nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        # if the mid element is lesser than its previous element then mid element is the smallest
        if nums[mid - 1] > nums[mid]:
            return nums[mid]

        # if the mid elements value is greater than the 0th element this means
        # the least value is still somewhere to the right as we are still dealing with elements greater than nums[0]
        if nums[mid] > nums[0]:
            left = mid + 1
        # if nums[0] is greater than the mid value then this means the smallest value is somewhere to the left
        else:
            right = mid - 1

# Test cases
print(find_min_in_rotated_sorted_array([3,4,5,1,2])) # Expected output: 1
print(find_min_in_rotated_sorted_array([4,5,6,7,0,1,2])) # Expected output: 0
print(find_min_in_rotated_sorted_array([11,13,15,17])) # Expected output: 11
```","[11, 13, 15, 17]",11,11,PASS,TRUE,N/A
44,1,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    This function performs binary search on a 2D matrix.
    
    Parameters:
    matrix (list): A 2D list of integers.
    target (int): The target number to be searched in the matrix.

    Returns:
    bool: True if the target is found in the matrix, False otherwise.
    """"""

    # If the input matrix is empty, return False
    if not matrix:
        return False

    # Get the dimensions of the matrix
    rows, cols = len(matrix), len(matrix[0])

    # Define start and end pointers for binary search
    start, end = 0, rows * cols - 1

    while start <= end:
        mid = (start + end) // 2
        # Calculate row and column indices from mid index
        row = mid // cols
        col = mid % cols

        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            start = mid + 1
        else:
            end = mid - 1

    return False


# Test cases to validate the solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [[1,3,5],[7,9,11],[13,15,17]]
target1 = 9
print(funcImp(matrix1,target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix 
matrix2 = [[10,20,30],[40,50,60],[70,80,90]]
target2 = 35 
print(funcImp(matrix2,target2)) # Expected output: False 

# Test case 3: Target exists at the boundary of the matrix
matrix3 = [[1,2,3],[4,5,6],[7,8,9]]
target3 = 1 
print(funcImp(matrix3,target3)) # Expected output: True 

# Test case 4: Empty matrix
matrix4 = []
target4 = 0 
print(funcImp(matrix4,target4)) # Expected output: False 
```","([[1, 3, 5], [7, 9, 11], [13, 15, 17]], 9)",TRUE,TRUE,PASS,TRUE,N/A
44,2,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    This function performs binary search on a 2D matrix.
    
    Parameters:
    matrix (list): A 2D list of integers.
    target (int): The target number to be searched in the matrix.

    Returns:
    bool: True if the target is found in the matrix, False otherwise.
    """"""

    # If the input matrix is empty, return False
    if not matrix:
        return False

    # Get the dimensions of the matrix
    rows, cols = len(matrix), len(matrix[0])

    # Define start and end pointers for binary search
    start, end = 0, rows * cols - 1

    while start <= end:
        mid = (start + end) // 2
        # Calculate row and column indices from mid index
        row = mid // cols
        col = mid % cols

        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            start = mid + 1
        else:
            end = mid - 1

    return False


# Test cases to validate the solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [[1,3,5],[7,9,11],[13,15,17]]
target1 = 9
print(funcImp(matrix1,target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix 
matrix2 = [[10,20,30],[40,50,60],[70,80,90]]
target2 = 35 
print(funcImp(matrix2,target2)) # Expected output: False 

# Test case 3: Target exists at the boundary of the matrix
matrix3 = [[1,2,3],[4,5,6],[7,8,9]]
target3 = 1 
print(funcImp(matrix3,target3)) # Expected output: True 

# Test case 4: Empty matrix
matrix4 = []
target4 = 0 
print(funcImp(matrix4,target4)) # Expected output: False 
```","([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 35)",FALSE,FALSE,PASS,TRUE,N/A
44,3,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    This function performs binary search on a 2D matrix.
    
    Parameters:
    matrix (list): A 2D list of integers.
    target (int): The target number to be searched in the matrix.

    Returns:
    bool: True if the target is found in the matrix, False otherwise.
    """"""

    # If the input matrix is empty, return False
    if not matrix:
        return False

    # Get the dimensions of the matrix
    rows, cols = len(matrix), len(matrix[0])

    # Define start and end pointers for binary search
    start, end = 0, rows * cols - 1

    while start <= end:
        mid = (start + end) // 2
        # Calculate row and column indices from mid index
        row = mid // cols
        col = mid % cols

        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            start = mid + 1
        else:
            end = mid - 1

    return False


# Test cases to validate the solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [[1,3,5],[7,9,11],[13,15,17]]
target1 = 9
print(funcImp(matrix1,target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix 
matrix2 = [[10,20,30],[40,50,60],[70,80,90]]
target2 = 35 
print(funcImp(matrix2,target2)) # Expected output: False 

# Test case 3: Target exists at the boundary of the matrix
matrix3 = [[1,2,3],[4,5,6],[7,8,9]]
target3 = 1 
print(funcImp(matrix3,target3)) # Expected output: True 

# Test case 4: Empty matrix
matrix4 = []
target4 = 0 
print(funcImp(matrix4,target4)) # Expected output: False 
```","([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1)",TRUE,TRUE,PASS,TRUE,N/A
44,4,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    This function performs binary search on a 2D matrix.
    
    Parameters:
    matrix (list): A 2D list of integers.
    target (int): The target number to be searched in the matrix.

    Returns:
    bool: True if the target is found in the matrix, False otherwise.
    """"""

    # If the input matrix is empty, return False
    if not matrix:
        return False

    # Get the dimensions of the matrix
    rows, cols = len(matrix), len(matrix[0])

    # Define start and end pointers for binary search
    start, end = 0, rows * cols - 1

    while start <= end:
        mid = (start + end) // 2
        # Calculate row and column indices from mid index
        row = mid // cols
        col = mid % cols

        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            start = mid + 1
        else:
            end = mid - 1

    return False


# Test cases to validate the solution

# Test case 1: Target exists in the middle of the matrix
matrix1 = [[1,3,5],[7,9,11],[13,15,17]]
target1 = 9
print(funcImp(matrix1,target1)) # Expected output: True

# Test case 2: Target does not exist in the matrix 
matrix2 = [[10,20,30],[40,50,60],[70,80,90]]
target2 = 35 
print(funcImp(matrix2,target2)) # Expected output: False 

# Test case 3: Target exists at the boundary of the matrix
matrix3 = [[1,2,3],[4,5,6],[7,8,9]]
target3 = 1 
print(funcImp(matrix3,target3)) # Expected output: True 

# Test case 4: Empty matrix
matrix4 = []
target4 = 0 
print(funcImp(matrix4,target4)) # Expected output: False 
```","([], 0)",FALSE,FALSE,PASS,TRUE,N/A
45,1,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def findPeak(arr):
    """"""
    This function takes an unsorted array as input and returns the peak element using binary search.
    A peak element is defined as an element that is greater than its neighbors.
    """"""

    # Define start and end of the array
    start, end = 0, len(arr) - 1

    # Binary Search for peak element
    while start < end:
        mid = (start + end) // 2

        # If middle element is less than next one, then peak must be in right half
        if arr[mid] < arr[mid + 1]:
            start = mid + 1
        else:
            # Else, the peak exists in left half
            end = mid

    # When start == end, we have found the peak element
    return arr[start]

# Test cases to validate the solution

# Peak element is '6'
print(findPeak([1,3,5,6,4])) 

# Peak element is '9'
print(findPeak([1,3,5,7,9])) 

# Peak element is '4'
print(findPeak([4])) 
```","[1, 3, 5, 6, 4]",6,6,PASS,TRUE,N/A
45,2,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def findPeak(arr):
    """"""
    This function takes an unsorted array as input and returns the peak element using binary search.
    A peak element is defined as an element that is greater than its neighbors.
    """"""

    # Define start and end of the array
    start, end = 0, len(arr) - 1

    # Binary Search for peak element
    while start < end:
        mid = (start + end) // 2

        # If middle element is less than next one, then peak must be in right half
        if arr[mid] < arr[mid + 1]:
            start = mid + 1
        else:
            # Else, the peak exists in left half
            end = mid

    # When start == end, we have found the peak element
    return arr[start]

# Test cases to validate the solution

# Peak element is '6'
print(findPeak([1,3,5,6,4])) 

# Peak element is '9'
print(findPeak([1,3,5,7,9])) 

# Peak element is '4'
print(findPeak([4])) 
```","[1, 3, 5, 7, 9]",9,9,PASS,TRUE,N/A
45,3,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def findPeak(arr):
    """"""
    This function takes an unsorted array as input and returns the peak element using binary search.
    A peak element is defined as an element that is greater than its neighbors.
    """"""

    # Define start and end of the array
    start, end = 0, len(arr) - 1

    # Binary Search for peak element
    while start < end:
        mid = (start + end) // 2

        # If middle element is less than next one, then peak must be in right half
        if arr[mid] < arr[mid + 1]:
            start = mid + 1
        else:
            # Else, the peak exists in left half
            end = mid

    # When start == end, we have found the peak element
    return arr[start]

# Test cases to validate the solution

# Peak element is '6'
print(findPeak([1,3,5,6,4])) 

# Peak element is '9'
print(findPeak([1,3,5,7,9])) 

# Peak element is '4'
print(findPeak([4])) 
```",[4],4,4,PASS,TRUE,N/A
46,1,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_bitonic(arr):
    """"""
    This function checks if an array is bitonic or not.
    An array is considered bitonic if it is first increasing and then decreasing.
    """"""
    
    # Find the index of peak element
    peak_index = arr.index(max(arr))
    
    # Check if elements on left side of peak are increasing
    for i in range(1, peak_index):
        if arr[i] < arr[i-1]:
            return False
    
    # Check if elements on right side of peak are decreasing
    for i in range(peak_index+1, len(arr)):
        if arr[i] > arr[i-1]:
            return False
    
    return True

# Test cases to verify the function

print(is_bitonic([1, 3, 5, 7, 6, 4]))  # Expected output: True
print(is_bitonic([1, 2, 3, 4]))         # Expected output: False
print(is_bitonic([7, 6, 5, 4]))         # Expected output: False
print(is_bitonic([1]))                  # Expected output: True
```","[1, 3, 5, 7, 6, 4]",TRUE,TRUE,PASS,TRUE,N/A
46,2,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_bitonic(arr):
    """"""
    This function checks if an array is bitonic or not.
    An array is considered bitonic if it is first increasing and then decreasing.
    """"""
    
    # Find the index of peak element
    peak_index = arr.index(max(arr))
    
    # Check if elements on left side of peak are increasing
    for i in range(1, peak_index):
        if arr[i] < arr[i-1]:
            return False
    
    # Check if elements on right side of peak are decreasing
    for i in range(peak_index+1, len(arr)):
        if arr[i] > arr[i-1]:
            return False
    
    return True

# Test cases to verify the function

print(is_bitonic([1, 3, 5, 7, 6, 4]))  # Expected output: True
print(is_bitonic([1, 2, 3, 4]))         # Expected output: False
print(is_bitonic([7, 6, 5, 4]))         # Expected output: False
print(is_bitonic([1]))                  # Expected output: True
```","[1, 2, 3, 4]",FALSE,TRUE,FAIL,FALSE,N/A
46,3,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_bitonic(arr):
    """"""
    This function checks if an array is bitonic or not.
    An array is considered bitonic if it is first increasing and then decreasing.
    """"""
    
    # Find the index of peak element
    peak_index = arr.index(max(arr))
    
    # Check if elements on left side of peak are increasing
    for i in range(1, peak_index):
        if arr[i] < arr[i-1]:
            return False
    
    # Check if elements on right side of peak are decreasing
    for i in range(peak_index+1, len(arr)):
        if arr[i] > arr[i-1]:
            return False
    
    return True

# Test cases to verify the function

print(is_bitonic([1, 3, 5, 7, 6, 4]))  # Expected output: True
print(is_bitonic([1, 2, 3, 4]))         # Expected output: False
print(is_bitonic([7, 6, 5, 4]))         # Expected output: False
print(is_bitonic([1]))                  # Expected output: True
```","[7, 6, 5, 4]",FALSE,TRUE,FAIL,FALSE,N/A
46,4,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_bitonic(arr):
    """"""
    This function checks if an array is bitonic or not.
    An array is considered bitonic if it is first increasing and then decreasing.
    """"""
    
    # Find the index of peak element
    peak_index = arr.index(max(arr))
    
    # Check if elements on left side of peak are increasing
    for i in range(1, peak_index):
        if arr[i] < arr[i-1]:
            return False
    
    # Check if elements on right side of peak are decreasing
    for i in range(peak_index+1, len(arr)):
        if arr[i] > arr[i-1]:
            return False
    
    return True

# Test cases to verify the function

print(is_bitonic([1, 3, 5, 7, 6, 4]))  # Expected output: True
print(is_bitonic([1, 2, 3, 4]))         # Expected output: False
print(is_bitonic([7, 6, 5, 4]))         # Expected output: False
print(is_bitonic([1]))                  # Expected output: True
```",[1],TRUE,TRUE,PASS,TRUE,N/A
47,1,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num, precision=0.00001):
    """"""
    This function calculates the square root of a given number using binary search.
    
    Parameters:
    num (float): The number to find the square root of.
    precision (float): The precision of the result. Default is 0.00001.

    Returns:
    float: The square root of num.
    """"""
    
    # Check if the number is negative
    if num < 0:
        raise ValueError(""Cannot calculate the square root of a negative number"")
        
    # Initialize start and end for binary search
    start = 0
    end = num
    
    # If the number is less than 1, set end as 1 to handle such cases
    if num < 1:
        end = 1

    while True:
        mid = (start + end) / 2
        
        # If we're close enough to the answer within our precision, return mid as answer
        if abs(mid*mid - num) <= precision:
            return mid
        
        # If mid*mid < num, then iterate on right side of mid
        elif mid*mid < num:
            start = mid
            
        # Else iterate on left side of mid
        else:
            end = mid


# Test cases to validate the solution

# Square root of 4 is 2
assert(abs(funcImp(4) - 2) <= 0.00001)

# Square root of 9 is 3
assert(abs(funcImp(9) - 3) <= 0.00001)

# Square root of 1 is 1
assert(abs(funcImp(1) - 1) <= 0.00001)

# Square root of numbers less than one should be greater than the number itself
assert(funcImp(0.16) > 0.16)

# Square root of 0 is 0
assert(abs(funcImp(0)) == 0)

print(""All test cases passed"")
```",4,2,2,PASS,TRUE,N/A
47,2,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num, precision=0.00001):
    """"""
    This function calculates the square root of a given number using binary search.
    
    Parameters:
    num (float): The number to find the square root of.
    precision (float): The precision of the result. Default is 0.00001.

    Returns:
    float: The square root of num.
    """"""
    
    # Check if the number is negative
    if num < 0:
        raise ValueError(""Cannot calculate the square root of a negative number"")
        
    # Initialize start and end for binary search
    start = 0
    end = num
    
    # If the number is less than 1, set end as 1 to handle such cases
    if num < 1:
        end = 1

    while True:
        mid = (start + end) / 2
        
        # If we're close enough to the answer within our precision, return mid as answer
        if abs(mid*mid - num) <= precision:
            return mid
        
        # If mid*mid < num, then iterate on right side of mid
        elif mid*mid < num:
            start = mid
            
        # Else iterate on left side of mid
        else:
            end = mid


# Test cases to validate the solution

# Square root of 4 is 2
assert(abs(funcImp(4) - 2) <= 0.00001)

# Square root of 9 is 3
assert(abs(funcImp(9) - 3) <= 0.00001)

# Square root of 1 is 1
assert(abs(funcImp(1) - 1) <= 0.00001)

# Square root of numbers less than one should be greater than the number itself
assert(funcImp(0.16) > 0.16)

# Square root of 0 is 0
assert(abs(funcImp(0)) == 0)

print(""All test cases passed"")
```",9,3,3.000001431,PASS,TRUE,N/A
47,3,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num, precision=0.00001):
    """"""
    This function calculates the square root of a given number using binary search.
    
    Parameters:
    num (float): The number to find the square root of.
    precision (float): The precision of the result. Default is 0.00001.

    Returns:
    float: The square root of num.
    """"""
    
    # Check if the number is negative
    if num < 0:
        raise ValueError(""Cannot calculate the square root of a negative number"")
        
    # Initialize start and end for binary search
    start = 0
    end = num
    
    # If the number is less than 1, set end as 1 to handle such cases
    if num < 1:
        end = 1

    while True:
        mid = (start + end) / 2
        
        # If we're close enough to the answer within our precision, return mid as answer
        if abs(mid*mid - num) <= precision:
            return mid
        
        # If mid*mid < num, then iterate on right side of mid
        elif mid*mid < num:
            start = mid
            
        # Else iterate on left side of mid
        else:
            end = mid


# Test cases to validate the solution

# Square root of 4 is 2
assert(abs(funcImp(4) - 2) <= 0.00001)

# Square root of 9 is 3
assert(abs(funcImp(9) - 3) <= 0.00001)

# Square root of 1 is 1
assert(abs(funcImp(1) - 1) <= 0.00001)

# Square root of numbers less than one should be greater than the number itself
assert(funcImp(0.16) > 0.16)

# Square root of 0 is 0
assert(abs(funcImp(0)) == 0)

print(""All test cases passed"")
```",1,1,0.999996185,PASS,TRUE,N/A
47,4,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num, precision=0.00001):
    """"""
    This function calculates the square root of a given number using binary search.
    
    Parameters:
    num (float): The number to find the square root of.
    precision (float): The precision of the result. Default is 0.00001.

    Returns:
    float: The square root of num.
    """"""
    
    # Check if the number is negative
    if num < 0:
        raise ValueError(""Cannot calculate the square root of a negative number"")
        
    # Initialize start and end for binary search
    start = 0
    end = num
    
    # If the number is less than 1, set end as 1 to handle such cases
    if num < 1:
        end = 1

    while True:
        mid = (start + end) / 2
        
        # If we're close enough to the answer within our precision, return mid as answer
        if abs(mid*mid - num) <= precision:
            return mid
        
        # If mid*mid < num, then iterate on right side of mid
        elif mid*mid < num:
            start = mid
            
        # Else iterate on left side of mid
        else:
            end = mid


# Test cases to validate the solution

# Square root of 4 is 2
assert(abs(funcImp(4) - 2) <= 0.00001)

# Square root of 9 is 3
assert(abs(funcImp(9) - 3) <= 0.00001)

# Square root of 1 is 1
assert(abs(funcImp(1) - 1) <= 0.00001)

# Square root of numbers less than one should be greater than the number itself
assert(funcImp(0.16) > 0.16)

# Square root of 0 is 0
assert(abs(funcImp(0)) == 0)

print(""All test cases passed"")
```",0.16,TRUE,0.399993896,FAIL,FALSE,N/A
47,5,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num, precision=0.00001):
    """"""
    This function calculates the square root of a given number using binary search.
    
    Parameters:
    num (float): The number to find the square root of.
    precision (float): The precision of the result. Default is 0.00001.

    Returns:
    float: The square root of num.
    """"""
    
    # Check if the number is negative
    if num < 0:
        raise ValueError(""Cannot calculate the square root of a negative number"")
        
    # Initialize start and end for binary search
    start = 0
    end = num
    
    # If the number is less than 1, set end as 1 to handle such cases
    if num < 1:
        end = 1

    while True:
        mid = (start + end) / 2
        
        # If we're close enough to the answer within our precision, return mid as answer
        if abs(mid*mid - num) <= precision:
            return mid
        
        # If mid*mid < num, then iterate on right side of mid
        elif mid*mid < num:
            start = mid
            
        # Else iterate on left side of mid
        else:
            end = mid


# Test cases to validate the solution

# Square root of 4 is 2
assert(abs(funcImp(4) - 2) <= 0.00001)

# Square root of 9 is 3
assert(abs(funcImp(9) - 3) <= 0.00001)

# Square root of 1 is 1
assert(abs(funcImp(1) - 1) <= 0.00001)

# Square root of numbers less than one should be greater than the number itself
assert(funcImp(0.16) > 0.16)

# Square root of 0 is 0
assert(abs(funcImp(0)) == 0)

print(""All test cases passed"")
```",0,0,0.001953125,FAIL,FALSE,N/A
48,1,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to perform Depth-First Search on a graph
def DFS(graph, start, visited):
    # Mark the current node as visited
    visited[start] = True

    # Recur for all the vertices adjacent to this vertex
    for i in graph[start]:
        if visited[i] == False:
            DFS(graph, i, visited)

# Function to return the count of connected components in an undirected graph
def connectedComponents(graph):
    visited = []
    cc_count = 0

    # Mark all the vertices as not visited
    for i in range(len(graph)):
        visited.append(False)

    # Call the recursive helper function to print DFS traversal starting from all vertices one by one
    for v in range(len(visited)):
        if visited[v] == False:
            DFS(graph, v, visited)
            cc_count += 1

    return cc_count

# Test cases
graph = [[1], [0, 3], [3], [1, 2]]
print(connectedComponents(graph))  # Output: 1

graph = [[1], [0], [3], [2]]
print(connectedComponents(graph))  # Output: 2
```","[[1], [0, 3], [3], [1, 2]]",1,1,PASS,TRUE,N/A
48,2,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to perform Depth-First Search on a graph
def DFS(graph, start, visited):
    # Mark the current node as visited
    visited[start] = True

    # Recur for all the vertices adjacent to this vertex
    for i in graph[start]:
        if visited[i] == False:
            DFS(graph, i, visited)

# Function to return the count of connected components in an undirected graph
def connectedComponents(graph):
    visited = []
    cc_count = 0

    # Mark all the vertices as not visited
    for i in range(len(graph)):
        visited.append(False)

    # Call the recursive helper function to print DFS traversal starting from all vertices one by one
    for v in range(len(visited)):
        if visited[v] == False:
            DFS(graph, v, visited)
            cc_count += 1

    return cc_count

# Test cases
graph = [[1], [0, 3], [3], [1, 2]]
print(connectedComponents(graph))  # Output: 1

graph = [[1], [0], [3], [2]]
print(connectedComponents(graph))  # Output: 2
```","[[1], [0], [3], [2]]",2,2,PASS,TRUE,N/A
49,1,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the structure of nodes in the binary tree
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

# Recursive DFS function
def funcImp(node):
    if node is not None:
        print(node.value)  # Visit the root node first
        funcImp(node.left)  # Then traverse the left subtree
        funcImp(node.right)  # Finally, traverse the right subtree

# Test the function with a binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

print(""Depth-First Search traversal of the binary tree is:"")
funcImp(root)
```","[1, 2, 3, 4, 5]","[1, 2, 4, 5, 3]","[1, 2, 4, 5, 3]",PASS,TRUE,N/A
50,1,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","# Define the function
def has_cycle(graph):
    """"""
    This function uses DFS to check if there is a cycle in the graph.
    
    :param graph: A dictionary representing the directed graph. 
                  The keys are nodes and the values are lists of nodes that can be reached by a direct edge from the key node.
    :return: True if there is a cycle, False otherwise.
    """"""
    
    # Create sets for visited and recursion stack nodes
    visited = set()
    rec_stack = set()

    # Helper function for DFS
    def dfs(node):
        visited.add(node)
        rec_stack.add(node)

        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True

        rec_stack.remove(node)
        return False

    # Call DFS helper function for every node
    for node in graph.keys():
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases to verify the function

graph1 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E'],
  'D': [],
  'E': ['F'],
  'F': []
}

print(has_cycle(graph1))  # Expected output: False

graph2 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E', 'A'],
  'D': [],
  'E': ['F'],
  'F': []
}

print(has_cycle(graph2))  # Expected output: True

graph3 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E'],
  'D': [],
  'E': ['F', 'B'],
  'F': []
}

print(has_cycle(graph3))  # Expected output: True","{'A': ['B'], 'B': ['C', 'D'], 'C': ['E'], 'D': [], 'E': ['F'], 'F': []}",FALSE,FALSE,PASS,TRUE,N/A
50,2,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","# Define the function
def has_cycle(graph):
    """"""
    This function uses DFS to check if there is a cycle in the graph.
    
    :param graph: A dictionary representing the directed graph. 
                  The keys are nodes and the values are lists of nodes that can be reached by a direct edge from the key node.
    :return: True if there is a cycle, False otherwise.
    """"""
    
    # Create sets for visited and recursion stack nodes
    visited = set()
    rec_stack = set()

    # Helper function for DFS
    def dfs(node):
        visited.add(node)
        rec_stack.add(node)

        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True

        rec_stack.remove(node)
        return False

    # Call DFS helper function for every node
    for node in graph.keys():
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases to verify the function

graph1 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E'],
  'D': [],
  'E': ['F'],
  'F': []
}

print(has_cycle(graph1))  # Expected output: False

graph2 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E', 'A'],
  'D': [],
  'E': ['F'],
  'F': []
}

print(has_cycle(graph2))  # Expected output: True

graph3 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E'],
  'D': [],
  'E': ['F', 'B'],
  'F': []
}

print(has_cycle(graph3))  # Expected output: True","{'A': ['B'], 'B': ['C', 'D'], 'C': ['E', 'A'], 'D': [], 'E': ['F'], 'F': []}",TRUE,TRUE,PASS,TRUE,N/A
50,3,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","# Define the function
def has_cycle(graph):
    """"""
    This function uses DFS to check if there is a cycle in the graph.
    
    :param graph: A dictionary representing the directed graph. 
                  The keys are nodes and the values are lists of nodes that can be reached by a direct edge from the key node.
    :return: True if there is a cycle, False otherwise.
    """"""
    
    # Create sets for visited and recursion stack nodes
    visited = set()
    rec_stack = set()

    # Helper function for DFS
    def dfs(node):
        visited.add(node)
        rec_stack.add(node)

        # Visit all neighbors
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True

        rec_stack.remove(node)
        return False

    # Call DFS helper function for every node
    for node in graph.keys():
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases to verify the function

graph1 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E'],
  'D': [],
  'E': ['F'],
  'F': []
}

print(has_cycle(graph1))  # Expected output: False

graph2 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E', 'A'],
  'D': [],
  'E': ['F'],
  'F': []
}

print(has_cycle(graph2))  # Expected output: True

graph3 = {
  'A': ['B'],
  'B': ['C', 'D'],
  'C': ['E'],
  'D': [],
  'E': ['F', 'B'],
  'F': []
}

print(has_cycle(graph3))  # Expected output: True","{'A': ['B'], 'B': ['C', 'D'], 'C': ['E'], 'D': [], 'E': ['F', 'B'], 'F': []}",TRUE,TRUE,PASS,TRUE,N/A
