problem_number,index,category,problem_type,problem,solution_prompt,solution,test_input,expected,actual,status,pass,exception
1,1,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to calculate the sum of two integers
def funcImp(a, b):
    # Check if both inputs are integers
    if isinstance(a, int) and isinstance(b, int):
        # Calculate the sum of a and b
        result = a + b
        return result
    else:
        return ""Error: Both inputs must be integers""

# Test the function with different test cases
test_cases = [
    (2, 3),         # Expected output: 5
    (-5, 10),       # Expected output: 5
    (0, 0),         # Expected output: 0
    (100, -50),     # Expected output: 50
    (""2"", ""3""),     # Expected output: Error message
    (2.5, 3.7),     # Expected output: Error message
]

for case in test_cases:
    input_a, input_b = case[0], case[1]
    print(f""Input: {input_a}, {input_b}"")
    print(f""Output: {funcImp(input_a, input_b)}"")
```","2, 3",5,5,PASS,TRUE,N/A
1,2,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to calculate the sum of two integers
def funcImp(a, b):
    # Check if both inputs are integers
    if isinstance(a, int) and isinstance(b, int):
        # Calculate the sum of a and b
        result = a + b
        return result
    else:
        return ""Error: Both inputs must be integers""

# Test the function with different test cases
test_cases = [
    (2, 3),         # Expected output: 5
    (-5, 10),       # Expected output: 5
    (0, 0),         # Expected output: 0
    (100, -50),     # Expected output: 50
    (""2"", ""3""),     # Expected output: Error message
    (2.5, 3.7),     # Expected output: Error message
]

for case in test_cases:
    input_a, input_b = case[0], case[1]
    print(f""Input: {input_a}, {input_b}"")
    print(f""Output: {funcImp(input_a, input_b)}"")
```","-5, 10",5,5,PASS,TRUE,N/A
1,3,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to calculate the sum of two integers
def funcImp(a, b):
    # Check if both inputs are integers
    if isinstance(a, int) and isinstance(b, int):
        # Calculate the sum of a and b
        result = a + b
        return result
    else:
        return ""Error: Both inputs must be integers""

# Test the function with different test cases
test_cases = [
    (2, 3),         # Expected output: 5
    (-5, 10),       # Expected output: 5
    (0, 0),         # Expected output: 0
    (100, -50),     # Expected output: 50
    (""2"", ""3""),     # Expected output: Error message
    (2.5, 3.7),     # Expected output: Error message
]

for case in test_cases:
    input_a, input_b = case[0], case[1]
    print(f""Input: {input_a}, {input_b}"")
    print(f""Output: {funcImp(input_a, input_b)}"")
```","0, 0",0,0,PASS,TRUE,N/A
1,4,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to calculate the sum of two integers
def funcImp(a, b):
    # Check if both inputs are integers
    if isinstance(a, int) and isinstance(b, int):
        # Calculate the sum of a and b
        result = a + b
        return result
    else:
        return ""Error: Both inputs must be integers""

# Test the function with different test cases
test_cases = [
    (2, 3),         # Expected output: 5
    (-5, 10),       # Expected output: 5
    (0, 0),         # Expected output: 0
    (100, -50),     # Expected output: 50
    (""2"", ""3""),     # Expected output: Error message
    (2.5, 3.7),     # Expected output: Error message
]

for case in test_cases:
    input_a, input_b = case[0], case[1]
    print(f""Input: {input_a}, {input_b}"")
    print(f""Output: {funcImp(input_a, input_b)}"")
```","100, -50",50,50,PASS,TRUE,N/A
1,5,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to calculate the sum of two integers
def funcImp(a, b):
    # Check if both inputs are integers
    if isinstance(a, int) and isinstance(b, int):
        # Calculate the sum of a and b
        result = a + b
        return result
    else:
        return ""Error: Both inputs must be integers""

# Test the function with different test cases
test_cases = [
    (2, 3),         # Expected output: 5
    (-5, 10),       # Expected output: 5
    (0, 0),         # Expected output: 0
    (100, -50),     # Expected output: 50
    (""2"", ""3""),     # Expected output: Error message
    (2.5, 3.7),     # Expected output: Error message
]

for case in test_cases:
    input_a, input_b = case[0], case[1]
    print(f""Input: {input_a}, {input_b}"")
    print(f""Output: {funcImp(input_a, input_b)}"")
```","2, 3",Error: Both inputs must be integers,Error: Both inputs must be integers,PASS,TRUE,N/A
1,6,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function to calculate the sum of two integers
def funcImp(a, b):
    # Check if both inputs are integers
    if isinstance(a, int) and isinstance(b, int):
        # Calculate the sum of a and b
        result = a + b
        return result
    else:
        return ""Error: Both inputs must be integers""

# Test the function with different test cases
test_cases = [
    (2, 3),         # Expected output: 5
    (-5, 10),       # Expected output: 5
    (0, 0),         # Expected output: 0
    (100, -50),     # Expected output: 50
    (""2"", ""3""),     # Expected output: Error message
    (2.5, 3.7),     # Expected output: Error message
]

for case in test_cases:
    input_a, input_b = case[0], case[1]
    print(f""Input: {input_a}, {input_b}"")
    print(f""Output: {funcImp(input_a, input_b)}"")
```","2.5, 3.7",Error: Both inputs must be integers,Error: Both inputs must be integers,PASS,TRUE,N/A
2,1,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to calculate the sum of two floating-point numbers
def funcImp(num1, num2):
    # Check if both inputs are valid floating-point numbers
    if isinstance(num1, float) and isinstance(num2, float):
        # Calculate the sum of the two numbers
        result = num1 + num2
        return result
    else:
        return ""Invalid input. Please provide valid floating-point numbers.""

# Test cases
test_cases = [
    (3.14, 2.71),   # Expected output: 5.85
    (-1.5, 4.2),    # Expected output: 2.7
    (0.0, 0.0),     # Expected output: 0.0
    (3.14, ""2.71""), # Expected output: Invalid input message
]

# Execute test cases and compare with expected results
for i, (num1, num2) in enumerate(test_cases):
    print(f""Test case {i+1}:"")
    print(f""Input: {num1}, {num2}"")
    
    result = funcImp(num1, num2)
    
    print(f""Output: {result}"")
    
    expected_result = test_cases[i][0] + test_cases[i][1]
    
    if result == expected_result:
        print(""Test passed."")
    else:
        print(""Test failed."")
        
    print()
```","3.14, 2.71",5.85,5.85,PASS,TRUE,N/A
2,2,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to calculate the sum of two floating-point numbers
def funcImp(num1, num2):
    # Check if both inputs are valid floating-point numbers
    if isinstance(num1, float) and isinstance(num2, float):
        # Calculate the sum of the two numbers
        result = num1 + num2
        return result
    else:
        return ""Invalid input. Please provide valid floating-point numbers.""

# Test cases
test_cases = [
    (3.14, 2.71),   # Expected output: 5.85
    (-1.5, 4.2),    # Expected output: 2.7
    (0.0, 0.0),     # Expected output: 0.0
    (3.14, ""2.71""), # Expected output: Invalid input message
]

# Execute test cases and compare with expected results
for i, (num1, num2) in enumerate(test_cases):
    print(f""Test case {i+1}:"")
    print(f""Input: {num1}, {num2}"")
    
    result = funcImp(num1, num2)
    
    print(f""Output: {result}"")
    
    expected_result = test_cases[i][0] + test_cases[i][1]
    
    if result == expected_result:
        print(""Test passed."")
    else:
        print(""Test failed."")
        
    print()
```","-1.5, 4.2",2.7,2.7,PASS,TRUE,N/A
2,3,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to calculate the sum of two floating-point numbers
def funcImp(num1, num2):
    # Check if both inputs are valid floating-point numbers
    if isinstance(num1, float) and isinstance(num2, float):
        # Calculate the sum of the two numbers
        result = num1 + num2
        return result
    else:
        return ""Invalid input. Please provide valid floating-point numbers.""

# Test cases
test_cases = [
    (3.14, 2.71),   # Expected output: 5.85
    (-1.5, 4.2),    # Expected output: 2.7
    (0.0, 0.0),     # Expected output: 0.0
    (3.14, ""2.71""), # Expected output: Invalid input message
]

# Execute test cases and compare with expected results
for i, (num1, num2) in enumerate(test_cases):
    print(f""Test case {i+1}:"")
    print(f""Input: {num1}, {num2}"")
    
    result = funcImp(num1, num2)
    
    print(f""Output: {result}"")
    
    expected_result = test_cases[i][0] + test_cases[i][1]
    
    if result == expected_result:
        print(""Test passed."")
    else:
        print(""Test failed."")
        
    print()
```","0.0, 0.0",0,0,PASS,TRUE,N/A
3,1,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    Function to convert two strings containing numeric values to integers and return their sum.
    
    Args:
        str1 (str): The first string containing a numeric value.
        str2 (str): The second string containing a numeric value.
        
    Returns:
        int: The sum of the converted integer values of str1 and str2.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(str1)
        num2 = int(str2)
        
        # Return the sum of the converted integers
        return num1 + num2
    
    except ValueError:
        # Handle the case where either or both input strings are not valid numeric values
        print(""Invalid input. Please provide valid numeric values."")
```","('10', '20')",30,30,PASS,TRUE,N/A
3,2,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    Function to convert two strings containing numeric values to integers and return their sum.
    
    Args:
        str1 (str): The first string containing a numeric value.
        str2 (str): The second string containing a numeric value.
        
    Returns:
        int: The sum of the converted integer values of str1 and str2.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(str1)
        num2 = int(str2)
        
        # Return the sum of the converted integers
        return num1 + num2
    
    except ValueError:
        # Handle the case where either or both input strings are not valid numeric values
        print(""Invalid input. Please provide valid numeric values."")
```","('5', '-3')",2,2,PASS,TRUE,N/A
3,3,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    Function to convert two strings containing numeric values to integers and return their sum.
    
    Args:
        str1 (str): The first string containing a numeric value.
        str2 (str): The second string containing a numeric value.
        
    Returns:
        int: The sum of the converted integer values of str1 and str2.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(str1)
        num2 = int(str2)
        
        # Return the sum of the converted integers
        return num1 + num2
    
    except ValueError:
        # Handle the case where either or both input strings are not valid numeric values
        print(""Invalid input. Please provide valid numeric values."")
```","('abc', 'def')",,,FAIL,FALSE,Invalid input. Please provide valid numeric values.
3,4,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    Function to convert two strings containing numeric values to integers and return their sum.
    
    Args:
        str1 (str): The first string containing a numeric value.
        str2 (str): The second string containing a numeric value.
        
    Returns:
        int: The sum of the converted integer values of str1 and str2.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(str1)
        num2 = int(str2)
        
        # Return the sum of the converted integers
        return num1 + num2
    
    except ValueError:
        # Handle the case where either or both input strings are not valid numeric values
        print(""Invalid input. Please provide valid numeric values."")
```","('', '15')",,,FAIL,FALSE,Invalid input. Please provide valid numeric values.
3,5,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(str1, str2):
    """"""
    Function to convert two strings containing numeric values to integers and return their sum.
    
    Args:
        str1 (str): The first string containing a numeric value.
        str2 (str): The second string containing a numeric value.
        
    Returns:
        int: The sum of the converted integer values of str1 and str2.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(str1)
        num2 = int(str2)
        
        # Return the sum of the converted integers
        return num1 + num2
    
    except ValueError:
        # Handle the case where either or both input strings are not valid numeric values
        print(""Invalid input. Please provide valid numeric values."")
```","('100', '')",,,FAIL,FALSE,Invalid input. Please provide valid numeric values.
4,1,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num1, num2):
    # Convert the binary strings to integers
    int1 = int(num1, 2)
    int2 = int(num2, 2)

    # Add the two integers
    result = int1 + int2

    # Convert the result back to a binary string
    binary_result = bin(result)[2:]

    return binary_result


# Test cases
test_cases = [
    (""10"", ""11""),  # Expected output: ""101""
    (""1010"", ""110""),  # Expected output: ""10000""
    (""111"", ""111""),  # Expected output: ""1110""
]

for num1, num2 in test_cases:
    result = funcImp(num1, num2)
    print(f""Input: {num1}, {num2} | Output: {result}"")
```","""10"", ""11""","""101""","""101""",PASS,TRUE,N/A
4,2,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num1, num2):
    # Convert the binary strings to integers
    int1 = int(num1, 2)
    int2 = int(num2, 2)

    # Add the two integers
    result = int1 + int2

    # Convert the result back to a binary string
    binary_result = bin(result)[2:]

    return binary_result


# Test cases
test_cases = [
    (""10"", ""11""),  # Expected output: ""101""
    (""1010"", ""110""),  # Expected output: ""10000""
    (""111"", ""111""),  # Expected output: ""1110""
]

for num1, num2 in test_cases:
    result = funcImp(num1, num2)
    print(f""Input: {num1}, {num2} | Output: {result}"")
```","""1010"", ""110""","""10000""","""10000""",PASS,TRUE,N/A
4,3,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num1, num2):
    # Convert the binary strings to integers
    int1 = int(num1, 2)
    int2 = int(num2, 2)

    # Add the two integers
    result = int1 + int2

    # Convert the result back to a binary string
    binary_result = bin(result)[2:]

    return binary_result


# Test cases
test_cases = [
    (""10"", ""11""),  # Expected output: ""101""
    (""1010"", ""110""),  # Expected output: ""10000""
    (""111"", ""111""),  # Expected output: ""1110""
]

for num1, num2 in test_cases:
    result = funcImp(num1, num2)
    print(f""Input: {num1}, {num2} | Output: {result}"")
```","""111"", ""111""","""1110""","""1110""",PASS,TRUE,N/A
5,1,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function finds the sum of all odd numbers between two given integers (inclusive).

    Parameters:
        start (int): The starting integer.
        end (int): The ending integer.

    Returns:
        int: The sum of all odd numbers between start and end.
    """"""
    # Initialize the sum to 0
    total = 0

    # Iterate over all numbers from start to end (inclusive)
    for num in range(start, end + 1):
        # Check if the number is odd
        if num % 2 != 0:
            # Add the odd number to the total sum
            total += num

    return total


# Test cases
test_cases = [
    (1, 10),   # Sum of odd numbers from 1 to 10 is 25
    (-5, 5),   # Sum of odd numbers from -5 to 5 is 0
    (0, 100),  # Sum of odd numbers from 0 to 100 is 2500
]

# Execute test cases and compare with expected results
for i, (start, end) in enumerate(test_cases):
    result = funcImp(start, end)
    
    print(f""Test case {i+1}:"")
    print(f""Start: {start}, End: {end}"")
    print(f""Result: {result}"")
    
```","start=1, end=10",25,25,PASS,TRUE,N/A
5,2,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function finds the sum of all odd numbers between two given integers (inclusive).

    Parameters:
        start (int): The starting integer.
        end (int): The ending integer.

    Returns:
        int: The sum of all odd numbers between start and end.
    """"""
    # Initialize the sum to 0
    total = 0

    # Iterate over all numbers from start to end (inclusive)
    for num in range(start, end + 1):
        # Check if the number is odd
        if num % 2 != 0:
            # Add the odd number to the total sum
            total += num

    return total


# Test cases
test_cases = [
    (1, 10),   # Sum of odd numbers from 1 to 10 is 25
    (-5, 5),   # Sum of odd numbers from -5 to 5 is 0
    (0, 100),  # Sum of odd numbers from 0 to 100 is 2500
]

# Execute test cases and compare with expected results
for i, (start, end) in enumerate(test_cases):
    result = funcImp(start, end)
    
    print(f""Test case {i+1}:"")
    print(f""Start: {start}, End: {end}"")
    print(f""Result: {result}"")
    
```","start=-5, end=5",0,0,PASS,TRUE,N/A
5,3,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function finds the sum of all odd numbers between two given integers (inclusive).

    Parameters:
        start (int): The starting integer.
        end (int): The ending integer.

    Returns:
        int: The sum of all odd numbers between start and end.
    """"""
    # Initialize the sum to 0
    total = 0

    # Iterate over all numbers from start to end (inclusive)
    for num in range(start, end + 1):
        # Check if the number is odd
        if num % 2 != 0:
            # Add the odd number to the total sum
            total += num

    return total


# Test cases
test_cases = [
    (1, 10),   # Sum of odd numbers from 1 to 10 is 25
    (-5, 5),   # Sum of odd numbers from -5 to 5 is 0
    (0, 100),  # Sum of odd numbers from 0 to 100 is 2500
]

# Execute test cases and compare with expected results
for i, (start, end) in enumerate(test_cases):
    result = funcImp(start, end)
    
    print(f""Test case {i+1}:"")
    print(f""Start: {start}, End: {end}"")
    print(f""Result: {result}"")
    
```","start=0, end=100",2500,2500,PASS,TRUE,N/A
6,1,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to find the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
        start (int): The starting integer.
        end (int): The ending integer.
        
    Returns:
        int: The sum of all prime numbers between start and end.
    """"""
    
    # Helper function to check if a number is prime
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True
    
    # Initialize the sum variable
    prime_sum = 0
    
    # Iterate through each number between start and end (inclusive)
    for num in range(start, end + 1):
        if is_prime(num):
            prime_sum += num
    
    return prime_sum

# Test cases
print(funcImp(1, 10))   # Output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20))  # Output: 28 (11 + 13 + 17 + 19)
print(funcImp(20, 30))  # Output: 41 (23 +29)
```","(1, 10)",17,17,PASS,TRUE,N/A
6,2,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to find the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
        start (int): The starting integer.
        end (int): The ending integer.
        
    Returns:
        int: The sum of all prime numbers between start and end.
    """"""
    
    # Helper function to check if a number is prime
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True
    
    # Initialize the sum variable
    prime_sum = 0
    
    # Iterate through each number between start and end (inclusive)
    for num in range(start, end + 1):
        if is_prime(num):
            prime_sum += num
    
    return prime_sum

# Test cases
print(funcImp(1, 10))   # Output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20))  # Output: 28 (11 + 13 + 17 + 19)
print(funcImp(20, 30))  # Output: 41 (23 +29)
```","(10, 20)",28,60,FAIL,FALSE,N/A
6,3,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to find the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
        start (int): The starting integer.
        end (int): The ending integer.
        
    Returns:
        int: The sum of all prime numbers between start and end.
    """"""
    
    # Helper function to check if a number is prime
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True
    
    # Initialize the sum variable
    prime_sum = 0
    
    # Iterate through each number between start and end (inclusive)
    for num in range(start, end + 1):
        if is_prime(num):
            prime_sum += num
    
    return prime_sum

# Test cases
print(funcImp(1, 10))   # Output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20))  # Output: 28 (11 + 13 + 17 + 19)
print(funcImp(20, 30))  # Output: 41 (23 +29)
```","(20, 30)",41,52,FAIL,FALSE,N/A
7,1,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.

    Parameters:
    - numbers: A list of numbers

    Returns:
    - The average of the numbers
    """"""
    total = 0
    count = 0

    # Iterate over each number in the list
    for num in numbers:
        total += num
        count += 1

    # Calculate the average
    if count > 0:
        average = total / count
        return average
    else:
        return None


# Test cases
test_cases = [
    ([1, 2, 3, 4, 5], 3.0),   # Average of [1, 2, 3, 4, 5] is 3.0
    ([10, -5, 8], 4.333333333333333),   # Average of [10, -5, 8] is approximately 4.33
]

# Execute test cases and compare with expected results
for i, (numbers, expected_result) in enumerate(test_cases):
    result = funcImp(numbers)
    
    if result == expected_result:
        print(f""Test case {i+1}: Passed"")
    else:
        print(f""Test case {i+1}: Failed. Expected {expected_result}, but got {result}"")
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,N/A
7,2,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.

    Parameters:
    - numbers: A list of numbers

    Returns:
    - The average of the numbers
    """"""
    total = 0
    count = 0

    # Iterate over each number in the list
    for num in numbers:
        total += num
        count += 1

    # Calculate the average
    if count > 0:
        average = total / count
        return average
    else:
        return None


# Test cases
test_cases = [
    ([1, 2, 3, 4, 5], 3.0),   # Average of [1, 2, 3, 4, 5] is 3.0
    ([10, -5, 8], 4.333333333333333),   # Average of [10, -5, 8] is approximately 4.33
]

# Execute test cases and compare with expected results
for i, (numbers, expected_result) in enumerate(test_cases):
    result = funcImp(numbers)
    
    if result == expected_result:
        print(f""Test case {i+1}: Passed"")
    else:
        print(f""Test case {i+1}: Failed. Expected {expected_result}, but got {result}"")
```","[10, -5, 8]",4.333333333,4.333333333,PASS,TRUE,N/A
8,1,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Base case: if the list is empty, return 0
    if len(numbers) == 0:
        return 0
    
    # Recursive case: calculate the sum of all numbers in the list
    # and divide it by the length of the list
    return (numbers[0] + funcImp(numbers[1:])) / len(numbers)

# Test cases
test_cases = [
    [1, 2, 3, 4, 5],            # average = 3.0
    [10, -5, 8, -2],            # average = 2.75
    [0],                        # average = 0.0
    [],                         # average = 0.0 (empty list)
]

# Execute test cases and compare with expected results
for i, numbers in enumerate(test_cases):
    result = funcImp(numbers)
    
    print(f""Test case {i+1}:"")
    print(f""Input: {numbers}"")
    print(f""Output: {result}"")
    
```","[1, 2, 3, 4, 5]",3,0.425,FAIL,FALSE,N/A
8,2,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Base case: if the list is empty, return 0
    if len(numbers) == 0:
        return 0
    
    # Recursive case: calculate the sum of all numbers in the list
    # and divide it by the length of the list
    return (numbers[0] + funcImp(numbers[1:])) / len(numbers)

# Test cases
test_cases = [
    [1, 2, 3, 4, 5],            # average = 3.0
    [10, -5, 8, -2],            # average = 2.75
    [0],                        # average = 0.0
    [],                         # average = 0.0 (empty list)
]

# Execute test cases and compare with expected results
for i, numbers in enumerate(test_cases):
    result = funcImp(numbers)
    
    print(f""Test case {i+1}:"")
    print(f""Input: {numbers}"")
    print(f""Output: {result}"")
    
```","[10, -5, 8, -2]",2.75,2.333333333,FAIL,FALSE,N/A
8,3,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Base case: if the list is empty, return 0
    if len(numbers) == 0:
        return 0
    
    # Recursive case: calculate the sum of all numbers in the list
    # and divide it by the length of the list
    return (numbers[0] + funcImp(numbers[1:])) / len(numbers)

# Test cases
test_cases = [
    [1, 2, 3, 4, 5],            # average = 3.0
    [10, -5, 8, -2],            # average = 2.75
    [0],                        # average = 0.0
    [],                         # average = 0.0 (empty list)
]

# Execute test cases and compare with expected results
for i, numbers in enumerate(test_cases):
    result = funcImp(numbers)
    
    print(f""Test case {i+1}:"")
    print(f""Input: {numbers}"")
    print(f""Output: {result}"")
    
```",[0],0,0,PASS,TRUE,N/A
9,1,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Check if the input list is empty
    if len(numbers) == 0:
        return None
    
    # Initialize variables for sum and count
    total = 0
    count = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Check if the current element is a number
        if isinstance(num, (int, float)):
            total += num
            count += 1
    
    # Calculate the average by dividing the sum by the count
    average = total / count
    
    return average

# Test cases
test_case_1 = [1, 2, 3, 4, 5]
test_case_2 = [10, -5, 8.5, -2.5]
test_case_3 = []
test_case_4 = [1, 'a', 2.5, 'b', True]

# Execute test cases
print(funcImp(test_case_1))   # Output: 3.0
print(funcImp(test_case_2))   # Output: 2.25
print(funcImp(test_case_3))   # Output: None (empty list)
print(funcImp(test_case_4))   # Output: 1.75 (only consider numeric elements)
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,N/A
9,2,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Check if the input list is empty
    if len(numbers) == 0:
        return None
    
    # Initialize variables for sum and count
    total = 0
    count = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Check if the current element is a number
        if isinstance(num, (int, float)):
            total += num
            count += 1
    
    # Calculate the average by dividing the sum by the count
    average = total / count
    
    return average

# Test cases
test_case_1 = [1, 2, 3, 4, 5]
test_case_2 = [10, -5, 8.5, -2.5]
test_case_3 = []
test_case_4 = [1, 'a', 2.5, 'b', True]

# Execute test cases
print(funcImp(test_case_1))   # Output: 3.0
print(funcImp(test_case_2))   # Output: 2.25
print(funcImp(test_case_3))   # Output: None (empty list)
print(funcImp(test_case_4))   # Output: 1.75 (only consider numeric elements)
```","[10, -5, 8.5, -2.5]",2.75,2.75,PASS,TRUE,N/A
10,1,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Check if the list is empty
    if len(numbers) == 0:
        return None
    
    # Initialize variables for sum and count
    total = 0
    count = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Check if the number is valid (numeric)
        if isinstance(num, (int, float)):
            total += num
            count += 1
    
    # Check if no valid numbers were found
    if count == 0:
        return None
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases
test_cases = [
    ([1, 2, 3], 2),
    ([10, -5, 8, 2], 3.75),
    ([], None),
    ([1, 'a', 'b', 4], 2.5),
]

# Execute test cases and compare with expected results
for numbers, expected_result in test_cases:
    result = funcImp(numbers)
    
    print(f""Input: {numbers}"")
    print(f""Expected Result: {expected_result}"")
    
    if result == expected_result:
        print(""Test Passed"")
        print()
    else:
        print(""Test Failed"")
        print()
```","[1, 2, 3]",2,2,PASS,TRUE,N/A
10,2,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Check if the list is empty
    if len(numbers) == 0:
        return None
    
    # Initialize variables for sum and count
    total = 0
    count = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Check if the number is valid (numeric)
        if isinstance(num, (int, float)):
            total += num
            count += 1
    
    # Check if no valid numbers were found
    if count == 0:
        return None
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases
test_cases = [
    ([1, 2, 3], 2),
    ([10, -5, 8, 2], 3.75),
    ([], None),
    ([1, 'a', 'b', 4], 2.5),
]

# Execute test cases and compare with expected results
for numbers, expected_result in test_cases:
    result = funcImp(numbers)
    
    print(f""Input: {numbers}"")
    print(f""Expected Result: {expected_result}"")
    
    if result == expected_result:
        print(""Test Passed"")
        print()
    else:
        print(""Test Failed"")
        print()
```","[10, -5, 8, 2]",3.75,3.75,PASS,TRUE,N/A
10,3,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Check if the list is empty
    if len(numbers) == 0:
        return None
    
    # Initialize variables for sum and count
    total = 0
    count = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Check if the number is valid (numeric)
        if isinstance(num, (int, float)):
            total += num
            count += 1
    
    # Check if no valid numbers were found
    if count == 0:
        return None
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases
test_cases = [
    ([1, 2, 3], 2),
    ([10, -5, 8, 2], 3.75),
    ([], None),
    ([1, 'a', 'b', 4], 2.5),
]

# Execute test cases and compare with expected results
for numbers, expected_result in test_cases:
    result = funcImp(numbers)
    
    print(f""Input: {numbers}"")
    print(f""Expected Result: {expected_result}"")
    
    if result == expected_result:
        print(""Test Passed"")
        print()
    else:
        print(""Test Failed"")
        print()
```",[],,,PASS,TRUE,N/A
10,4,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Check if the list is empty
    if len(numbers) == 0:
        return None
    
    # Initialize variables for sum and count
    total = 0
    count = 0
    
    # Iterate over each number in the list
    for num in numbers:
        # Check if the number is valid (numeric)
        if isinstance(num, (int, float)):
            total += num
            count += 1
    
    # Check if no valid numbers were found
    if count == 0:
        return None
    
    # Calculate and return the average
    average = total / count
    return average

# Test cases
test_cases = [
    ([1, 2, 3], 2),
    ([10, -5, 8, 2], 3.75),
    ([], None),
    ([1, 'a', 'b', 4], 2.5),
]

# Execute test cases and compare with expected results
for numbers, expected_result in test_cases:
    result = funcImp(numbers)
    
    print(f""Input: {numbers}"")
    print(f""Expected Result: {expected_result}"")
    
    if result == expected_result:
        print(""Test Passed"")
        print()
    else:
        print(""Test Failed"")
        print()
```","[1, 'a', 'b', 4]",2.5,2.5,PASS,TRUE,N/A
11,1,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    # Check if the lengths of numbers and weights are equal
    if len(numbers) != len(weights):
        return ""Error: The lengths of numbers and weights should be equal.""

    # Calculate the sum of products of each number and its weight
    weighted_sum = sum(num * weight for num, weight in zip(numbers, weights))

    # Calculate the total weight
    total_weight = sum(weights)

    # Calculate the weighted average
    weighted_average = weighted_sum / total_weight

    return weighted_average


# Test cases
numbers = [1, 2, 3]
weights = [0.5, 0.3, 0.2]
print(funcImp(numbers, weights))  # Output: 1.4

numbers = [4, 5, 6]
weights = [0.25, 0.25, 0.5]
print(funcImp(numbers, weights))  # Output: 5.75

numbers = [10]
weights = [1]
print(funcImp(numbers, weights))  # Output: 10

numbers = []
weights = []
print(funcImp(numbers, weights))  # Output: Error: The lengths of numbers and weights should be equal.
```","[[1, 2, 3], [0.5, 0.3, 0.2]]",1.4,1.7,FAIL,FALSE,N/A
11,2,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    # Check if the lengths of numbers and weights are equal
    if len(numbers) != len(weights):
        return ""Error: The lengths of numbers and weights should be equal.""

    # Calculate the sum of products of each number and its weight
    weighted_sum = sum(num * weight for num, weight in zip(numbers, weights))

    # Calculate the total weight
    total_weight = sum(weights)

    # Calculate the weighted average
    weighted_average = weighted_sum / total_weight

    return weighted_average


# Test cases
numbers = [1, 2, 3]
weights = [0.5, 0.3, 0.2]
print(funcImp(numbers, weights))  # Output: 1.4

numbers = [4, 5, 6]
weights = [0.25, 0.25, 0.5]
print(funcImp(numbers, weights))  # Output: 5.75

numbers = [10]
weights = [1]
print(funcImp(numbers, weights))  # Output: 10

numbers = []
weights = []
print(funcImp(numbers, weights))  # Output: Error: The lengths of numbers and weights should be equal.
```","[[4, 5, 6], [0.25, 0.25, 0.5]]",5.75,5.25,FAIL,FALSE,N/A
11,3,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    # Check if the lengths of numbers and weights are equal
    if len(numbers) != len(weights):
        return ""Error: The lengths of numbers and weights should be equal.""

    # Calculate the sum of products of each number and its weight
    weighted_sum = sum(num * weight for num, weight in zip(numbers, weights))

    # Calculate the total weight
    total_weight = sum(weights)

    # Calculate the weighted average
    weighted_average = weighted_sum / total_weight

    return weighted_average


# Test cases
numbers = [1, 2, 3]
weights = [0.5, 0.3, 0.2]
print(funcImp(numbers, weights))  # Output: 1.4

numbers = [4, 5, 6]
weights = [0.25, 0.25, 0.5]
print(funcImp(numbers, weights))  # Output: 5.75

numbers = [10]
weights = [1]
print(funcImp(numbers, weights))  # Output: 10

numbers = []
weights = []
print(funcImp(numbers, weights))  # Output: Error: The lengths of numbers and weights should be equal.
```","[[10], [1]]",10,10,PASS,TRUE,N/A
11,4,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    # Check if the lengths of numbers and weights are equal
    if len(numbers) != len(weights):
        return ""Error: The lengths of numbers and weights should be equal.""

    # Calculate the sum of products of each number and its weight
    weighted_sum = sum(num * weight for num, weight in zip(numbers, weights))

    # Calculate the total weight
    total_weight = sum(weights)

    # Calculate the weighted average
    weighted_average = weighted_sum / total_weight

    return weighted_average


# Test cases
numbers = [1, 2, 3]
weights = [0.5, 0.3, 0.2]
print(funcImp(numbers, weights))  # Output: 1.4

numbers = [4, 5, 6]
weights = [0.25, 0.25, 0.5]
print(funcImp(numbers, weights))  # Output: 5.75

numbers = [10]
weights = [1]
print(funcImp(numbers, weights))  # Output: 10

numbers = []
weights = []
print(funcImp(numbers, weights))  # Output: Error: The lengths of numbers and weights should be equal.
```","[[], []]",Error: The lengths of numbers and weights should be equal.,,FAIL,FALSE,division by zero
12,1,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Convert the input list of numbers to a sorted list
    sorted_numbers = sorted(numbers)
    
    # Find the median value
    n = len(sorted_numbers)
    if n % 2 == 0:
        median = (sorted_numbers[n//2 - 1] + sorted_numbers[n//2]) / 2
    else:
        median = sorted_numbers[n//2]
    
    # Calculate the average of all values greater than or equal to the median
    total = 0
    count = 0
    for num in sorted_numbers:
        if num >= median:
            total += num
            count += 1
    
    if count > 0:
        average = total / count
    else:
        average = None
    
    return median, average


# Test cases

# Test case 1: List with odd number of elements
numbers1 = [5, 3, 8, 2, 9]
median1, average1 = funcImp(numbers1)
print(f""Test case 1: {numbers1}"")
print(f""Median: {median1}, Average: {average1}"")

# Test case 2: List with even number of elements
numbers2 = [7, 4, 6, 9]
median2, average2 = funcImp(numbers2)
print(f""Test case 2: {numbers2}"")
print(f""Median: {median2}, Average: {average2}"")

# Test case 3: List with duplicate elements
numbers3 = [5, 3, 8, 5]
median3, average3 = funcImp(numbers3)
print(f""Test case 3: {numbers3}"")
print(f""Median: {median3}, Average: {average3}"")

# Test case 4: List with all elements less than the median
numbers4 = [1, 2, 3, 4]
median4, average4 = funcImp(numbers4)
print(f""Test case 4: {numbers4}"")
print(f""Median: {median4}, Average: {average4}"")

# Test case 5: List with all elements greater than or equal to the median
numbers5 = [6, 7, 8, 9]
median5, average5 = funcImp(numbers5)
print(f""Test case 5: {numbers5}"")
print(f""Median: {median5}, Average: {average5}"")

# Test case 6: Empty list
numbers6 = []
median6, average6 = funcImp(numbers6)
print(f""Test case 6: {numbers6}"")
print(f""Median: {median6}, Average: {average6}"")
```","[5, 3, 8, 2, 9]","5, 7.333333333333333","5, 7.333333333333333",PASS,TRUE,N/A
12,2,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Convert the input list of numbers to a sorted list
    sorted_numbers = sorted(numbers)
    
    # Find the median value
    n = len(sorted_numbers)
    if n % 2 == 0:
        median = (sorted_numbers[n//2 - 1] + sorted_numbers[n//2]) / 2
    else:
        median = sorted_numbers[n//2]
    
    # Calculate the average of all values greater than or equal to the median
    total = 0
    count = 0
    for num in sorted_numbers:
        if num >= median:
            total += num
            count += 1
    
    if count > 0:
        average = total / count
    else:
        average = None
    
    return median, average


# Test cases

# Test case 1: List with odd number of elements
numbers1 = [5, 3, 8, 2, 9]
median1, average1 = funcImp(numbers1)
print(f""Test case 1: {numbers1}"")
print(f""Median: {median1}, Average: {average1}"")

# Test case 2: List with even number of elements
numbers2 = [7, 4, 6, 9]
median2, average2 = funcImp(numbers2)
print(f""Test case 2: {numbers2}"")
print(f""Median: {median2}, Average: {average2}"")

# Test case 3: List with duplicate elements
numbers3 = [5, 3, 8, 5]
median3, average3 = funcImp(numbers3)
print(f""Test case 3: {numbers3}"")
print(f""Median: {median3}, Average: {average3}"")

# Test case 4: List with all elements less than the median
numbers4 = [1, 2, 3, 4]
median4, average4 = funcImp(numbers4)
print(f""Test case 4: {numbers4}"")
print(f""Median: {median4}, Average: {average4}"")

# Test case 5: List with all elements greater than or equal to the median
numbers5 = [6, 7, 8, 9]
median5, average5 = funcImp(numbers5)
print(f""Test case 5: {numbers5}"")
print(f""Median: {median5}, Average: {average5}"")

# Test case 6: Empty list
numbers6 = []
median6, average6 = funcImp(numbers6)
print(f""Test case 6: {numbers6}"")
print(f""Median: {median6}, Average: {average6}"")
```","[7, 4, 6, 9]","6.5, 7.666666666666667","6.5, 8.0",FAIL,FALSE,N/A
12,3,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Convert the input list of numbers to a sorted list
    sorted_numbers = sorted(numbers)
    
    # Find the median value
    n = len(sorted_numbers)
    if n % 2 == 0:
        median = (sorted_numbers[n//2 - 1] + sorted_numbers[n//2]) / 2
    else:
        median = sorted_numbers[n//2]
    
    # Calculate the average of all values greater than or equal to the median
    total = 0
    count = 0
    for num in sorted_numbers:
        if num >= median:
            total += num
            count += 1
    
    if count > 0:
        average = total / count
    else:
        average = None
    
    return median, average


# Test cases

# Test case 1: List with odd number of elements
numbers1 = [5, 3, 8, 2, 9]
median1, average1 = funcImp(numbers1)
print(f""Test case 1: {numbers1}"")
print(f""Median: {median1}, Average: {average1}"")

# Test case 2: List with even number of elements
numbers2 = [7, 4, 6, 9]
median2, average2 = funcImp(numbers2)
print(f""Test case 2: {numbers2}"")
print(f""Median: {median2}, Average: {average2}"")

# Test case 3: List with duplicate elements
numbers3 = [5, 3, 8, 5]
median3, average3 = funcImp(numbers3)
print(f""Test case 3: {numbers3}"")
print(f""Median: {median3}, Average: {average3}"")

# Test case 4: List with all elements less than the median
numbers4 = [1, 2, 3, 4]
median4, average4 = funcImp(numbers4)
print(f""Test case 4: {numbers4}"")
print(f""Median: {median4}, Average: {average4}"")

# Test case 5: List with all elements greater than or equal to the median
numbers5 = [6, 7, 8, 9]
median5, average5 = funcImp(numbers5)
print(f""Test case 5: {numbers5}"")
print(f""Median: {median5}, Average: {average5}"")

# Test case 6: Empty list
numbers6 = []
median6, average6 = funcImp(numbers6)
print(f""Test case 6: {numbers6}"")
print(f""Median: {median6}, Average: {average6}"")
```","[5, 3, 8, 5]","5.0, 6.0","5.0, 6.0",PASS,TRUE,N/A
12,4,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Convert the input list of numbers to a sorted list
    sorted_numbers = sorted(numbers)
    
    # Find the median value
    n = len(sorted_numbers)
    if n % 2 == 0:
        median = (sorted_numbers[n//2 - 1] + sorted_numbers[n//2]) / 2
    else:
        median = sorted_numbers[n//2]
    
    # Calculate the average of all values greater than or equal to the median
    total = 0
    count = 0
    for num in sorted_numbers:
        if num >= median:
            total += num
            count += 1
    
    if count > 0:
        average = total / count
    else:
        average = None
    
    return median, average


# Test cases

# Test case 1: List with odd number of elements
numbers1 = [5, 3, 8, 2, 9]
median1, average1 = funcImp(numbers1)
print(f""Test case 1: {numbers1}"")
print(f""Median: {median1}, Average: {average1}"")

# Test case 2: List with even number of elements
numbers2 = [7, 4, 6, 9]
median2, average2 = funcImp(numbers2)
print(f""Test case 2: {numbers2}"")
print(f""Median: {median2}, Average: {average2}"")

# Test case 3: List with duplicate elements
numbers3 = [5, 3, 8, 5]
median3, average3 = funcImp(numbers3)
print(f""Test case 3: {numbers3}"")
print(f""Median: {median3}, Average: {average3}"")

# Test case 4: List with all elements less than the median
numbers4 = [1, 2, 3, 4]
median4, average4 = funcImp(numbers4)
print(f""Test case 4: {numbers4}"")
print(f""Median: {median4}, Average: {average4}"")

# Test case 5: List with all elements greater than or equal to the median
numbers5 = [6, 7, 8, 9]
median5, average5 = funcImp(numbers5)
print(f""Test case 5: {numbers5}"")
print(f""Median: {median5}, Average: {average5}"")

# Test case 6: Empty list
numbers6 = []
median6, average6 = funcImp(numbers6)
print(f""Test case 6: {numbers6}"")
print(f""Median: {median6}, Average: {average6}"")
```","[1, 2, 3, 4]","2.5, None","2.5, 3.5",FAIL,FALSE,N/A
12,5,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    # Convert the input list of numbers to a sorted list
    sorted_numbers = sorted(numbers)
    
    # Find the median value
    n = len(sorted_numbers)
    if n % 2 == 0:
        median = (sorted_numbers[n//2 - 1] + sorted_numbers[n//2]) / 2
    else:
        median = sorted_numbers[n//2]
    
    # Calculate the average of all values greater than or equal to the median
    total = 0
    count = 0
    for num in sorted_numbers:
        if num >= median:
            total += num
            count += 1
    
    if count > 0:
        average = total / count
    else:
        average = None
    
    return median, average


# Test cases

# Test case 1: List with odd number of elements
numbers1 = [5, 3, 8, 2, 9]
median1, average1 = funcImp(numbers1)
print(f""Test case 1: {numbers1}"")
print(f""Median: {median1}, Average: {average1}"")

# Test case 2: List with even number of elements
numbers2 = [7, 4, 6, 9]
median2, average2 = funcImp(numbers2)
print(f""Test case 2: {numbers2}"")
print(f""Median: {median2}, Average: {average2}"")

# Test case 3: List with duplicate elements
numbers3 = [5, 3, 8, 5]
median3, average3 = funcImp(numbers3)
print(f""Test case 3: {numbers3}"")
print(f""Median: {median3}, Average: {average3}"")

# Test case 4: List with all elements less than the median
numbers4 = [1, 2, 3, 4]
median4, average4 = funcImp(numbers4)
print(f""Test case 4: {numbers4}"")
print(f""Median: {median4}, Average: {average4}"")

# Test case 5: List with all elements greater than or equal to the median
numbers5 = [6, 7, 8, 9]
median5, average5 = funcImp(numbers5)
print(f""Test case 5: {numbers5}"")
print(f""Median: {median5}, Average: {average5}"")

# Test case 6: Empty list
numbers6 = []
median6, average6 = funcImp(numbers6)
print(f""Test case 6: {numbers6}"")
print(f""Median: {median6}, Average: {average6}"")
```","[6, 7, 8, 9]","7.5, 8.0","7.5, 8.5",FAIL,FALSE,N/A
13,1,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst, window_size):
    """"""
    Calculate the moving average for each element in a given list.

    Args:
        lst (list): The input list.
        window_size (int): The size of the sliding window.

    Returns:
        list: A new list containing the moving averages.

    Raises:
        ValueError: If the window size is not positive or greater than the length of the input list.
    """"""
    if window_size <= 0 or window_size > len(lst):
        raise ValueError(""Window size must be positive and less than or equal to the length of the input list."")

    moving_averages = []
    for i in range(len(lst) - window_size + 1):
        window = lst[i:i+window_size]
        average = sum(window) / window_size
        moving_averages.append(average)

    return moving_averages
```","[1, 2, 3, 4, 5]","[2.0, 3.0, 4.0]","2.0, 3.0, 4.0",PASS,TRUE,N/A
13,2,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst, window_size):
    """"""
    Calculate the moving average for each element in a given list.

    Args:
        lst (list): The input list.
        window_size (int): The size of the sliding window.

    Returns:
        list: A new list containing the moving averages.

    Raises:
        ValueError: If the window size is not positive or greater than the length of the input list.
    """"""
    if window_size <= 0 or window_size > len(lst):
        raise ValueError(""Window size must be positive and less than or equal to the length of the input list."")

    moving_averages = []
    for i in range(len(lst) - window_size + 1):
        window = lst[i:i+window_size]
        average = sum(window) / window_size
        moving_averages.append(average)

    return moving_averages
```","[-1, -2, -3, -4, -5]","[-1.5, -2.5, -3.5, -4.5]","-1.5, -2.5, -3.5, -4.5",PASS,TRUE,N/A
13,3,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(lst, window_size):
    """"""
    Calculate the moving average for each element in a given list.

    Args:
        lst (list): The input list.
        window_size (int): The size of the sliding window.

    Returns:
        list: A new list containing the moving averages.

    Raises:
        ValueError: If the window size is not positive or greater than the length of the input list.
    """"""
    if window_size <= 0 or window_size > len(lst):
        raise ValueError(""Window size must be positive and less than or equal to the length of the input list."")

    moving_averages = []
    for i in range(len(lst) - window_size + 1):
        window = lst[i:i+window_size]
        average = sum(window) / window_size
        moving_averages.append(average)

    return moving_averages
```","[1, 2.5, 3, -4.5, 5]","[0.75, 0.25]","0.5, 1.5",FAIL,FALSE,N/A
14,1,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    n = len(arr)
    prefix_sum = 0
    result = []
    
    for i in range(n):
        prefix_sum += arr[i]
        result.append(prefix_sum / (i+1))
    
    return result
```

This function takes an array `arr` as input and returns a new array `result` where each element represents the running average up to the current position.

To test this function, you can use the following code:

```python
test_cases = [
    [1, 2, 3, 4, 5],
    [10, -5, 8, 3],
    [],
]

for test_case in test_cases:
    print(f""Input: {test_case}"")
    print(f""Output: {funcImp(test_case)}"")
    print()
```

This will output:

```
Input: [1, 2, 3, 4, 5]
Output: [1.0, 1.5, 2.0, 2.5, 3.0]

Input: [10, -5, 8, 3]
Output: [10.0, 2.5, 4.333333333333333, 6.5]

Input: []
Output: []
```","[1, 2, 3, 4, 5]","[1.0, 1.5, 2.0, 2.5, 3.0]","[1.0, 1.5, 2.0, 2.5, 3.0]",PASS,TRUE,N/A
14,2,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    n = len(arr)
    prefix_sum = 0
    result = []
    
    for i in range(n):
        prefix_sum += arr[i]
        result.append(prefix_sum / (i+1))
    
    return result
```

This function takes an array `arr` as input and returns a new array `result` where each element represents the running average up to the current position.

To test this function, you can use the following code:

```python
test_cases = [
    [1, 2, 3, 4, 5],
    [10, -5, 8, 3],
    [],
]

for test_case in test_cases:
    print(f""Input: {test_case}"")
    print(f""Output: {funcImp(test_case)}"")
    print()
```

This will output:

```
Input: [1, 2, 3, 4, 5]
Output: [1.0, 1.5, 2.0, 2.5, 3.0]

Input: [10, -5, 8, 3]
Output: [10.0, 2.5, 4.333333333333333, 6.5]

Input: []
Output: []
```","[10, -5, 8, 3]","[10.0, 2.5, 4.333333333333333, 4.0]","[10.0, 2.5, 4.333333333333333, 4.0]",PASS,TRUE,N/A
14,3,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    n = len(arr)
    prefix_sum = 0
    result = []
    
    for i in range(n):
        prefix_sum += arr[i]
        result.append(prefix_sum / (i+1))
    
    return result
```

This function takes an array `arr` as input and returns a new array `result` where each element represents the running average up to the current position.

To test this function, you can use the following code:

```python
test_cases = [
    [1, 2, 3, 4, 5],
    [10, -5, 8, 3],
    [],
]

for test_case in test_cases:
    print(f""Input: {test_case}"")
    print(f""Output: {funcImp(test_case)}"")
    print()
```

This will output:

```
Input: [1, 2, 3, 4, 5]
Output: [1.0, 1.5, 2.0, 2.5, 3.0]

Input: [10, -5, 8, 3]
Output: [10.0, 2.5, 4.333333333333333, 6.5]

Input: []
Output: []
```",[],[],[],PASS,TRUE,N/A
15,1,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",2,TRUE,TRUE,PASS,TRUE,N/A
15,2,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",3,TRUE,TRUE,PASS,TRUE,N/A
15,3,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",5,TRUE,TRUE,PASS,TRUE,N/A
15,4,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",7,TRUE,TRUE,PASS,TRUE,N/A
15,5,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",11,TRUE,TRUE,PASS,TRUE,N/A
15,6,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",13,TRUE,TRUE,PASS,TRUE,N/A
15,7,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",17,FALSE,TRUE,FAIL,FALSE,N/A
15,8,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",19,FALSE,TRUE,FAIL,FALSE,N/A
15,9,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",23,FALSE,TRUE,FAIL,FALSE,N/A
15,10,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",29,FALSE,TRUE,FAIL,FALSE,N/A
15,11,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",4,FALSE,FALSE,PASS,TRUE,N/A
15,12,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",6,FALSE,FALSE,PASS,TRUE,N/A
15,13,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",8,FALSE,FALSE,PASS,TRUE,N/A
15,14,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",9,FALSE,FALSE,PASS,TRUE,N/A
15,15,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",10,FALSE,FALSE,PASS,TRUE,N/A
15,16,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",12,FALSE,FALSE,PASS,TRUE,N/A
15,17,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime or not
def funcImp(num):
    # Check if the number is less than 2, which is not prime
    if num < 2:
        return False
    
    # Check for divisibility from 2 to the square root of the number
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    
    # If no divisor is found, the number is prime
    return True

# Test cases
test_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Prime numbers
test_cases += [4, 6, 8, 9, 10, 12, 14] # Non-prime numbers

# Execute test cases and print results
for num in test_cases:
    result = funcImp(num)
    print(f""{num} is prime: {result}"")
```",14,FALSE,FALSE,PASS,TRUE,N/A
16,1,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given input.
    
    Parameters:
        n (int): The input number.
        
    Returns:
        int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""
        Checks if a number is prime.
        
        Parameters:
            num (int): The number to check.
            
        Returns:
            bool: True if num is prime, False otherwise.
        """"""
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    # Increment n until we find a prime number
    while True:
        n += 1
        if is_prime(n):
            return n

# Test cases
test_cases = [10, 20, 30, 40, 50]

for test_case in test_cases:
    result = funcImp(test_case)
    print(f""The smallest prime number greater than {test_case} is {result}"")
```",n = 10,11,11,PASS,TRUE,N/A
16,2,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given input.
    
    Parameters:
        n (int): The input number.
        
    Returns:
        int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""
        Checks if a number is prime.
        
        Parameters:
            num (int): The number to check.
            
        Returns:
            bool: True if num is prime, False otherwise.
        """"""
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    # Increment n until we find a prime number
    while True:
        n += 1
        if is_prime(n):
            return n

# Test cases
test_cases = [10, 20, 30, 40, 50]

for test_case in test_cases:
    result = funcImp(test_case)
    print(f""The smallest prime number greater than {test_case} is {result}"")
```",n = 20,23,23,PASS,TRUE,N/A
16,3,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given input.
    
    Parameters:
        n (int): The input number.
        
    Returns:
        int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""
        Checks if a number is prime.
        
        Parameters:
            num (int): The number to check.
            
        Returns:
            bool: True if num is prime, False otherwise.
        """"""
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    # Increment n until we find a prime number
    while True:
        n += 1
        if is_prime(n):
            return n

# Test cases
test_cases = [10, 20, 30, 40, 50]

for test_case in test_cases:
    result = funcImp(test_case)
    print(f""The smallest prime number greater than {test_case} is {result}"")
```",n = 30,31,31,PASS,TRUE,N/A
16,4,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given input.
    
    Parameters:
        n (int): The input number.
        
    Returns:
        int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""
        Checks if a number is prime.
        
        Parameters:
            num (int): The number to check.
            
        Returns:
            bool: True if num is prime, False otherwise.
        """"""
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    # Increment n until we find a prime number
    while True:
        n += 1
        if is_prime(n):
            return n

# Test cases
test_cases = [10, 20, 30, 40, 50]

for test_case in test_cases:
    result = funcImp(test_case)
    print(f""The smallest prime number greater than {test_case} is {result}"")
```",n = 40,41,41,PASS,TRUE,N/A
16,5,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    """"""
    Returns the smallest prime number greater than a given input.
    
    Parameters:
        n (int): The input number.
        
    Returns:
        int: The smallest prime number greater than n.
    """"""
    
    def is_prime(num):
        """"""
        Checks if a number is prime.
        
        Parameters:
            num (int): The number to check.
            
        Returns:
            bool: True if num is prime, False otherwise.
        """"""
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    # Increment n until we find a prime number
    while True:
        n += 1
        if is_prime(n):
            return n

# Test cases
test_cases = [10, 20, 30, 40, 50]

for test_case in test_cases:
    result = funcImp(test_case)
    print(f""The smallest prime number greater than {test_case} is {result}"")
```",n = 50,53,53,PASS,TRUE,N/A
17,1,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to print all prime numbers between two given numbers.

    Parameters:
    start (int): The starting number.
    end (int): The ending number.

    Returns:
    None
    """"""

    # Iterate through each number in the range
    for num in range(start, end + 1):

        # Prime numbers are greater than 1
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                print(num)

# Test the function with different test cases

# Test case 1: start = 10, end = 20
print(""Prime numbers between 10 and 20:"")
funcImp(10, 20)
print()

# Test case 2: start = -5, end = 5
print(""Prime numbers between -5 and 5:"")
funcImp(-5, 5)
print()

# Test case 3: start = 50, end = 100
print(""Prime numbers between 50 and 100:"")
funcImp(50, 100)
```","start = 10, end = 20","11
13
17
19","11
13
17
19",PASS,TRUE,N/A
17,2,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to print all prime numbers between two given numbers.

    Parameters:
    start (int): The starting number.
    end (int): The ending number.

    Returns:
    None
    """"""

    # Iterate through each number in the range
    for num in range(start, end + 1):

        # Prime numbers are greater than 1
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                print(num)

# Test the function with different test cases

# Test case 1: start = 10, end = 20
print(""Prime numbers between 10 and 20:"")
funcImp(10, 20)
print()

# Test case 2: start = -5, end = 5
print(""Prime numbers between -5 and 5:"")
funcImp(-5, 5)
print()

# Test case 3: start = 50, end = 100
print(""Prime numbers between 50 and 100:"")
funcImp(50, 100)
```","start = -5, end = 5","2
3
5","2
3
5",PASS,TRUE,N/A
17,3,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to print all prime numbers between two given numbers.

    Parameters:
    start (int): The starting number.
    end (int): The ending number.

    Returns:
    None
    """"""

    # Iterate through each number in the range
    for num in range(start, end + 1):

        # Prime numbers are greater than 1
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                print(num)

# Test the function with different test cases

# Test case 1: start = 10, end = 20
print(""Prime numbers between 10 and 20:"")
funcImp(10, 20)
print()

# Test case 2: start = -5, end = 5
print(""Prime numbers between -5 and 5:"")
funcImp(-5, 5)
print()

# Test case 3: start = 50, end = 100
print(""Prime numbers between 50 and 100:"")
funcImp(50, 100)
```","start = 50, end = 100","53
59
61
67
71
73
79
83
89
97","53
59
61
67
71
73
79
83
89
97",PASS,TRUE,N/A
18,1,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to find the sum of all prime numbers within a given range.

    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.

    Returns:
    int: The sum of all prime numbers within the given range.
    """"""
    
    # Initialize variables
    primes = []
    
    # Iterate through each number in the range
    for num in range(start, end + 1):
        # Check if the number is greater than 1
        if num > 1:
            # Check if the number is divisible by any other number less than itself
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    
    # Calculate and return the sum of all prime numbers
    return sum(primes)


# Test cases

# Test case 1: Range from 1 to 10
start = 1
end = 10
expected_output = 17   # Prime numbers: [2, 3, 5, 7]
output = funcImp(start, end)
print(f""Test case 1 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 2: Range from -10 to -1
start = -10
end = -1
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 2 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 3: Range from 20 to 30
start = 20
end = 30
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 3 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 4: Range from 1 to 100
start = 1
end = 100
expected_output = 1060   # Sum of prime numbers from 1 to 100 is 1060
output = funcImp(start, end)
print(f""Test case 4 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 5: Range from -100 to -50
start = -100
end = -50
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 5 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

```","(1, 10)",17,17,PASS,TRUE,N/A
18,2,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to find the sum of all prime numbers within a given range.

    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.

    Returns:
    int: The sum of all prime numbers within the given range.
    """"""
    
    # Initialize variables
    primes = []
    
    # Iterate through each number in the range
    for num in range(start, end + 1):
        # Check if the number is greater than 1
        if num > 1:
            # Check if the number is divisible by any other number less than itself
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    
    # Calculate and return the sum of all prime numbers
    return sum(primes)


# Test cases

# Test case 1: Range from 1 to 10
start = 1
end = 10
expected_output = 17   # Prime numbers: [2, 3, 5, 7]
output = funcImp(start, end)
print(f""Test case 1 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 2: Range from -10 to -1
start = -10
end = -1
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 2 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 3: Range from 20 to 30
start = 20
end = 30
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 3 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 4: Range from 1 to 100
start = 1
end = 100
expected_output = 1060   # Sum of prime numbers from 1 to 100 is 1060
output = funcImp(start, end)
print(f""Test case 4 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 5: Range from -100 to -50
start = -100
end = -50
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 5 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

```","(-10, -1)",0,0,PASS,TRUE,N/A
18,3,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to find the sum of all prime numbers within a given range.

    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.

    Returns:
    int: The sum of all prime numbers within the given range.
    """"""
    
    # Initialize variables
    primes = []
    
    # Iterate through each number in the range
    for num in range(start, end + 1):
        # Check if the number is greater than 1
        if num > 1:
            # Check if the number is divisible by any other number less than itself
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    
    # Calculate and return the sum of all prime numbers
    return sum(primes)


# Test cases

# Test case 1: Range from 1 to 10
start = 1
end = 10
expected_output = 17   # Prime numbers: [2, 3, 5, 7]
output = funcImp(start, end)
print(f""Test case 1 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 2: Range from -10 to -1
start = -10
end = -1
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 2 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 3: Range from 20 to 30
start = 20
end = 30
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 3 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 4: Range from 1 to 100
start = 1
end = 100
expected_output = 1060   # Sum of prime numbers from 1 to 100 is 1060
output = funcImp(start, end)
print(f""Test case 4 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 5: Range from -100 to -50
start = -100
end = -50
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 5 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

```","(20, 30)",0,52,FAIL,FALSE,N/A
18,4,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to find the sum of all prime numbers within a given range.

    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.

    Returns:
    int: The sum of all prime numbers within the given range.
    """"""
    
    # Initialize variables
    primes = []
    
    # Iterate through each number in the range
    for num in range(start, end + 1):
        # Check if the number is greater than 1
        if num > 1:
            # Check if the number is divisible by any other number less than itself
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    
    # Calculate and return the sum of all prime numbers
    return sum(primes)


# Test cases

# Test case 1: Range from 1 to 10
start = 1
end = 10
expected_output = 17   # Prime numbers: [2, 3, 5, 7]
output = funcImp(start, end)
print(f""Test case 1 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 2: Range from -10 to -1
start = -10
end = -1
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 2 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 3: Range from 20 to 30
start = 20
end = 30
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 3 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 4: Range from 1 to 100
start = 1
end = 100
expected_output = 1060   # Sum of prime numbers from 1 to 100 is 1060
output = funcImp(start, end)
print(f""Test case 4 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 5: Range from -100 to -50
start = -100
end = -50
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 5 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

```","(1, 100)",1060,1060,PASS,TRUE,N/A
18,5,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    Function to find the sum of all prime numbers within a given range.

    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.

    Returns:
    int: The sum of all prime numbers within the given range.
    """"""
    
    # Initialize variables
    primes = []
    
    # Iterate through each number in the range
    for num in range(start, end + 1):
        # Check if the number is greater than 1
        if num > 1:
            # Check if the number is divisible by any other number less than itself
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    
    # Calculate and return the sum of all prime numbers
    return sum(primes)


# Test cases

# Test case 1: Range from 1 to 10
start = 1
end = 10
expected_output = 17   # Prime numbers: [2, 3, 5, 7]
output = funcImp(start, end)
print(f""Test case 1 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 2: Range from -10 to -1
start = -10
end = -1
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 2 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 3: Range from 20 to 30
start = 20
end = 30
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 3 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 4: Range from 1 to 100
start = 1
end = 100
expected_output = 1060   # Sum of prime numbers from 1 to 100 is 1060
output = funcImp(start, end)
print(f""Test case 4 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

# Test case 5: Range from -100 to -50
start = -100
end = -50
expected_output = 0   # No prime numbers in this range
output = funcImp(start, end)
print(f""Test case 5 - Expected output: {expected_output}, Output: {output}"")
assert output == expected_output

```","(-100, -50)",0,0,PASS,TRUE,N/A
19,1,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    # Check if n is less than 2
    if n < 2:
        return None
    
    # Divide n by 2 until it is no longer divisible by 2
    while n % 2 == 0:
        n //= 2
    
    # Check for factors starting from 3 up to the square root of n
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            n //= i
    
    # If n is still greater than 2, it is a prime factor itself
    if n > 2:
        return n
    
    # If no prime factors were found, return None
    return None

# Test cases
test_cases = [10, 21, 13195, -5, 0]

for test_case in test_cases:
    result = funcImp(test_case)
    
    print(f""Largest prime factor of {test_case}: {result}"")
```",10,10,5,FAIL,FALSE,N/A
19,2,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    # Check if n is less than 2
    if n < 2:
        return None
    
    # Divide n by 2 until it is no longer divisible by 2
    while n % 2 == 0:
        n //= 2
    
    # Check for factors starting from 3 up to the square root of n
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            n //= i
    
    # If n is still greater than 2, it is a prime factor itself
    if n > 2:
        return n
    
    # If no prime factors were found, return None
    return None

# Test cases
test_cases = [10, 21, 13195, -5, 0]

for test_case in test_cases:
    result = funcImp(test_case)
    
    print(f""Largest prime factor of {test_case}: {result}"")
```",21,21,7,FAIL,FALSE,N/A
19,3,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    # Check if n is less than 2
    if n < 2:
        return None
    
    # Divide n by 2 until it is no longer divisible by 2
    while n % 2 == 0:
        n //= 2
    
    # Check for factors starting from 3 up to the square root of n
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            n //= i
    
    # If n is still greater than 2, it is a prime factor itself
    if n > 2:
        return n
    
    # If no prime factors were found, return None
    return None

# Test cases
test_cases = [10, 21, 13195, -5, 0]

for test_case in test_cases:
    result = funcImp(test_case)
    
    print(f""Largest prime factor of {test_case}: {result}"")
```",13195,13195,,FAIL,FALSE,N/A
19,4,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    # Check if n is less than 2
    if n < 2:
        return None
    
    # Divide n by 2 until it is no longer divisible by 2
    while n % 2 == 0:
        n //= 2
    
    # Check for factors starting from 3 up to the square root of n
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            n //= i
    
    # If n is still greater than 2, it is a prime factor itself
    if n > 2:
        return n
    
    # If no prime factors were found, return None
    return None

# Test cases
test_cases = [10, 21, 13195, -5, 0]

for test_case in test_cases:
    result = funcImp(test_case)
    
    print(f""Largest prime factor of {test_case}: {result}"")
```",-5,,,PASS,TRUE,N/A
19,5,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import math

def funcImp(n):
    # Check if n is less than 2
    if n < 2:
        return None
    
    # Divide n by 2 until it is no longer divisible by 2
    while n % 2 == 0:
        n //= 2
    
    # Check for factors starting from 3 up to the square root of n
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            n //= i
    
    # If n is still greater than 2, it is a prime factor itself
    if n > 2:
        return n
    
    # If no prime factors were found, return None
    return None

# Test cases
test_cases = [10, 21, 13195, -5, 0]

for test_case in test_cases:
    result = funcImp(test_case)
    
    print(f""Largest prime factor of {test_case}: {result}"")
```",0,,,PASS,TRUE,N/A
20,1,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Function to check if a number is semiprime
def is_semiprime(n):
    # Check all possible factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        # If i is a factor of n, check if both i and n/i are prime numbers
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True
    return False

# Test cases
test_cases = [15, 22, 25, 30, 33]

for num in test_cases:
    result = is_semiprime(num)
    print(f""{num} is semiprime: {result}"")
```",15,TRUE,TRUE,PASS,TRUE,N/A
20,2,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Function to check if a number is semiprime
def is_semiprime(n):
    # Check all possible factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        # If i is a factor of n, check if both i and n/i are prime numbers
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True
    return False

# Test cases
test_cases = [15, 22, 25, 30, 33]

for num in test_cases:
    result = is_semiprime(num)
    print(f""{num} is semiprime: {result}"")
```",22,TRUE,TRUE,PASS,TRUE,N/A
20,3,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Function to check if a number is semiprime
def is_semiprime(n):
    # Check all possible factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        # If i is a factor of n, check if both i and n/i are prime numbers
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True
    return False

# Test cases
test_cases = [15, 22, 25, 30, 33]

for num in test_cases:
    result = is_semiprime(num)
    print(f""{num} is semiprime: {result}"")
```",25,FALSE,TRUE,FAIL,FALSE,N/A
20,4,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Function to check if a number is semiprime
def is_semiprime(n):
    # Check all possible factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        # If i is a factor of n, check if both i and n/i are prime numbers
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True
    return False

# Test cases
test_cases = [15, 22, 25, 30, 33]

for num in test_cases:
    result = is_semiprime(num)
    print(f""{num} is semiprime: {result}"")
```",30,FALSE,FALSE,PASS,TRUE,N/A
20,5,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Function to check if a number is semiprime
def is_semiprime(n):
    # Check all possible factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        # If i is a factor of n, check if both i and n/i are prime numbers
        if n % i == 0 and is_prime(i) and is_prime(n // i):
            return True
    return False

# Test cases
test_cases = [15, 22, 25, 30, 33]

for num in test_cases:
    result = is_semiprime(num)
    print(f""{num} is semiprime: {result}"")
```",33,FALSE,TRUE,FAIL,FALSE,N/A
21,1,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def bubble_sort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n-1):
        
        # Last i elements are already in place
        for j in range(0, n-i-1):
            
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test the function with some sample inputs
arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr))  # Output: [11, 12, 22, 25, 34, 64, 90]

arr = [5, -2, -9, -7]
print(bubble_sort(arr))  # Output: [-9, -7, -2, 5]

arr = ['apple', 'banana', 'cherry', 'date']
print(bubble_sort(arr))  # Output: ['apple', 'banana', 'cherry', 'date']

```","[64, 34, 25, 12, 22, 11, 90]","[11, 12, 22, 25, 34, 64, 90]","[11, 12, 22, 25, 34, 64, 90]",PASS,TRUE,N/A
21,2,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def bubble_sort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n-1):
        
        # Last i elements are already in place
        for j in range(0, n-i-1):
            
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test the function with some sample inputs
arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr))  # Output: [11, 12, 22, 25, 34, 64, 90]

arr = [5, -2, -9, -7]
print(bubble_sort(arr))  # Output: [-9, -7, -2, 5]

arr = ['apple', 'banana', 'cherry', 'date']
print(bubble_sort(arr))  # Output: ['apple', 'banana', 'cherry', 'date']

```","[5, -2, -9, -7]","[-9, -7, -2, 5]","[-9, -7, -2, 5]",PASS,TRUE,N/A
21,3,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def bubble_sort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n-1):
        
        # Last i elements are already in place
        for j in range(0, n-i-1):
            
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test the function with some sample inputs
arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr))  # Output: [11, 12, 22, 25, 34, 64, 90]

arr = [5, -2, -9, -7]
print(bubble_sort(arr))  # Output: [-9, -7, -2, 5]

arr = ['apple', 'banana', 'cherry', 'date']
print(bubble_sort(arr))  # Output: ['apple', 'banana', 'cherry', 'date']

```","['apple', 'banana', 'cherry', 'date']","['apple', 'banana', 'cherry', 'date']","['apple', 'banana', 'cherry', 'date']",PASS,TRUE,N/A
22,1,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm and calculate its average case time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def insertion_sort(arr):
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        # Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position
        while j >= 0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key

# Test the function with some sample inputs
arr = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(arr)
print(""Sorted array:"", arr)
```","[64, 34, 25, 12, 22, 11, 90]","[11, 12, 22, 25, 34, 64, 90]","[11, 12, 22, 25, 34, 64, 90]",PASS,TRUE,N/A
23,1,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Sort the array in lexicographical order using the sorted() function
    sorted_arr = sorted(arr)
    
    return sorted_arr

# Test cases
test_case_1 = [""apple"", ""banana"", ""cherry""]
test_case_2 = [""cat"", ""dog"", ""elephant""]
test_case_3 = [""123"", ""456"", ""789""]
test_case_4 = [""!"", ""@"", ""#""]

# Execute test cases
result_1 = funcImp(test_case_1)
result_2 = funcImp(test_case_2)
result_3 = funcImp(test_case_3)
result_4 = funcImp(test_case_4)

# Print results
print(result_1)  # Output: ['apple', 'banana', 'cherry']
print(result_2)  # Output: ['cat', 'dog', 'elephant']
print(result_3)  # Output: ['123', '456', '789']
print(result_4)  # Output: ['!', '@', '#']
```","['apple', 'banana', 'cherry']","['apple', 'banana', 'cherry']","['apple', 'banana', 'cherry']",PASS,TRUE,N/A
23,2,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Sort the array in lexicographical order using the sorted() function
    sorted_arr = sorted(arr)
    
    return sorted_arr

# Test cases
test_case_1 = [""apple"", ""banana"", ""cherry""]
test_case_2 = [""cat"", ""dog"", ""elephant""]
test_case_3 = [""123"", ""456"", ""789""]
test_case_4 = [""!"", ""@"", ""#""]

# Execute test cases
result_1 = funcImp(test_case_1)
result_2 = funcImp(test_case_2)
result_3 = funcImp(test_case_3)
result_4 = funcImp(test_case_4)

# Print results
print(result_1)  # Output: ['apple', 'banana', 'cherry']
print(result_2)  # Output: ['cat', 'dog', 'elephant']
print(result_3)  # Output: ['123', '456', '789']
print(result_4)  # Output: ['!', '@', '#']
```","['cat', 'dog', 'elephant']","['cat', 'dog', 'elephant']","['cat', 'dog', 'elephant']",PASS,TRUE,N/A
23,3,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Sort the array in lexicographical order using the sorted() function
    sorted_arr = sorted(arr)
    
    return sorted_arr

# Test cases
test_case_1 = [""apple"", ""banana"", ""cherry""]
test_case_2 = [""cat"", ""dog"", ""elephant""]
test_case_3 = [""123"", ""456"", ""789""]
test_case_4 = [""!"", ""@"", ""#""]

# Execute test cases
result_1 = funcImp(test_case_1)
result_2 = funcImp(test_case_2)
result_3 = funcImp(test_case_3)
result_4 = funcImp(test_case_4)

# Print results
print(result_1)  # Output: ['apple', 'banana', 'cherry']
print(result_2)  # Output: ['cat', 'dog', 'elephant']
print(result_3)  # Output: ['123', '456', '789']
print(result_4)  # Output: ['!', '@', '#']
```","['123', '456', '789']","['123', '456', '789']","['123', '456', '789']",PASS,TRUE,N/A
23,4,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Sort the array in lexicographical order using the sorted() function
    sorted_arr = sorted(arr)
    
    return sorted_arr

# Test cases
test_case_1 = [""apple"", ""banana"", ""cherry""]
test_case_2 = [""cat"", ""dog"", ""elephant""]
test_case_3 = [""123"", ""456"", ""789""]
test_case_4 = [""!"", ""@"", ""#""]

# Execute test cases
result_1 = funcImp(test_case_1)
result_2 = funcImp(test_case_2)
result_3 = funcImp(test_case_3)
result_4 = funcImp(test_case_4)

# Print results
print(result_1)  # Output: ['apple', 'banana', 'cherry']
print(result_2)  # Output: ['cat', 'dog', 'elephant']
print(result_3)  # Output: ['123', '456', '789']
print(result_4)  # Output: ['!', '@', '#']
```","['!', '@', '#']","['!', '@', '#']","['!', '#', '@']",FAIL,FALSE,N/A
24,1,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Implementation of Selection Sort algorithm

def selection_sort(arr):
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases
test_cases = [
    [4, 2, 7, 1, 5],
    [9, 3, 6, 2],
    [],
    [1],
    [5, 4, 3, 2, 1],
]

# Execute test cases
for i, test_case in enumerate(test_cases):
    result = selection_sort(test_case)
    print(f""Test case {i+1}: {result}"")
```","[4, 2, 7, 1, 5]","[1, 2, 4, 5, 7]","[1, 2, 4, 5, 7]",PASS,TRUE,N/A
24,2,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Implementation of Selection Sort algorithm

def selection_sort(arr):
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases
test_cases = [
    [4, 2, 7, 1, 5],
    [9, 3, 6, 2],
    [],
    [1],
    [5, 4, 3, 2, 1],
]

# Execute test cases
for i, test_case in enumerate(test_cases):
    result = selection_sort(test_case)
    print(f""Test case {i+1}: {result}"")
```","[9, 3, 6, 2]","[2, 3, 6, 9]","[2, 3, 6, 9]",PASS,TRUE,N/A
24,3,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Implementation of Selection Sort algorithm

def selection_sort(arr):
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases
test_cases = [
    [4, 2, 7, 1, 5],
    [9, 3, 6, 2],
    [],
    [1],
    [5, 4, 3, 2, 1],
]

# Execute test cases
for i, test_case in enumerate(test_cases):
    result = selection_sort(test_case)
    print(f""Test case {i+1}: {result}"")
```",[],[],[],PASS,TRUE,N/A
24,4,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Implementation of Selection Sort algorithm

def selection_sort(arr):
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases
test_cases = [
    [4, 2, 7, 1, 5],
    [9, 3, 6, 2],
    [],
    [1],
    [5, 4, 3, 2, 1],
]

# Execute test cases
for i, test_case in enumerate(test_cases):
    result = selection_sort(test_case)
    print(f""Test case {i+1}: {result}"")
```",[1],[1],[1],PASS,TRUE,N/A
24,5,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Implementation of Selection Sort algorithm

def selection_sort(arr):
    # Traverse through all array elements
    for i in range(len(arr)):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Test cases
test_cases = [
    [4, 2, 7, 1, 5],
    [9, 3, 6, 2],
    [],
    [1],
    [5, 4, 3, 2, 1],
]

# Execute test cases
for i, test_case in enumerate(test_cases):
    result = selection_sort(test_case)
    print(f""Test case {i+1}: {result}"")
```","[5, 4, 3, 2, 1]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,N/A
25,1,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Node class to represent a node in the linked list
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Function to merge two sorted linked lists and return the merged list
def merge_lists(head1, head2):
    # Base cases: if either of the lists is empty, return the other list
    if head1 is None:
        return head2
    if head2 is None:
        return head1
    
    # Initialize a dummy node as the new head of the merged list
    dummy = Node(0)
    
    # Pointer to traverse the merged list
    curr = dummy
    
    # Traverse both lists and compare their nodes to merge them in sorted order
    while head1 and head2:
        if head1.data <= head2.data:
            curr.next = head1
            head1 = head1.next
        else:
            curr.next = head2
            head2 = head2.next
        
        curr = curr.next
    
    # Append any remaining nodes from either of the lists to the merged list
    if head1:
        curr.next = head1
    if head2:
        curr.next = head2
    
    # Return the new merged list (excluding the dummy node)
    return dummy.next

# Function to split a linked list into two halves using slow-fast pointer technique
def split_list(head):
    slow_ptr = fast_ptr = prev_slow_ptr = None
    
    # Base case: if there are 0 or 1 nodes in the list, no need to split further
    if not head or not head.next:
        return (head, None)
    
    slow_ptr = fast_ptr = prev_slow_ptr = head
    
    while fast_ptr and fast_ptr.next:
        prev_slow_ptr = slow_ptr
        slow_ptr = slow_ptr.next
        fast_ptr = fast_ptr.next.next
    
    # Split the list by setting the next pointer of the previous node to None
    prev_slow_ptr.next = None
    
    # Return the two halves of the list
    return (head, slow_ptr)

# Function to perform Merge Sort on a linked list
def merge_sort(head):
    # Base case: if there are 0 or 1 nodes in the list, it is already sorted
    if not head or not head.next:
        return head
    
    # Split the list into two halves using split_list function
    left_half, right_half = split_list(head)
    
    # Recursively sort both halves of the list
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    
    # Merge the sorted halves using merge_lists function and return the result
    return merge_lists(left_half, right_half)

# Test cases

# Create a sample linked list: 4 -> 2 -> 1 -> 3 -> None
head = Node(4)
head.next = Node(2)
head.next.next = Node(1)
head.next.next.next = Node(3)

# Sort the linked list using Merge Sort algorithm
sorted_head = merge_sort(head)

# Print the sorted linked list: 1 -> 2 -> 3 -> 4 -> None
curr_node = sorted_head
while curr_node:
    print(curr_node.data, end="" "")
    curr_node = curr_node.next

```",4 -> 2 -> 1 -> 3,1 -> 2 -> 3 -> 4,1 -> 2 -> 3 -> 4,PASS,TRUE,N/A
26,1,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def countingSort(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1

    for i in range(1, 10):
        count[i] += count[i - 1]

    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    for i in range(n):
        arr[i] = output[i]


def radixSort(arr):
    max_value = max(arr)

    exp = 1
    while max_value // exp > 0:
        countingSort(arr, exp)
        exp *= 10


# Test the function with some sample inputs
arr = [170, 45, 75, 90, 802, 24, 2, 66]
radixSort(arr)
print(""Sorted array:"", arr)
```","[170,45,75,90,802,24,2,66]","[2, 24, 45, 66, 75, 90, 170, 802]","[2, 24, 45, 66, 75, 90, 170, 802]",PASS,TRUE,N/A
27,1,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Step 1: Find the maximum element in the array
    max_element = max(arr)

    # Step 2: Create a count array to store the frequency of each element
    count = [0] * (max_element + 1)
    for num in arr:
        count[num] += 1

    # Step 3: Modify the count array to store the cumulative sum of frequencies
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # Step 4: Create a sorted array using the count array
    sorted_arr = [0] * len(arr)
    for num in arr:
        sorted_arr[count[num] - 1] = num
        count[num] -= 1

    return sorted_arr
```

To test this function, you can use the following code:

```python
# Test case 1: Array with duplicate elements
arr = [3, 2, 4, 2, 5, 4, 3]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [2, 2, 3, 3, 4, 4, 5]

# Test case 2: Array with all elements being duplicates
arr = [5, 5, 5, 5]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [5, 5, 5, 5]

# Test case : Empty array
arr = []
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: []

# Test case : Array with no duplicates
arr = [9,8 ,7 ,6 ,5 ,4 ,3 ,2, 1]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```","[3, 2, 4, 2, 5, 4, 3]","[2, 2, 3, 3, 4, 4, 5]","[2, 2, 3, 3, 4, 4, 5]",PASS,TRUE,N/A
27,2,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Step 1: Find the maximum element in the array
    max_element = max(arr)

    # Step 2: Create a count array to store the frequency of each element
    count = [0] * (max_element + 1)
    for num in arr:
        count[num] += 1

    # Step 3: Modify the count array to store the cumulative sum of frequencies
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # Step 4: Create a sorted array using the count array
    sorted_arr = [0] * len(arr)
    for num in arr:
        sorted_arr[count[num] - 1] = num
        count[num] -= 1

    return sorted_arr
```

To test this function, you can use the following code:

```python
# Test case 1: Array with duplicate elements
arr = [3, 2, 4, 2, 5, 4, 3]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [2, 2, 3, 3, 4, 4, 5]

# Test case 2: Array with all elements being duplicates
arr = [5, 5, 5, 5]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [5, 5, 5, 5]

# Test case : Empty array
arr = []
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: []

# Test case : Array with no duplicates
arr = [9,8 ,7 ,6 ,5 ,4 ,3 ,2, 1]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```","[5, 5, 5, 5]","[5, 5, 5, 5]","[5, 5, 5, 5]",PASS,TRUE,N/A
27,3,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Step 1: Find the maximum element in the array
    max_element = max(arr)

    # Step 2: Create a count array to store the frequency of each element
    count = [0] * (max_element + 1)
    for num in arr:
        count[num] += 1

    # Step 3: Modify the count array to store the cumulative sum of frequencies
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # Step 4: Create a sorted array using the count array
    sorted_arr = [0] * len(arr)
    for num in arr:
        sorted_arr[count[num] - 1] = num
        count[num] -= 1

    return sorted_arr
```

To test this function, you can use the following code:

```python
# Test case 1: Array with duplicate elements
arr = [3, 2, 4, 2, 5, 4, 3]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [2, 2, 3, 3, 4, 4, 5]

# Test case 2: Array with all elements being duplicates
arr = [5, 5, 5, 5]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [5, 5, 5, 5]

# Test case : Empty array
arr = []
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: []

# Test case : Array with no duplicates
arr = [9,8 ,7 ,6 ,5 ,4 ,3 ,2, 1]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```",[],[],,ERROR,FALSE,max() arg is an empty sequence
27,4,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Step 1: Find the maximum element in the array
    max_element = max(arr)

    # Step 2: Create a count array to store the frequency of each element
    count = [0] * (max_element + 1)
    for num in arr:
        count[num] += 1

    # Step 3: Modify the count array to store the cumulative sum of frequencies
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # Step 4: Create a sorted array using the count array
    sorted_arr = [0] * len(arr)
    for num in arr:
        sorted_arr[count[num] - 1] = num
        count[num] -= 1

    return sorted_arr
```

To test this function, you can use the following code:

```python
# Test case 1: Array with duplicate elements
arr = [3, 2, 4, 2, 5, 4, 3]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [2, 2, 3, 3, 4, 4, 5]

# Test case 2: Array with all elements being duplicates
arr = [5, 5, 5, 5]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [5, 5, 5, 5]

# Test case : Empty array
arr = []
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: []

# Test case : Array with no duplicates
arr = [9,8 ,7 ,6 ,5 ,4 ,3 ,2, 1]
sorted_arr = funcImp(arr)
print(sorted_arr)   # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```","[9, 8, 7, 6, 5, 4, 3, 2, 1]","[1, 2, 3, 4, 5, 6, 7, 8, 9]","[1, 2, 3, 4, 5, 6, 7, 8, 9]",PASS,TRUE,max() arg is an empty sequence
28,1,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# Test the function with some sample inputs
arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)
print(""Sorted array is:"")
for i in range(len(arr)):
    print(""%d"" %arr[i])
```","[12, 11, 13, 5, 6, 7]","[5, 6, 7, 11, 12, 13]","[5, 6, 7, 11, 12, 13]",PASS,TRUE,N/A
29,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    # Create a queue to store the nodes to be visited
    queue = deque()
    # Enqueue the start node and mark it as visited
    queue.append((start, [start]))
    visited = set([start])

    while queue:
        # Dequeue a node from the front of the queue
        node, path = queue.popleft()

        # Check if we have reached the end node
        if node == end:
            return path

        # Visit all adjacent nodes of the current node
        for neighbor in graph[node]:
            if neighbor not in visited:
                # Enqueue the neighbor and update its path
                queue.append((neighbor, path + [neighbor]))
                visited.add(neighbor)

    # If no path is found, return None
    return None

# Test case 1: Find shortest path between nodes A and D in a graph
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
start_node = 'A'
end_node = 'D'
print(funcImp(graph, start_node, end_node))  # Output: ['A', 'C', 'D']

# Test case 2: Find shortest path between nodes X and Y in a graph with multiple paths
graph = {
    'X': ['Y', 'Z'],
    'Y': ['X', 'Z'],
    'Z': ['X', 'Y']
}
start_node = 'X'
end_node = 'Y'
print(funcImp(graph, start_node, end_node))  # Output: ['X', 'Y']

# Test case 3: Find shortest path between nodes P and Q in a graph with no path
graph = {
    'P': ['Q'],
    'Q': []
}
start_node = 'P'
end_node = 'Q'
print(funcImp(graph, start_node, end_node))  # Output: None
```","graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
start_node = 'A'
end_node = 'D'","['A', 'C', 'D']","['A', 'B', 'D']",FAIL,FALSE,N/A
29,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    # Create a queue to store the nodes to be visited
    queue = deque()
    # Enqueue the start node and mark it as visited
    queue.append((start, [start]))
    visited = set([start])

    while queue:
        # Dequeue a node from the front of the queue
        node, path = queue.popleft()

        # Check if we have reached the end node
        if node == end:
            return path

        # Visit all adjacent nodes of the current node
        for neighbor in graph[node]:
            if neighbor not in visited:
                # Enqueue the neighbor and update its path
                queue.append((neighbor, path + [neighbor]))
                visited.add(neighbor)

    # If no path is found, return None
    return None

# Test case 1: Find shortest path between nodes A and D in a graph
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
start_node = 'A'
end_node = 'D'
print(funcImp(graph, start_node, end_node))  # Output: ['A', 'C', 'D']

# Test case 2: Find shortest path between nodes X and Y in a graph with multiple paths
graph = {
    'X': ['Y', 'Z'],
    'Y': ['X', 'Z'],
    'Z': ['X', 'Y']
}
start_node = 'X'
end_node = 'Y'
print(funcImp(graph, start_node, end_node))  # Output: ['X', 'Y']

# Test case 3: Find shortest path between nodes P and Q in a graph with no path
graph = {
    'P': ['Q'],
    'Q': []
}
start_node = 'P'
end_node = 'Q'
print(funcImp(graph, start_node, end_node))  # Output: None
```","graph = {
    'X': ['Y', 'Z'],
    'Y': ['X', 'Z'],
    'Z': ['X', 'Y']
}
start_node = 'X'
end_node = 'Y'","['X', 'Y']","['X', 'Y']",PASS,TRUE,N/A
29,3,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    # Create a queue to store the nodes to be visited
    queue = deque()
    # Enqueue the start node and mark it as visited
    queue.append((start, [start]))
    visited = set([start])

    while queue:
        # Dequeue a node from the front of the queue
        node, path = queue.popleft()

        # Check if we have reached the end node
        if node == end:
            return path

        # Visit all adjacent nodes of the current node
        for neighbor in graph[node]:
            if neighbor not in visited:
                # Enqueue the neighbor and update its path
                queue.append((neighbor, path + [neighbor]))
                visited.add(neighbor)

    # If no path is found, return None
    return None

# Test case 1: Find shortest path between nodes A and D in a graph
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
start_node = 'A'
end_node = 'D'
print(funcImp(graph, start_node, end_node))  # Output: ['A', 'C', 'D']

# Test case 2: Find shortest path between nodes X and Y in a graph with multiple paths
graph = {
    'X': ['Y', 'Z'],
    'Y': ['X', 'Z'],
    'Z': ['X', 'Y']
}
start_node = 'X'
end_node = 'Y'
print(funcImp(graph, start_node, end_node))  # Output: ['X', 'Y']

# Test case 3: Find shortest path between nodes P and Q in a graph with no path
graph = {
    'P': ['Q'],
    'Q': []
}
start_node = 'P'
end_node = 'Q'
print(funcImp(graph, start_node, end_node))  # Output: None
```","graph = {
    'P': ['Q'],
    'Q': []
}
start_node = 'P'
end_node = 'Q'",None,"['P', 'Q']",FAIL,FALSE,N/A
30,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a set to keep track of visited nodes
    visited = set()

    # Create a set to keep track of nodes in the current path
    path = set()

    # Define a helper function to perform depth-first search
    def dfs(node):
        # Add the current node to the visited and path sets
        visited.add(node)
        path.add(node)

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            # If the neighbor has not been visited, recursively call dfs on it
            if neighbor not in visited:
                if dfs(neighbor):
                    return True

            # If the neighbor is already in the path, there is a cycle
            elif neighbor in path:
                return True

        # Remove the current node from the path set before returning
        path.remove(node)

        return False

    # Iterate over all nodes in the graph and perform dfs on each unvisited node
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases
graph1 = {
    'A': ['B', 'C'],
    'B': ['C'],
    'C': ['D'],
    'D': []
}
print(funcImp(graph1))  # False

graph2 = {
    'A': ['B', 'C'],
    'B': ['C', 'D'],
    'C': [],
    'D': ['A']
}
print(funcImp(graph2))  # True

graph3 = {
    'A': ['B', 'C'],
    'B': ['C', 'D'],
    'C': [],
    'D': []
}
print(funcImp(graph3))  # False
```","{'A': ['B', 'C'], 'B': ['C'], 'C': ['D'], 'D': []}",FALSE,FALSE,PASS,TRUE,N/A
30,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a set to keep track of visited nodes
    visited = set()

    # Create a set to keep track of nodes in the current path
    path = set()

    # Define a helper function to perform depth-first search
    def dfs(node):
        # Add the current node to the visited and path sets
        visited.add(node)
        path.add(node)

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            # If the neighbor has not been visited, recursively call dfs on it
            if neighbor not in visited:
                if dfs(neighbor):
                    return True

            # If the neighbor is already in the path, there is a cycle
            elif neighbor in path:
                return True

        # Remove the current node from the path set before returning
        path.remove(node)

        return False

    # Iterate over all nodes in the graph and perform dfs on each unvisited node
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases
graph1 = {
    'A': ['B', 'C'],
    'B': ['C'],
    'C': ['D'],
    'D': []
}
print(funcImp(graph1))  # False

graph2 = {
    'A': ['B', 'C'],
    'B': ['C', 'D'],
    'C': [],
    'D': ['A']
}
print(funcImp(graph2))  # True

graph3 = {
    'A': ['B', 'C'],
    'B': ['C', 'D'],
    'C': [],
    'D': []
}
print(funcImp(graph3))  # False
```","{'A': ['B', 'C'], 'B': ['C', 'D'], 'C': [], 'D': ['A']}",TRUE,TRUE,PASS,TRUE,N/A
30,3,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a set to keep track of visited nodes
    visited = set()

    # Create a set to keep track of nodes in the current path
    path = set()

    # Define a helper function to perform depth-first search
    def dfs(node):
        # Add the current node to the visited and path sets
        visited.add(node)
        path.add(node)

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            # If the neighbor has not been visited, recursively call dfs on it
            if neighbor not in visited:
                if dfs(neighbor):
                    return True

            # If the neighbor is already in the path, there is a cycle
            elif neighbor in path:
                return True

        # Remove the current node from the path set before returning
        path.remove(node)

        return False

    # Iterate over all nodes in the graph and perform dfs on each unvisited node
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases
graph1 = {
    'A': ['B', 'C'],
    'B': ['C'],
    'C': ['D'],
    'D': []
}
print(funcImp(graph1))  # False

graph2 = {
    'A': ['B', 'C'],
    'B': ['C', 'D'],
    'C': [],
    'D': ['A']
}
print(funcImp(graph2))  # True

graph3 = {
    'A': ['B', 'C'],
    'B': ['C', 'D'],
    'C': [],
    'D': []
}
print(funcImp(graph3))  # False
```","{'A': ['B', 'C'], 'B': ['C', 'D'], 'C': [], 'D': []}",FALSE,FALSE,PASS,TRUE,N/A
31,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import sys

def dijkstra(graph, source):
    # Initialize distances and visited array
    distances = {node: sys.maxsize for node in graph}
    distances[source] = 0
    visited = set()

    while len(visited) < len(graph):
        # Find the node with the minimum distance
        min_distance = sys.maxsize
        min_node = None
        for node in graph:
            if node not in visited and distances[node] < min_distance:
                min_distance = distances[node]
                min_node = node

        # Mark the current node as visited
        visited.add(min_node)

        # Update the distances of adjacent nodes
        for neighbor, weight in graph[min_node].items():
            new_distance = distances[min_node] + weight
            if new_distance < distances[neighbor]:
                distances[neighbor] = new_distance

    return distances


# Test case
graph = {
    'A': {'B': 5, 'C': 2},
    'B': {'A': 5, 'D': 1},
    'C': {'A': 2, 'D': 6},
    'D': {'B': 1, 'C': 6}
}

source_node = 'A'
distances = dijkstra(graph, source_node)
print(distances)
```","graph = {
    'A': {'B': 5, 'C': 2},
    'B': {'A': 5, 'D': 1},
    'C': {'A': 2, 'D': 6},
    'D': {'B': 1, 'C': 6}
}

source_node = 'A'","{'A': 0, 'B': 5, 'C': 2, 'D': 6}","{'A': 0, 'B': 5, 'C': 2, 'D': 6}",PASS,TRUE,N/A
32,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a set to keep track of visited nodes
    visited = set()

    # Define a helper function to perform depth-first search
    def dfs(node):
        # Mark the current node as visited
        visited.add(node)

        # Recursively visit all adjacent nodes that have not been visited yet
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)

    # Start the depth-first search from an arbitrary node
    start_node = next(iter(graph))
    dfs(start_node)

    # Check if all nodes have been visited
    return len(visited) == len(graph)


# Test the function with some sample graphs

# Graph 1: Connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'C'],
    'C': ['A', 'B']
}
print(funcImp(graph1))  # Output: True

# Graph 2: Disconnected graph
graph2 = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A'],
    'D': []
}
print(funcImp(graph2))  # Output: False

# Graph 3: Empty graph (no nodes)
graph3 = {}
print(funcImp(graph3))  # Output: True

# Graph 4: Single node graph
graph4 = {'A': []}
print(funcImp(graph4))  # Output: True

```","graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'C'],
    'C': ['A', 'B']
}",TRUE,TRUE,PASS,TRUE,N/A
32,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a set to keep track of visited nodes
    visited = set()

    # Define a helper function to perform depth-first search
    def dfs(node):
        # Mark the current node as visited
        visited.add(node)

        # Recursively visit all adjacent nodes that have not been visited yet
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)

    # Start the depth-first search from an arbitrary node
    start_node = next(iter(graph))
    dfs(start_node)

    # Check if all nodes have been visited
    return len(visited) == len(graph)


# Test the function with some sample graphs

# Graph 1: Connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'C'],
    'C': ['A', 'B']
}
print(funcImp(graph1))  # Output: True

# Graph 2: Disconnected graph
graph2 = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A'],
    'D': []
}
print(funcImp(graph2))  # Output: False

# Graph 3: Empty graph (no nodes)
graph3 = {}
print(funcImp(graph3))  # Output: True

# Graph 4: Single node graph
graph4 = {'A': []}
print(funcImp(graph4))  # Output: True

```","# Graph 2: Disconnected graph
graph2 = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A'],
    'D': []
}",FALSE,FALSE,PASS,TRUE,N/A
32,3,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a set to keep track of visited nodes
    visited = set()

    # Define a helper function to perform depth-first search
    def dfs(node):
        # Mark the current node as visited
        visited.add(node)

        # Recursively visit all adjacent nodes that have not been visited yet
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)

    # Start the depth-first search from an arbitrary node
    start_node = next(iter(graph))
    dfs(start_node)

    # Check if all nodes have been visited
    return len(visited) == len(graph)


# Test the function with some sample graphs

# Graph 1: Connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'C'],
    'C': ['A', 'B']
}
print(funcImp(graph1))  # Output: True

# Graph 2: Disconnected graph
graph2 = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A'],
    'D': []
}
print(funcImp(graph2))  # Output: False

# Graph 3: Empty graph (no nodes)
graph3 = {}
print(funcImp(graph3))  # Output: True

# Graph 4: Single node graph
graph4 = {'A': []}
print(funcImp(graph4))  # Output: True

```","# Graph 3: Empty graph (no nodes)
graph3 = {}",TRUE,,FAIL,FALSE,start_node = next(iter(graph))
32,4,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a set to keep track of visited nodes
    visited = set()

    # Define a helper function to perform depth-first search
    def dfs(node):
        # Mark the current node as visited
        visited.add(node)

        # Recursively visit all adjacent nodes that have not been visited yet
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)

    # Start the depth-first search from an arbitrary node
    start_node = next(iter(graph))
    dfs(start_node)

    # Check if all nodes have been visited
    return len(visited) == len(graph)


# Test the function with some sample graphs

# Graph 1: Connected graph
graph1 = {
    'A': ['B', 'C'],
    'B': ['A', 'C'],
    'C': ['A', 'B']
}
print(funcImp(graph1))  # Output: True

# Graph 2: Disconnected graph
graph2 = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A'],
    'D': []
}
print(funcImp(graph2))  # Output: False

# Graph 3: Empty graph (no nodes)
graph3 = {}
print(funcImp(graph3))  # Output: True

# Graph 4: Single node graph
graph4 = {'A': []}
print(funcImp(graph4))  # Output: True

```","# Graph 4: Single node graph
graph4 = {'A': []}",TRUE,TRUE,PASS,TRUE,N/A
33,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def topological_sort(graph):
    # Create a visited list to keep track of visited nodes
    visited = set()
    # Create a stack to store the sorted nodes
    stack = []

    def dfs(node):
        # Mark the current node as visited
        visited.add(node)
        # Visit all the neighbors of the current node
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
        # Add the current node to the stack after visiting all its neighbors
        stack.append(node)

    # Perform DFS on each unvisited node in the graph
    for node in graph:
        if node not in visited:
            dfs(node)

    # Return the reversed order of nodes in the stack to get the topological sort
    return stack[::-1]
```

To test this function, you can create a directed acyclic graph and pass it to the `topological_sort` function. Here's an example:

```python
# Define a directed acyclic graph as an adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': ['D', 'E'],
    'D': ['F'],
    'E': [],
    'F': []
}

# Call the topological_sort function with the graph
result = topological_sort(graph)

# Print the sorted nodes
print(result)
```","# Define a directed acyclic graph as an adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': ['D', 'E'],
    'D': ['F'],
    'E': [],
    'F': []
}","['A', 'C', 'E', 'B', 'D', 'F']","['A', 'C', 'E', 'B', 'D', 'F']",PASS,TRUE,N/A
34,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end, path=[]):
    # Add the current node to the path
    path = path + [start]

    # If the current node is the end node, return the path
    if start == end:
        return [path]

    # If the current node is not in the graph, return an empty list
    if start not in graph:
        return []

    # Initialize a list to store all possible paths
    paths = []

    # Iterate through each neighbor of the current node
    for neighbor in graph[start]:
        # If the neighbor has not been visited yet, recursively find all paths from it to the end node
        if neighbor not in path:
            new_paths = funcImp(graph, neighbor, end, path)
            # Append each new path to the list of paths
            paths.extend(new_paths)

    return paths

# Test case 1: Undirected graph represented as a dictionary
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'E'],
    'E': ['C', 'D']
}
start_node = 'A'
end_node = 'E'
print(funcImp(graph, start_node, end_node))

# Output: [['A', 'C', 'E'], ['A', 'B', 'D', 'E']]

# Test case 2: Empty graph
graph = {}
start_node = 1
end_node = 2
print(funcImp(graph, start_node, end_node))

# Output: []

# Test case 3: Graph with only one node and no edges
graph = {
    'A': []
}
start_node = 'A'
end_node = 'A'
print(funcImp(graph, start_node, end_node))

# Output: [['A']]

# Test case 4: Graph with multiple paths between start and end nodes
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'E'],
    'E': ['C', 'D']
}
start_node = 'A'
end_node = 'D'
print(funcImp(graph, start_node, end_node))

# Output: [['A', 'B', 'D'], ['A', 'C', 'E', 'D']]
```","({'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'E'], 'D': ['B', 'E'], 'E': ['C', 'D']}, 'A', 'E')","[['A', 'C', 'E'], ['A', 'B', 'D', 'E']]","[['A', 'B', 'D', 'E'], ['A', 'C', 'E']]",FAIL,FALSE,N/A
34,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end, path=[]):
    # Add the current node to the path
    path = path + [start]

    # If the current node is the end node, return the path
    if start == end:
        return [path]

    # If the current node is not in the graph, return an empty list
    if start not in graph:
        return []

    # Initialize a list to store all possible paths
    paths = []

    # Iterate through each neighbor of the current node
    for neighbor in graph[start]:
        # If the neighbor has not been visited yet, recursively find all paths from it to the end node
        if neighbor not in path:
            new_paths = funcImp(graph, neighbor, end, path)
            # Append each new path to the list of paths
            paths.extend(new_paths)

    return paths

# Test case 1: Undirected graph represented as a dictionary
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'E'],
    'E': ['C', 'D']
}
start_node = 'A'
end_node = 'E'
print(funcImp(graph, start_node, end_node))

# Output: [['A', 'C', 'E'], ['A', 'B', 'D', 'E']]

# Test case 2: Empty graph
graph = {}
start_node = 1
end_node = 2
print(funcImp(graph, start_node, end_node))

# Output: []

# Test case 3: Graph with only one node and no edges
graph = {
    'A': []
}
start_node = 'A'
end_node = 'A'
print(funcImp(graph, start_node, end_node))

# Output: [['A']]

# Test case 4: Graph with multiple paths between start and end nodes
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'E'],
    'E': ['C', 'D']
}
start_node = 'A'
end_node = 'D'
print(funcImp(graph, start_node, end_node))

# Output: [['A', 'B', 'D'], ['A', 'C', 'E', 'D']]
```","({}, 1, 2)",[],[],PASS,TRUE,N/A
34,3,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end, path=[]):
    # Add the current node to the path
    path = path + [start]

    # If the current node is the end node, return the path
    if start == end:
        return [path]

    # If the current node is not in the graph, return an empty list
    if start not in graph:
        return []

    # Initialize a list to store all possible paths
    paths = []

    # Iterate through each neighbor of the current node
    for neighbor in graph[start]:
        # If the neighbor has not been visited yet, recursively find all paths from it to the end node
        if neighbor not in path:
            new_paths = funcImp(graph, neighbor, end, path)
            # Append each new path to the list of paths
            paths.extend(new_paths)

    return paths

# Test case 1: Undirected graph represented as a dictionary
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'E'],
    'E': ['C', 'D']
}
start_node = 'A'
end_node = 'E'
print(funcImp(graph, start_node, end_node))

# Output: [['A', 'C', 'E'], ['A', 'B', 'D', 'E']]

# Test case 2: Empty graph
graph = {}
start_node = 1
end_node = 2
print(funcImp(graph, start_node, end_node))

# Output: []

# Test case 3: Graph with only one node and no edges
graph = {
    'A': []
}
start_node = 'A'
end_node = 'A'
print(funcImp(graph, start_node, end_node))

# Output: [['A']]

# Test case 4: Graph with multiple paths between start and end nodes
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'E'],
    'E': ['C', 'D']
}
start_node = 'A'
end_node = 'D'
print(funcImp(graph, start_node, end_node))

# Output: [['A', 'B', 'D'], ['A', 'C', 'E', 'D']]
```","({'A': []}, 'A', 'A')",[['A']],[['A']],PASS,TRUE,N/A
34,4,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end, path=[]):
    # Add the current node to the path
    path = path + [start]

    # If the current node is the end node, return the path
    if start == end:
        return [path]

    # If the current node is not in the graph, return an empty list
    if start not in graph:
        return []

    # Initialize a list to store all possible paths
    paths = []

    # Iterate through each neighbor of the current node
    for neighbor in graph[start]:
        # If the neighbor has not been visited yet, recursively find all paths from it to the end node
        if neighbor not in path:
            new_paths = funcImp(graph, neighbor, end, path)
            # Append each new path to the list of paths
            paths.extend(new_paths)

    return paths

# Test case 1: Undirected graph represented as a dictionary
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'E'],
    'E': ['C', 'D']
}
start_node = 'A'
end_node = 'E'
print(funcImp(graph, start_node, end_node))

# Output: [['A', 'C', 'E'], ['A', 'B', 'D', 'E']]

# Test case 2: Empty graph
graph = {}
start_node = 1
end_node = 2
print(funcImp(graph, start_node, end_node))

# Output: []

# Test case 3: Graph with only one node and no edges
graph = {
    'A': []
}
start_node = 'A'
end_node = 'A'
print(funcImp(graph, start_node, end_node))

# Output: [['A']]

# Test case 4: Graph with multiple paths between start and end nodes
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'E'],
    'E': ['C', 'D']
}
start_node = 'A'
end_node = 'D'
print(funcImp(graph, start_node, end_node))

# Output: [['A', 'B', 'D'], ['A', 'C', 'E', 'D']]
```","({'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'E'], 'D': ['B', 'E'], 'E': ['C', 'D']}, 'A', 'D')","[['A', 'B', 'D'], ['A', 'C', 'E', 'D']]","[['A', 'B', 'D'], ['A', 'C', 'E', 'D']]",PASS,TRUE,N/A
35,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    def dfs(node, visited, parent):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor, visited, node):
                    return True
            elif neighbor != parent:
                return True
        return False

    cycles = []
    visited = set()
    for node in graph:
        if node not in visited:
            if dfs(node, visited, None):
                cycle = []
                current_node = node
                while current_node != parent[current_node]:
                    cycle.append(current_node)
                    current_node = parent[current_node]
                cycle.append(current_node)
                cycles.append(cycle[::-1])
    
    for cycle in cycles:
        print(cycle)

# Test case 1: A simple graph with one cycle
graph1 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B']
}
funcImp(graph1)  # Output: ['A', 'B', 'C']

# Test case 2: A graph with multiple disconnected cycles
graph2 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B'],
    'D': [],
    'E': ['F'],
    'F': ['E']
}
funcImp(graph2)  # Output: ['A', 'B', 'C'], ['E', 'F']

# Test case 3: A graph without any cycles
graph3 = {
    'A': [],
    'B': [],
    'C': []
}
funcImp(graph3)  # Output: []

# Test case 4: An empty graph
graph4 = {}
funcImp(graph4)  # Output: []
```","# Test case 1: A simple graph with one cycle
graph1 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B']
}","[['A', 'B', 'C']]",,FAIL,FALSE,N/A
35,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    def dfs(node, visited, parent):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor, visited, node):
                    return True
            elif neighbor != parent:
                return True
        return False

    cycles = []
    visited = set()
    for node in graph:
        if node not in visited:
            if dfs(node, visited, None):
                cycle = []
                current_node = node
                while current_node != parent[current_node]:
                    cycle.append(current_node)
                    current_node = parent[current_node]
                cycle.append(current_node)
                cycles.append(cycle[::-1])
    
    for cycle in cycles:
        print(cycle)

# Test case 1: A simple graph with one cycle
graph1 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B']
}
funcImp(graph1)  # Output: ['A', 'B', 'C']

# Test case 2: A graph with multiple disconnected cycles
graph2 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B'],
    'D': [],
    'E': ['F'],
    'F': ['E']
}
funcImp(graph2)  # Output: ['A', 'B', 'C'], ['E', 'F']

# Test case 3: A graph without any cycles
graph3 = {
    'A': [],
    'B': [],
    'C': []
}
funcImp(graph3)  # Output: []

# Test case 4: An empty graph
graph4 = {}
funcImp(graph4)  # Output: []
```","# Test case 2: A graph with multiple disconnected cycles
graph2 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B'],
    'D': [],
    'E': ['F'],
    'F': ['E']
}","['A', 'B', 'C'], ['E', 'F']",,FAIL,FALSE,N/A
35,3,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    def dfs(node, visited, parent):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor, visited, node):
                    return True
            elif neighbor != parent:
                return True
        return False

    cycles = []
    visited = set()
    for node in graph:
        if node not in visited:
            if dfs(node, visited, None):
                cycle = []
                current_node = node
                while current_node != parent[current_node]:
                    cycle.append(current_node)
                    current_node = parent[current_node]
                cycle.append(current_node)
                cycles.append(cycle[::-1])
    
    for cycle in cycles:
        print(cycle)

# Test case 1: A simple graph with one cycle
graph1 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B']
}
funcImp(graph1)  # Output: ['A', 'B', 'C']

# Test case 2: A graph with multiple disconnected cycles
graph2 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B'],
    'D': [],
    'E': ['F'],
    'F': ['E']
}
funcImp(graph2)  # Output: ['A', 'B', 'C'], ['E', 'F']

# Test case 3: A graph without any cycles
graph3 = {
    'A': [],
    'B': [],
    'C': []
}
funcImp(graph3)  # Output: []

# Test case 4: An empty graph
graph4 = {}
funcImp(graph4)  # Output: []
```","# Test case 3: A graph without any cycles
graph3 = {
    'A': [],
    'B': [],
    'C': []
}",[],,FAIL,FALSE,N/A
35,4,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    def dfs(node, visited, parent):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor, visited, node):
                    return True
            elif neighbor != parent:
                return True
        return False

    cycles = []
    visited = set()
    for node in graph:
        if node not in visited:
            if dfs(node, visited, None):
                cycle = []
                current_node = node
                while current_node != parent[current_node]:
                    cycle.append(current_node)
                    current_node = parent[current_node]
                cycle.append(current_node)
                cycles.append(cycle[::-1])
    
    for cycle in cycles:
        print(cycle)

# Test case 1: A simple graph with one cycle
graph1 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B']
}
funcImp(graph1)  # Output: ['A', 'B', 'C']

# Test case 2: A graph with multiple disconnected cycles
graph2 = {
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B'],
    'D': [],
    'E': ['F'],
    'F': ['E']
}
funcImp(graph2)  # Output: ['A', 'B', 'C'], ['E', 'F']

# Test case 3: A graph without any cycles
graph3 = {
    'A': [],
    'B': [],
    'C': []
}
funcImp(graph3)  # Output: []

# Test case 4: An empty graph
graph4 = {}
funcImp(graph4)  # Output: []
```","# Test case 4: An empty graph
graph4 = {}",[],,FAIL,FALSE,N/A
36,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import defaultdict

def funcImp(graph, start, end):
    # Create a visited set to keep track of visited nodes
    visited = set()

    # Create a queue for BFS traversal
    queue = []

    # Mark the start node as visited and enqueue it
    visited.add(start)
    queue.append(start)

    while queue:
        # Dequeue a vertex from the queue
        current_node = queue.pop(0)

        # If the current node is the end node, return True
        if current_node == end:
            return True

        # Get all adjacent nodes of the current node that have not been visited yet
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                # Mark the neighbor as visited and enqueue it
                visited.add(neighbor)
                queue.append(neighbor)

    # If no path is found, return False
    return False


# Test case 1: Graph with a path between nodes 1 and 4
graph1 = defaultdict(list)
graph1[1] = [2, 3]
graph1[2] = [1, 4]
graph1[3] = [1]
graph1[4] = [2]

print(funcImp(graph1, 1, 4))  # Output: True

# Test case 2: Graph with no path between nodes 1 and 5
graph2 = defaultdict(list)
graph2[1] = [2, 3]
graph2[2] = [1, 4]
graph2[3] = [1]
graph2[4] = [2]

print(funcImp(graph2, 1, 5))  # Output: False

# Test case 3: Empty graph
empty_graph = defaultdict(list)

print(funcImp(empty_graph, 1, 2))  # Output: False
```","(defaultdict(<class 'list'>, {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]}), 1, 4)",TRUE,TRUE,PASS,TRUE,N/A
36,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import defaultdict

def funcImp(graph, start, end):
    # Create a visited set to keep track of visited nodes
    visited = set()

    # Create a queue for BFS traversal
    queue = []

    # Mark the start node as visited and enqueue it
    visited.add(start)
    queue.append(start)

    while queue:
        # Dequeue a vertex from the queue
        current_node = queue.pop(0)

        # If the current node is the end node, return True
        if current_node == end:
            return True

        # Get all adjacent nodes of the current node that have not been visited yet
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                # Mark the neighbor as visited and enqueue it
                visited.add(neighbor)
                queue.append(neighbor)

    # If no path is found, return False
    return False


# Test case 1: Graph with a path between nodes 1 and 4
graph1 = defaultdict(list)
graph1[1] = [2, 3]
graph1[2] = [1, 4]
graph1[3] = [1]
graph1[4] = [2]

print(funcImp(graph1, 1, 4))  # Output: True

# Test case 2: Graph with no path between nodes 1 and 5
graph2 = defaultdict(list)
graph2[1] = [2, 3]
graph2[2] = [1, 4]
graph2[3] = [1]
graph2[4] = [2]

print(funcImp(graph2, 1, 5))  # Output: False

# Test case 3: Empty graph
empty_graph = defaultdict(list)

print(funcImp(empty_graph, 1, 2))  # Output: False
```","(defaultdict(<class 'list'>, {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]}), 1, 5)",FALSE,FALSE,PASS,TRUE,N/A
36,3,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import defaultdict

def funcImp(graph, start, end):
    # Create a visited set to keep track of visited nodes
    visited = set()

    # Create a queue for BFS traversal
    queue = []

    # Mark the start node as visited and enqueue it
    visited.add(start)
    queue.append(start)

    while queue:
        # Dequeue a vertex from the queue
        current_node = queue.pop(0)

        # If the current node is the end node, return True
        if current_node == end:
            return True

        # Get all adjacent nodes of the current node that have not been visited yet
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                # Mark the neighbor as visited and enqueue it
                visited.add(neighbor)
                queue.append(neighbor)

    # If no path is found, return False
    return False


# Test case 1: Graph with a path between nodes 1 and 4
graph1 = defaultdict(list)
graph1[1] = [2, 3]
graph1[2] = [1, 4]
graph1[3] = [1]
graph1[4] = [2]

print(funcImp(graph1, 1, 4))  # Output: True

# Test case 2: Graph with no path between nodes 1 and 5
graph2 = defaultdict(list)
graph2[1] = [2, 3]
graph2[2] = [1, 4]
graph2[3] = [1]
graph2[4] = [2]

print(funcImp(graph2, 1, 5))  # Output: False

# Test case 3: Empty graph
empty_graph = defaultdict(list)

print(funcImp(empty_graph, 1, 2))  # Output: False
```","(defaultdict(<class 'list'>, {), 1, 1)",FALSE,FALSE,PASS,TRUE,N/A
37,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)","Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.","## Problem Statement
- Develop a Python script to solve the problem: 'Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    def add_edge(self, u, v, w):
        self.graph.append([u, v, w])

    def find(self, parent, i):
        if parent[i] == i:
            return i
        return self.find(parent, parent[i])

    def union(self, parent, rank, x, y):
        xroot = self.find(parent, x)
        yroot = self.find(parent, y)

        if rank[xroot] < rank[yroot]:
            parent[xroot] = yroot
        elif rank[xroot] > rank[yroot]:
            parent[yroot] = xroot
        else:
            parent[yroot] = xroot
            rank[xroot] += 1

    def kruskal_mst(self):
        result = []
        i = 0
        e = 0

        self.graph = sorted(self.graph,key=lambda item: item[2])

        parent = []
        rank = []

        for node in range(self.V):
            parent.append(node)
            rank.append(0)

        while e < self.V - 1:
            u,v,w = self.graph[i]
            i += 1
            x = self.find(parent,u)
            y = self.find(parent,v)

            if x != y:
                e += 1
                result.append([u,v,w])
                self.union(parent,rank,x,y)
        print(result)  
               
graph = Graph(4)
graph.add_edge(0, 1, 10)
graph.add_edge(0, 2, 6)
graph.add_edge(0, 3, 5)
graph.add_edge(1 ,3 ,15)
graph.add_edge(2 ,3 ,4)

graph.kruskal_mst()
```","graph = Graph(4)
graph.add_edge(0, 1, 10)
graph.add_edge(0, 2, 6)
graph.add_edge(0, 3, 5)
graph.add_edge(1 ,3 ,15)
graph.add_edge(2 ,3 ,4)","[[2, 3, 4], [0, 3, 5], [0, 1, 10]]","[[2, 3, 4], [0, 3, 5], [0, 1, 10]]",PASS,TRUE,N/A
38,1,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(adj_list):
    # Function to perform depth-first search on the graph
    def dfs(node, visited):
        visited[node] = True
        for neighbor in adj_list[node]:
            if not visited[neighbor]:
                dfs(neighbor, visited)

    num_nodes = len(adj_list)
    visited = [False] * num_nodes  # Initialize all nodes as unvisited
    count = 0  # Initialize count of connected components

    for node in range(num_nodes):
        if not visited[node]:
            dfs(node, visited)
            count += 1

    return count


# Test cases
adj_list_1 = [[1, 2], [0], [0], [4], []]
print(funcImp(adj_list_1))  # Output: 3

adj_list_2 = [[1, 2], [0, 2], [0, 1], [], []]
print(funcImp(adj_list_2))  # Output: 2

adj_list_3 = [[1], [0, 2], [1], [], []]
print(funcImp(adj_list_3))  # Output: 3
```","[[1, 2], [0], [0], [4], []]",3,2,FAIL,FALSE,N/A
38,2,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(adj_list):
    # Function to perform depth-first search on the graph
    def dfs(node, visited):
        visited[node] = True
        for neighbor in adj_list[node]:
            if not visited[neighbor]:
                dfs(neighbor, visited)

    num_nodes = len(adj_list)
    visited = [False] * num_nodes  # Initialize all nodes as unvisited
    count = 0  # Initialize count of connected components

    for node in range(num_nodes):
        if not visited[node]:
            dfs(node, visited)
            count += 1

    return count


# Test cases
adj_list_1 = [[1, 2], [0], [0], [4], []]
print(funcImp(adj_list_1))  # Output: 3

adj_list_2 = [[1, 2], [0, 2], [0, 1], [], []]
print(funcImp(adj_list_2))  # Output: 2

adj_list_3 = [[1], [0, 2], [1], [], []]
print(funcImp(adj_list_3))  # Output: 3
```","[[1, 2], [0, 2], [0, 1], [], []]",2,3,FAIL,FALSE,N/A
38,3,medium,"Graph traversal (e.g., depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(adj_list):
    # Function to perform depth-first search on the graph
    def dfs(node, visited):
        visited[node] = True
        for neighbor in adj_list[node]:
            if not visited[neighbor]:
                dfs(neighbor, visited)

    num_nodes = len(adj_list)
    visited = [False] * num_nodes  # Initialize all nodes as unvisited
    count = 0  # Initialize count of connected components

    for node in range(num_nodes):
        if not visited[node]:
            dfs(node, visited)
            count += 1

    return count


# Test cases
adj_list_1 = [[1, 2], [0], [0], [4], []]
print(funcImp(adj_list_1))  # Output: 3

adj_list_2 = [[1, 2], [0, 2], [0, 1], [], []]
print(funcImp(adj_list_2))  # Output: 2

adj_list_3 = [[1], [0, 2], [1], [], []]
print(funcImp(adj_list_3))  # Output: 3
```","[[1], [0, 2], [1], [], []]",3,3,PASS,TRUE,N/A
39,1,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
```

To test this function, you can use the following code:

```python
arr = [2, 4, 6, 8, 10]
target = 6

result = binary_search(arr, target)
if result != -1:
    print(f""Element {target} is present at index {result}"")
else:
    print(""Element not found"")
```","[2, 4, 6, 8, 10]",6,2,PASS,TRUE,N/A
39,2,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
```

To test this function, you can use the following code:

```python
arr = [2, 4, 6, 8, 10]
target = 6

result = binary_search(arr, target)
if result != -1:
    print(f""Element {target} is present at index {result}"")
else:
    print(""Element not found"")
```","[2, 4, 6, 8, 10]",5,-1,PASS,TRUE,N/A
40,1,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Function to find the first occurrence of a target element in a sorted array using binary search.

    Args:
        arr (list): The sorted array.
        target: The target element to find.

    Returns:
        int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        # If the middle element is equal to the target and it's either the first element or its previous element is not equal to the target,
        # then we have found the first occurrence of the target.
        if arr[mid] == target and (mid == 0 or arr[mid-1] != target):
            return mid

        # If the middle element is greater than or equal to the target, search in the left half of the array.
        elif arr[mid] >= target:
            right = mid - 1

        # If the middle element is less than the target, search in the right half of the array.
        else:
            left = mid + 1

    return -1


# Test cases
arr = [1, 2, 3, 3, 4, 5]
target = 3
print(funcImp(arr, target))   # Output: 2

arr = [1, 2, 3, 3, 4, 5]
target = 6
print(funcImp(arr, target))   # Output: -1

arr = [1]
target = 1
print(funcImp(arr, target))   # Output: 0

arr = []
target = 5
print(funcImp(arr, target))   # Output: -1
```","[1, 2, 3, 3, 4, 5]",3,2,PASS,TRUE,N/A
40,2,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Function to find the first occurrence of a target element in a sorted array using binary search.

    Args:
        arr (list): The sorted array.
        target: The target element to find.

    Returns:
        int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        # If the middle element is equal to the target and it's either the first element or its previous element is not equal to the target,
        # then we have found the first occurrence of the target.
        if arr[mid] == target and (mid == 0 or arr[mid-1] != target):
            return mid

        # If the middle element is greater than or equal to the target, search in the left half of the array.
        elif arr[mid] >= target:
            right = mid - 1

        # If the middle element is less than the target, search in the right half of the array.
        else:
            left = mid + 1

    return -1


# Test cases
arr = [1, 2, 3, 3, 4, 5]
target = 3
print(funcImp(arr, target))   # Output: 2

arr = [1, 2, 3, 3, 4, 5]
target = 6
print(funcImp(arr, target))   # Output: -1

arr = [1]
target = 1
print(funcImp(arr, target))   # Output: 0

arr = []
target = 5
print(funcImp(arr, target))   # Output: -1
```","[1, 2, 3, 3, 4, 5]",6,-1,PASS,TRUE,N/A
40,3,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Function to find the first occurrence of a target element in a sorted array using binary search.

    Args:
        arr (list): The sorted array.
        target: The target element to find.

    Returns:
        int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        # If the middle element is equal to the target and it's either the first element or its previous element is not equal to the target,
        # then we have found the first occurrence of the target.
        if arr[mid] == target and (mid == 0 or arr[mid-1] != target):
            return mid

        # If the middle element is greater than or equal to the target, search in the left half of the array.
        elif arr[mid] >= target:
            right = mid - 1

        # If the middle element is less than the target, search in the right half of the array.
        else:
            left = mid + 1

    return -1


# Test cases
arr = [1, 2, 3, 3, 4, 5]
target = 3
print(funcImp(arr, target))   # Output: 2

arr = [1, 2, 3, 3, 4, 5]
target = 6
print(funcImp(arr, target))   # Output: -1

arr = [1]
target = 1
print(funcImp(arr, target))   # Output: 0

arr = []
target = 5
print(funcImp(arr, target))   # Output: -1
```",[1],1,0,PASS,TRUE,N/A
40,4,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Function to find the first occurrence of a target element in a sorted array using binary search.

    Args:
        arr (list): The sorted array.
        target: The target element to find.

    Returns:
        int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        # If the middle element is equal to the target and it's either the first element or its previous element is not equal to the target,
        # then we have found the first occurrence of the target.
        if arr[mid] == target and (mid == 0 or arr[mid-1] != target):
            return mid

        # If the middle element is greater than or equal to the target, search in the left half of the array.
        elif arr[mid] >= target:
            right = mid - 1

        # If the middle element is less than the target, search in the right half of the array.
        else:
            left = mid + 1

    return -1


# Test cases
arr = [1, 2, 3, 3, 4, 5]
target = 3
print(funcImp(arr, target))   # Output: 2

arr = [1, 2, 3, 3, 4, 5]
target = 6
print(funcImp(arr, target))   # Output: -1

arr = [1]
target = 1
print(funcImp(arr, target))   # Output: 0

arr = []
target = 5
print(funcImp(arr, target))   # Output: -1
```",[],5,-1,PASS,TRUE,N/A
41,1,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.

    Args:
        arr: A sorted array of elements.
        target: The target element to find.

    Returns:
        The index of the last occurrence of the target element in the array,
        or -1 if the target element is not found.
    """"""

    # Initialize variables for left and right pointers
    left = 0
    right = len(arr) - 1

    # Iterate until left pointer is less than or equal to right pointer
    while left <= right:
        # Calculate mid index
        mid = (left + right) // 2

        # If target element is found at mid index, check if it's the last occurrence
        if arr[mid] == target:
            # Check if mid index is the last occurrence by checking if next element is different
            if mid == len(arr) - 1 or arr[mid + 1] != target:
                return mid

            # If next element is also same as target, move left pointer to mid + 1 to search on the right side
            else:
                left = mid + 1

        # If target element is greater than current element, move left pointer to mid + 1 to search on the right side
        elif arr[mid] < target:
            left = mid + 1

        # If target element is smaller than current element, move right pointer to mid - 1 to search on the left side
        else:
            right = mid - 1

    # Target element not found, return -1
    return -1


# Test cases
arr = [2, 4, 6, 8, 8, 10]
target = 8
print(funcImp(arr, target))  # Output: 4

arr = [2, 4, 6, 8, 8, 10]
target = 5
print(funcImp(arr, target))  # Output: -1

arr = []
target = 5
print(funcImp(arr, target))  # Output: -1

arr = [2]
target = 2
print(funcImp(arr, target))  # Output: 0

arr = [2]
target = 3
print(funcImp(arr, target))  # Output: -1
```","arr=[2, 4, 6, 8, 8, 10], target=8",4,4,PASS,TRUE,N/A
41,2,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.

    Args:
        arr: A sorted array of elements.
        target: The target element to find.

    Returns:
        The index of the last occurrence of the target element in the array,
        or -1 if the target element is not found.
    """"""

    # Initialize variables for left and right pointers
    left = 0
    right = len(arr) - 1

    # Iterate until left pointer is less than or equal to right pointer
    while left <= right:
        # Calculate mid index
        mid = (left + right) // 2

        # If target element is found at mid index, check if it's the last occurrence
        if arr[mid] == target:
            # Check if mid index is the last occurrence by checking if next element is different
            if mid == len(arr) - 1 or arr[mid + 1] != target:
                return mid

            # If next element is also same as target, move left pointer to mid + 1 to search on the right side
            else:
                left = mid + 1

        # If target element is greater than current element, move left pointer to mid + 1 to search on the right side
        elif arr[mid] < target:
            left = mid + 1

        # If target element is smaller than current element, move right pointer to mid - 1 to search on the left side
        else:
            right = mid - 1

    # Target element not found, return -1
    return -1


# Test cases
arr = [2, 4, 6, 8, 8, 10]
target = 8
print(funcImp(arr, target))  # Output: 4

arr = [2, 4, 6, 8, 8, 10]
target = 5
print(funcImp(arr, target))  # Output: -1

arr = []
target = 5
print(funcImp(arr, target))  # Output: -1

arr = [2]
target = 2
print(funcImp(arr, target))  # Output: 0

arr = [2]
target = 3
print(funcImp(arr, target))  # Output: -1
```","arr=[2, 4, 6, 8, 8, 10], target=5",-1,-1,PASS,TRUE,N/A
41,3,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.

    Args:
        arr: A sorted array of elements.
        target: The target element to find.

    Returns:
        The index of the last occurrence of the target element in the array,
        or -1 if the target element is not found.
    """"""

    # Initialize variables for left and right pointers
    left = 0
    right = len(arr) - 1

    # Iterate until left pointer is less than or equal to right pointer
    while left <= right:
        # Calculate mid index
        mid = (left + right) // 2

        # If target element is found at mid index, check if it's the last occurrence
        if arr[mid] == target:
            # Check if mid index is the last occurrence by checking if next element is different
            if mid == len(arr) - 1 or arr[mid + 1] != target:
                return mid

            # If next element is also same as target, move left pointer to mid + 1 to search on the right side
            else:
                left = mid + 1

        # If target element is greater than current element, move left pointer to mid + 1 to search on the right side
        elif arr[mid] < target:
            left = mid + 1

        # If target element is smaller than current element, move right pointer to mid - 1 to search on the left side
        else:
            right = mid - 1

    # Target element not found, return -1
    return -1


# Test cases
arr = [2, 4, 6, 8, 8, 10]
target = 8
print(funcImp(arr, target))  # Output: 4

arr = [2, 4, 6, 8, 8, 10]
target = 5
print(funcImp(arr, target))  # Output: -1

arr = []
target = 5
print(funcImp(arr, target))  # Output: -1

arr = [2]
target = 2
print(funcImp(arr, target))  # Output: 0

arr = [2]
target = 3
print(funcImp(arr, target))  # Output: -1
```","arr=[], target=5",-1,-1,PASS,TRUE,N/A
41,4,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.

    Args:
        arr: A sorted array of elements.
        target: The target element to find.

    Returns:
        The index of the last occurrence of the target element in the array,
        or -1 if the target element is not found.
    """"""

    # Initialize variables for left and right pointers
    left = 0
    right = len(arr) - 1

    # Iterate until left pointer is less than or equal to right pointer
    while left <= right:
        # Calculate mid index
        mid = (left + right) // 2

        # If target element is found at mid index, check if it's the last occurrence
        if arr[mid] == target:
            # Check if mid index is the last occurrence by checking if next element is different
            if mid == len(arr) - 1 or arr[mid + 1] != target:
                return mid

            # If next element is also same as target, move left pointer to mid + 1 to search on the right side
            else:
                left = mid + 1

        # If target element is greater than current element, move left pointer to mid + 1 to search on the right side
        elif arr[mid] < target:
            left = mid + 1

        # If target element is smaller than current element, move right pointer to mid - 1 to search on the left side
        else:
            right = mid - 1

    # Target element not found, return -1
    return -1


# Test cases
arr = [2, 4, 6, 8, 8, 10]
target = 8
print(funcImp(arr, target))  # Output: 4

arr = [2, 4, 6, 8, 8, 10]
target = 5
print(funcImp(arr, target))  # Output: -1

arr = []
target = 5
print(funcImp(arr, target))  # Output: -1

arr = [2]
target = 2
print(funcImp(arr, target))  # Output: 0

arr = [2]
target = 3
print(funcImp(arr, target))  # Output: -1
```","arr=[2], target=2",0,0,PASS,TRUE,N/A
41,5,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Find the last occurrence of a target element in a sorted array using binary search.

    Args:
        arr: A sorted array of elements.
        target: The target element to find.

    Returns:
        The index of the last occurrence of the target element in the array,
        or -1 if the target element is not found.
    """"""

    # Initialize variables for left and right pointers
    left = 0
    right = len(arr) - 1

    # Iterate until left pointer is less than or equal to right pointer
    while left <= right:
        # Calculate mid index
        mid = (left + right) // 2

        # If target element is found at mid index, check if it's the last occurrence
        if arr[mid] == target:
            # Check if mid index is the last occurrence by checking if next element is different
            if mid == len(arr) - 1 or arr[mid + 1] != target:
                return mid

            # If next element is also same as target, move left pointer to mid + 1 to search on the right side
            else:
                left = mid + 1

        # If target element is greater than current element, move left pointer to mid + 1 to search on the right side
        elif arr[mid] < target:
            left = mid + 1

        # If target element is smaller than current element, move right pointer to mid - 1 to search on the left side
        else:
            right = mid - 1

    # Target element not found, return -1
    return -1


# Test cases
arr = [2, 4, 6, 8, 8, 10]
target = 8
print(funcImp(arr, target))  # Output: 4

arr = [2, 4, 6, 8, 8, 10]
target = 5
print(funcImp(arr, target))  # Output: -1

arr = []
target = 5
print(funcImp(arr, target))  # Output: -1

arr = [2]
target = 2
print(funcImp(arr, target))  # Output: 0

arr = [2]
target = 3
print(funcImp(arr, target))  # Output: -1
```","arr=[2], target=3",-1,-1,PASS,TRUE,N/A
42,1,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
```

To test this function, you can use the following code:

```python
arr = [2, 4, 6, 8, 10]
target = 8

result = binary_search(arr, target)
if result != -1:
    print(""Element found at index"", result)
else:
    print(""Element not found"")
```","arr = [2, 4, 6, 8, 10], target = 8",Element found at index 3,3,PASS,TRUE,N/A
43,1,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    # Check if the array is empty
    if not nums:
        return None
    
    # Initialize left and right pointers
    left = 0
    right = len(nums) - 1
    
    # Perform binary search to find the minimum element
    while left < right:
        mid = (left + right) // 2
        
        # If the middle element is greater than the last element, search in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        
        # If the middle element is less than or equal to the last element, search in the left half
        else:
            right = mid
    
    # The minimum element will be at index 'left'
    return nums[left]
```

You can test this function with different test cases to verify its correctness. Here are a few examples:

```python
# Test case 1: Sorted array [1, 2, 3, 4, 5]
print(funcImp([1, 2, 3, 4, 5]))   # Output: 1

# Test case 2: Rotated sorted array [4, 5, 6, 7, 0, 1, 2]
print(funcImp([4, 5, 6, 7, 0 ,1 ,2]))   # Output: 0

# Test case3: Rotated sorted array [7]
print(funcImp([7]))   # Output:7

# Test case4: Empty array []
print(funcImp([]))   # Output: None
```","[1, 2, 3, 4, 5]",1,1,PASS,TRUE,N/A
43,2,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    # Check if the array is empty
    if not nums:
        return None
    
    # Initialize left and right pointers
    left = 0
    right = len(nums) - 1
    
    # Perform binary search to find the minimum element
    while left < right:
        mid = (left + right) // 2
        
        # If the middle element is greater than the last element, search in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        
        # If the middle element is less than or equal to the last element, search in the left half
        else:
            right = mid
    
    # The minimum element will be at index 'left'
    return nums[left]
```

You can test this function with different test cases to verify its correctness. Here are a few examples:

```python
# Test case 1: Sorted array [1, 2, 3, 4, 5]
print(funcImp([1, 2, 3, 4, 5]))   # Output: 1

# Test case 2: Rotated sorted array [4, 5, 6, 7, 0, 1, 2]
print(funcImp([4, 5, 6, 7, 0 ,1 ,2]))   # Output: 0

# Test case3: Rotated sorted array [7]
print(funcImp([7]))   # Output:7

# Test case4: Empty array []
print(funcImp([]))   # Output: None
```","[4, 5, 6, 7, 0, 1, 2]",0,0,PASS,TRUE,N/A
43,3,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    # Check if the array is empty
    if not nums:
        return None
    
    # Initialize left and right pointers
    left = 0
    right = len(nums) - 1
    
    # Perform binary search to find the minimum element
    while left < right:
        mid = (left + right) // 2
        
        # If the middle element is greater than the last element, search in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        
        # If the middle element is less than or equal to the last element, search in the left half
        else:
            right = mid
    
    # The minimum element will be at index 'left'
    return nums[left]
```

You can test this function with different test cases to verify its correctness. Here are a few examples:

```python
# Test case 1: Sorted array [1, 2, 3, 4, 5]
print(funcImp([1, 2, 3, 4, 5]))   # Output: 1

# Test case 2: Rotated sorted array [4, 5, 6, 7, 0, 1, 2]
print(funcImp([4, 5, 6, 7, 0 ,1 ,2]))   # Output: 0

# Test case3: Rotated sorted array [7]
print(funcImp([7]))   # Output:7

# Test case4: Empty array []
print(funcImp([]))   # Output: None
```",[7],7,7,PASS,TRUE,N/A
43,4,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    # Check if the array is empty
    if not nums:
        return None
    
    # Initialize left and right pointers
    left = 0
    right = len(nums) - 1
    
    # Perform binary search to find the minimum element
    while left < right:
        mid = (left + right) // 2
        
        # If the middle element is greater than the last element, search in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        
        # If the middle element is less than or equal to the last element, search in the left half
        else:
            right = mid
    
    # The minimum element will be at index 'left'
    return nums[left]
```

You can test this function with different test cases to verify its correctness. Here are a few examples:

```python
# Test case 1: Sorted array [1, 2, 3, 4, 5]
print(funcImp([1, 2, 3, 4, 5]))   # Output: 1

# Test case 2: Rotated sorted array [4, 5, 6, 7, 0, 1, 2]
print(funcImp([4, 5, 6, 7, 0 ,1 ,2]))   # Output: 0

# Test case3: Rotated sorted array [7]
print(funcImp([7]))   # Output:7

# Test case4: Empty array []
print(funcImp([]))   # Output: None
```",[],,,PASS,TRUE,N/A
44,1,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Get the number of rows and columns in the matrix
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Set the start and end indices for binary search
    start = 0
    end = rows * cols - 1
    
    while start <= end:
        # Calculate the middle index
        mid = (start + end) // 2
        
        # Convert the middle index to row and column indices
        row = mid // cols
        col = mid % cols
        
        # Check if the middle element is equal to the target
        if matrix[row][col] == target:
            return True
        
        # If the middle element is greater than the target, search in the left half of the matrix
        elif matrix[row][col] > target:
            end = mid - 1
        
        # If the middle element is smaller than the target, search in the right half of the matrix
        else:
            start = mid + 1
    
    return False

# Test cases

# Test case 1: Target element exists in a non-empty matrix
matrix1 = [
    [1, 3, 5],
    [7, 9, 11],
    [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1))   # Output: True

# Test case 2: Target element does not exist in a non-empty matrix
matrix2 = [
    [2, 4, 6],
    [8, 10, 12],
    [14, 16, 18]
]
target2 = 7
print(funcImp(matrix2, target2))   # Output: False

# Test case 3: Target element exists in an empty matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3))   # Output: False

# Test case 4: Target element does not exist in an empty matrix
matrix4 = []
target4 = 0
print(funcImp(matrix4, target4))   # Output: False
```","matrix: [[1, 3, 5], [7, 9, 11], [13, 15, 17]], target: 9",TRUE,TRUE,PASS,TRUE,N/A
44,2,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Get the number of rows and columns in the matrix
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Set the start and end indices for binary search
    start = 0
    end = rows * cols - 1
    
    while start <= end:
        # Calculate the middle index
        mid = (start + end) // 2
        
        # Convert the middle index to row and column indices
        row = mid // cols
        col = mid % cols
        
        # Check if the middle element is equal to the target
        if matrix[row][col] == target:
            return True
        
        # If the middle element is greater than the target, search in the left half of the matrix
        elif matrix[row][col] > target:
            end = mid - 1
        
        # If the middle element is smaller than the target, search in the right half of the matrix
        else:
            start = mid + 1
    
    return False

# Test cases

# Test case 1: Target element exists in a non-empty matrix
matrix1 = [
    [1, 3, 5],
    [7, 9, 11],
    [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1))   # Output: True

# Test case 2: Target element does not exist in a non-empty matrix
matrix2 = [
    [2, 4, 6],
    [8, 10, 12],
    [14, 16, 18]
]
target2 = 7
print(funcImp(matrix2, target2))   # Output: False

# Test case 3: Target element exists in an empty matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3))   # Output: False

# Test case 4: Target element does not exist in an empty matrix
matrix4 = []
target4 = 0
print(funcImp(matrix4, target4))   # Output: False
```","matrix: [[2, 4, 6], [8, 10, 12], [14, 16, 18]], target: 7",FALSE,FALSE,PASS,TRUE,N/A
44,3,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Get the number of rows and columns in the matrix
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Set the start and end indices for binary search
    start = 0
    end = rows * cols - 1
    
    while start <= end:
        # Calculate the middle index
        mid = (start + end) // 2
        
        # Convert the middle index to row and column indices
        row = mid // cols
        col = mid % cols
        
        # Check if the middle element is equal to the target
        if matrix[row][col] == target:
            return True
        
        # If the middle element is greater than the target, search in the left half of the matrix
        elif matrix[row][col] > target:
            end = mid - 1
        
        # If the middle element is smaller than the target, search in the right half of the matrix
        else:
            start = mid + 1
    
    return False

# Test cases

# Test case 1: Target element exists in a non-empty matrix
matrix1 = [
    [1, 3, 5],
    [7, 9, 11],
    [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1))   # Output: True

# Test case 2: Target element does not exist in a non-empty matrix
matrix2 = [
    [2, 4, 6],
    [8, 10, 12],
    [14, 16, 18]
]
target2 = 7
print(funcImp(matrix2, target2))   # Output: False

# Test case 3: Target element exists in an empty matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3))   # Output: False

# Test case 4: Target element does not exist in an empty matrix
matrix4 = []
target4 = 0
print(funcImp(matrix4, target4))   # Output: False
```","matrix: [], target: 5",FALSE,FALSE,PASS,TRUE,N/A
44,4,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    # Check if the matrix is empty
    if not matrix or not matrix[0]:
        return False
    
    # Get the number of rows and columns in the matrix
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Set the start and end indices for binary search
    start = 0
    end = rows * cols - 1
    
    while start <= end:
        # Calculate the middle index
        mid = (start + end) // 2
        
        # Convert the middle index to row and column indices
        row = mid // cols
        col = mid % cols
        
        # Check if the middle element is equal to the target
        if matrix[row][col] == target:
            return True
        
        # If the middle element is greater than the target, search in the left half of the matrix
        elif matrix[row][col] > target:
            end = mid - 1
        
        # If the middle element is smaller than the target, search in the right half of the matrix
        else:
            start = mid + 1
    
    return False

# Test cases

# Test case 1: Target element exists in a non-empty matrix
matrix1 = [
    [1, 3, 5],
    [7, 9, 11],
    [13, 15, 17]
]
target1 = 9
print(funcImp(matrix1, target1))   # Output: True

# Test case 2: Target element does not exist in a non-empty matrix
matrix2 = [
    [2, 4, 6],
    [8, 10, 12],
    [14, 16, 18]
]
target2 = 7
print(funcImp(matrix2, target2))   # Output: False

# Test case 3: Target element exists in an empty matrix
matrix3 = []
target3 = 5
print(funcImp(matrix3, target3))   # Output: False

# Test case 4: Target element does not exist in an empty matrix
matrix4 = []
target4 = 0
print(funcImp(matrix4, target4))   # Output: False
```","matrix: [], target: 0",FALSE,FALSE,PASS,TRUE,N/A
45,1,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array is empty
    if not arr:
        return None
    
    # Initialize the start and end indices for binary search
    start = 0
    end = len(arr) - 1
    
    while start < end:
        mid = (start + end) // 2
        
        # Check if the middle element is a peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            return arr[mid]
        
        # If the middle element is smaller than its right neighbor, there must be a peak on the right side
        elif arr[mid] < arr[mid+1]:
            start = mid + 1
        
        # If the middle element is smaller than its left neighbor, there must be a peak on the left side
        else:
            end = mid - 1
    
    # If no peak element is found, return the last element as a fallback option
    return arr[end]

# Test cases

# Test case 1: Peak at index 2 (value: 5)
arr1 = [1, 3, 5, 4, 2]
print(funcImp(arr1)) # Output: 5

# Test case 2: Peak at index 3 (value: 7)
arr2 = [1, 3, 4, 7, 6]
print(funcImp(arr2)) # Output: 7

# Test case 3: Peak at index 0 (value: -10)
arr3 = [-10, -9, -8]
print(funcImp(arr3)) # Output: -10

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4)) # Output: None

# Test case 5: Peak at index 4 (value: 9)
arr5 = [1, 2, 3, 4, 9]
print(funcImp(arr5)) # Output: 9
```","arr1 = [1, 3, 5, 4, 2]",5,5,PASS,TRUE,N/A
45,2,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array is empty
    if not arr:
        return None
    
    # Initialize the start and end indices for binary search
    start = 0
    end = len(arr) - 1
    
    while start < end:
        mid = (start + end) // 2
        
        # Check if the middle element is a peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            return arr[mid]
        
        # If the middle element is smaller than its right neighbor, there must be a peak on the right side
        elif arr[mid] < arr[mid+1]:
            start = mid + 1
        
        # If the middle element is smaller than its left neighbor, there must be a peak on the left side
        else:
            end = mid - 1
    
    # If no peak element is found, return the last element as a fallback option
    return arr[end]

# Test cases

# Test case 1: Peak at index 2 (value: 5)
arr1 = [1, 3, 5, 4, 2]
print(funcImp(arr1)) # Output: 5

# Test case 2: Peak at index 3 (value: 7)
arr2 = [1, 3, 4, 7, 6]
print(funcImp(arr2)) # Output: 7

# Test case 3: Peak at index 0 (value: -10)
arr3 = [-10, -9, -8]
print(funcImp(arr3)) # Output: -10

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4)) # Output: None

# Test case 5: Peak at index 4 (value: 9)
arr5 = [1, 2, 3, 4, 9]
print(funcImp(arr5)) # Output: 9
```","arr2 = [1, 3, 4, 7, 6]",7,7,PASS,TRUE,N/A
45,3,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array is empty
    if not arr:
        return None
    
    # Initialize the start and end indices for binary search
    start = 0
    end = len(arr) - 1
    
    while start < end:
        mid = (start + end) // 2
        
        # Check if the middle element is a peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            return arr[mid]
        
        # If the middle element is smaller than its right neighbor, there must be a peak on the right side
        elif arr[mid] < arr[mid+1]:
            start = mid + 1
        
        # If the middle element is smaller than its left neighbor, there must be a peak on the left side
        else:
            end = mid - 1
    
    # If no peak element is found, return the last element as a fallback option
    return arr[end]

# Test cases

# Test case 1: Peak at index 2 (value: 5)
arr1 = [1, 3, 5, 4, 2]
print(funcImp(arr1)) # Output: 5

# Test case 2: Peak at index 3 (value: 7)
arr2 = [1, 3, 4, 7, 6]
print(funcImp(arr2)) # Output: 7

# Test case 3: Peak at index 0 (value: -10)
arr3 = [-10, -9, -8]
print(funcImp(arr3)) # Output: -10

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4)) # Output: None

# Test case 5: Peak at index 4 (value: 9)
arr5 = [1, 2, 3, 4, 9]
print(funcImp(arr5)) # Output: 9
```","arr3 = [-10, -9, -8]",-8,-8,PASS,TRUE,N/A
45,4,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array is empty
    if not arr:
        return None
    
    # Initialize the start and end indices for binary search
    start = 0
    end = len(arr) - 1
    
    while start < end:
        mid = (start + end) // 2
        
        # Check if the middle element is a peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            return arr[mid]
        
        # If the middle element is smaller than its right neighbor, there must be a peak on the right side
        elif arr[mid] < arr[mid+1]:
            start = mid + 1
        
        # If the middle element is smaller than its left neighbor, there must be a peak on the left side
        else:
            end = mid - 1
    
    # If no peak element is found, return the last element as a fallback option
    return arr[end]

# Test cases

# Test case 1: Peak at index 2 (value: 5)
arr1 = [1, 3, 5, 4, 2]
print(funcImp(arr1)) # Output: 5

# Test case 2: Peak at index 3 (value: 7)
arr2 = [1, 3, 4, 7, 6]
print(funcImp(arr2)) # Output: 7

# Test case 3: Peak at index 0 (value: -10)
arr3 = [-10, -9, -8]
print(funcImp(arr3)) # Output: -10

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4)) # Output: None

# Test case 5: Peak at index 4 (value: 9)
arr5 = [1, 2, 3, 4, 9]
print(funcImp(arr5)) # Output: 9
```",arr4 = [],,,PASS,TRUE,N/A
45,5,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array is empty
    if not arr:
        return None
    
    # Initialize the start and end indices for binary search
    start = 0
    end = len(arr) - 1
    
    while start < end:
        mid = (start + end) // 2
        
        # Check if the middle element is a peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            return arr[mid]
        
        # If the middle element is smaller than its right neighbor, there must be a peak on the right side
        elif arr[mid] < arr[mid+1]:
            start = mid + 1
        
        # If the middle element is smaller than its left neighbor, there must be a peak on the left side
        else:
            end = mid - 1
    
    # If no peak element is found, return the last element as a fallback option
    return arr[end]

# Test cases

# Test case 1: Peak at index 2 (value: 5)
arr1 = [1, 3, 5, 4, 2]
print(funcImp(arr1)) # Output: 5

# Test case 2: Peak at index 3 (value: 7)
arr2 = [1, 3, 4, 7, 6]
print(funcImp(arr2)) # Output: 7

# Test case 3: Peak at index 0 (value: -10)
arr3 = [-10, -9, -8]
print(funcImp(arr3)) # Output: -10

# Test case 4: Empty array
arr4 = []
print(funcImp(arr4)) # Output: None

# Test case 5: Peak at index 4 (value: 9)
arr5 = [1, 2, 3, 4, 9]
print(funcImp(arr5)) # Output: 9
```","arr5 = [1, 2, 3, 4, 9]",9,9,PASS,TRUE,N/A
46,1,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array has at least 3 elements
    if len(arr) < 3:
        return False
    
    # Use binary search to find the peak element in the array
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Check if mid is the peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            break
        
        # If mid is not the peak, update left or right based on the slope of the array
        elif arr[mid] > arr[mid-1]:
            left = mid + 1
        else:
            right = mid - 1
    
    # If no peak element is found, return False
    if left > right:
        return False
    
    # Check if the array is bitonic by checking if all elements before and after the peak are in increasing and decreasing order respectively
    for i in range(mid):
        if arr[i] >= arr[i+1]:
            return False
    
    for i in range(mid, len(arr)-1):
        if arr[i] <= arr[i+1]:
            return False
    
    return True

# Test cases
arr1 = [1, 2, 3, 4, 5, 4, 3, 2]
arr2 = [5, 4, 3, 2]
arr3 = [1, 2]
arr4 = [10]

print(funcImp(arr1))   # True
print(funcImp(arr2))   # True
print(funcImp(arr3))   # False
print(funcImp(arr4))   # False

```","arr1 = [1, 2, 3, 4, 5, 4, 3, 2]",TRUE,TRUE,PASS,TRUE,N/A
46,2,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array has at least 3 elements
    if len(arr) < 3:
        return False
    
    # Use binary search to find the peak element in the array
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Check if mid is the peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            break
        
        # If mid is not the peak, update left or right based on the slope of the array
        elif arr[mid] > arr[mid-1]:
            left = mid + 1
        else:
            right = mid - 1
    
    # If no peak element is found, return False
    if left > right:
        return False
    
    # Check if the array is bitonic by checking if all elements before and after the peak are in increasing and decreasing order respectively
    for i in range(mid):
        if arr[i] >= arr[i+1]:
            return False
    
    for i in range(mid, len(arr)-1):
        if arr[i] <= arr[i+1]:
            return False
    
    return True

# Test cases
arr1 = [1, 2, 3, 4, 5, 4, 3, 2]
arr2 = [5, 4, 3, 2]
arr3 = [1, 2]
arr4 = [10]

print(funcImp(arr1))   # True
print(funcImp(arr2))   # True
print(funcImp(arr3))   # False
print(funcImp(arr4))   # False

```","arr2 = [5, 4, 3, 2]",TRUE,TRUE,PASS,TRUE,N/A
46,3,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array has at least 3 elements
    if len(arr) < 3:
        return False
    
    # Use binary search to find the peak element in the array
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Check if mid is the peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            break
        
        # If mid is not the peak, update left or right based on the slope of the array
        elif arr[mid] > arr[mid-1]:
            left = mid + 1
        else:
            right = mid - 1
    
    # If no peak element is found, return False
    if left > right:
        return False
    
    # Check if the array is bitonic by checking if all elements before and after the peak are in increasing and decreasing order respectively
    for i in range(mid):
        if arr[i] >= arr[i+1]:
            return False
    
    for i in range(mid, len(arr)-1):
        if arr[i] <= arr[i+1]:
            return False
    
    return True

# Test cases
arr1 = [1, 2, 3, 4, 5, 4, 3, 2]
arr2 = [5, 4, 3, 2]
arr3 = [1, 2]
arr4 = [10]

print(funcImp(arr1))   # True
print(funcImp(arr2))   # True
print(funcImp(arr3))   # False
print(funcImp(arr4))   # False

```","arr3 = [1, 2]",FALSE,FALSE,PASS,TRUE,N/A
46,4,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    # Check if the array has at least 3 elements
    if len(arr) < 3:
        return False
    
    # Use binary search to find the peak element in the array
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Check if mid is the peak element
        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:
            break
        
        # If mid is not the peak, update left or right based on the slope of the array
        elif arr[mid] > arr[mid-1]:
            left = mid + 1
        else:
            right = mid - 1
    
    # If no peak element is found, return False
    if left > right:
        return False
    
    # Check if the array is bitonic by checking if all elements before and after the peak are in increasing and decreasing order respectively
    for i in range(mid):
        if arr[i] >= arr[i+1]:
            return False
    
    for i in range(mid, len(arr)-1):
        if arr[i] <= arr[i+1]:
            return False
    
    return True

# Test cases
arr1 = [1, 2, 3, 4, 5, 4, 3, 2]
arr2 = [5, 4, 3, 2]
arr3 = [1, 2]
arr4 = [10]

print(funcImp(arr1))   # True
print(funcImp(arr2))   # True
print(funcImp(arr3))   # False
print(funcImp(arr4))   # False

```",arr4 = [10],FALSE,FALSE,PASS,TRUE,N/A
47,1,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num):
    # Check if the number is negative
    if num < 0:
        return ""Invalid input: Number must be non-negative""

    # Base cases for 0 and 1
    if num == 0 or num == 1:
        return num

    # Binary search to find the square root
    start = 0
    end = num

    while start <= end:
        mid = (start + end) // 2

        # If mid*mid is equal to the number, return mid as the square root
        if mid * mid == num:
            return mid

        # If mid*mid is less than the number, update start to mid+1
        elif mid * mid < num:
            start = mid + 1

            # Check if (mid+1)*(mid+1) is greater than the number,
            # then return mid as the floor value of square root
            if (mid + 1) * (mid + 1) > num:
                return mid

        # If mid*mid is greater than the number, update end to mid-1
        else:
            end = mid - 1

    return ""Square root not found""


# Test cases
test_cases = [4, 9, 16, 25, -4, 0.25]

for test in test_cases:
    result = funcImp(test)
    print(f""Square root of {test}:"", result)
```",4,2,2,PASS,TRUE,N/A
47,2,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num):
    # Check if the number is negative
    if num < 0:
        return ""Invalid input: Number must be non-negative""

    # Base cases for 0 and 1
    if num == 0 or num == 1:
        return num

    # Binary search to find the square root
    start = 0
    end = num

    while start <= end:
        mid = (start + end) // 2

        # If mid*mid is equal to the number, return mid as the square root
        if mid * mid == num:
            return mid

        # If mid*mid is less than the number, update start to mid+1
        elif mid * mid < num:
            start = mid + 1

            # Check if (mid+1)*(mid+1) is greater than the number,
            # then return mid as the floor value of square root
            if (mid + 1) * (mid + 1) > num:
                return mid

        # If mid*mid is greater than the number, update end to mid-1
        else:
            end = mid - 1

    return ""Square root not found""


# Test cases
test_cases = [4, 9, 16, 25, -4, 0.25]

for test in test_cases:
    result = funcImp(test)
    print(f""Square root of {test}:"", result)
```",9,3,3,PASS,TRUE,N/A
47,3,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num):
    # Check if the number is negative
    if num < 0:
        return ""Invalid input: Number must be non-negative""

    # Base cases for 0 and 1
    if num == 0 or num == 1:
        return num

    # Binary search to find the square root
    start = 0
    end = num

    while start <= end:
        mid = (start + end) // 2

        # If mid*mid is equal to the number, return mid as the square root
        if mid * mid == num:
            return mid

        # If mid*mid is less than the number, update start to mid+1
        elif mid * mid < num:
            start = mid + 1

            # Check if (mid+1)*(mid+1) is greater than the number,
            # then return mid as the floor value of square root
            if (mid + 1) * (mid + 1) > num:
                return mid

        # If mid*mid is greater than the number, update end to mid-1
        else:
            end = mid - 1

    return ""Square root not found""


# Test cases
test_cases = [4, 9, 16, 25, -4, 0.25]

for test in test_cases:
    result = funcImp(test)
    print(f""Square root of {test}:"", result)
```",16,4,4,PASS,TRUE,N/A
47,4,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num):
    # Check if the number is negative
    if num < 0:
        return ""Invalid input: Number must be non-negative""

    # Base cases for 0 and 1
    if num == 0 or num == 1:
        return num

    # Binary search to find the square root
    start = 0
    end = num

    while start <= end:
        mid = (start + end) // 2

        # If mid*mid is equal to the number, return mid as the square root
        if mid * mid == num:
            return mid

        # If mid*mid is less than the number, update start to mid+1
        elif mid * mid < num:
            start = mid + 1

            # Check if (mid+1)*(mid+1) is greater than the number,
            # then return mid as the floor value of square root
            if (mid + 1) * (mid + 1) > num:
                return mid

        # If mid*mid is greater than the number, update end to mid-1
        else:
            end = mid - 1

    return ""Square root not found""


# Test cases
test_cases = [4, 9, 16, 25, -4, 0.25]

for test in test_cases:
    result = funcImp(test)
    print(f""Square root of {test}:"", result)
```",25,5,5,PASS,TRUE,N/A
47,5,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num):
    # Check if the number is negative
    if num < 0:
        return ""Invalid input: Number must be non-negative""

    # Base cases for 0 and 1
    if num == 0 or num == 1:
        return num

    # Binary search to find the square root
    start = 0
    end = num

    while start <= end:
        mid = (start + end) // 2

        # If mid*mid is equal to the number, return mid as the square root
        if mid * mid == num:
            return mid

        # If mid*mid is less than the number, update start to mid+1
        elif mid * mid < num:
            start = mid + 1

            # Check if (mid+1)*(mid+1) is greater than the number,
            # then return mid as the floor value of square root
            if (mid + 1) * (mid + 1) > num:
                return mid

        # If mid*mid is greater than the number, update end to mid-1
        else:
            end = mid - 1

    return ""Square root not found""


# Test cases
test_cases = [4, 9, 16, 25, -4, 0.25]

for test in test_cases:
    result = funcImp(test)
    print(f""Square root of {test}:"", result)
```",-4,Invalid input,Invalid input: Number must be non-negative,FAIL,FALSE,N/A
47,6,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num):
    # Check if the number is negative
    if num < 0:
        return ""Invalid input: Number must be non-negative""

    # Base cases for 0 and 1
    if num == 0 or num == 1:
        return num

    # Binary search to find the square root
    start = 0
    end = num

    while start <= end:
        mid = (start + end) // 2

        # If mid*mid is equal to the number, return mid as the square root
        if mid * mid == num:
            return mid

        # If mid*mid is less than the number, update start to mid+1
        elif mid * mid < num:
            start = mid + 1

            # Check if (mid+1)*(mid+1) is greater than the number,
            # then return mid as the floor value of square root
            if (mid + 1) * (mid + 1) > num:
                return mid

        # If mid*mid is greater than the number, update end to mid-1
        else:
            end = mid - 1

    return ""Square root not found""


# Test cases
test_cases = [4, 9, 16, 25, -4, 0.25]

for test in test_cases:
    result = funcImp(test)
    print(f""Square root of {test}:"", result)
```",0.25,0.5,0,FAIL,FALSE,N/A
48,1,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Function to perform DFS traversal
    def dfs(node, visited, component):
        visited[node] = True
        component.append(node)
        for neighbor in graph[node]:
            if not visited[neighbor]:
                dfs(neighbor, visited, component)

    # Initialize variables
    num_nodes = len(graph)
    visited = [False] * num_nodes
    components = []

    # Traverse each node in the graph
    for node in range(num_nodes):
        if not visited[node]:
            component = []
            dfs(node, visited, component)
            components.append(component)

    return components

# Test the function with a sample graph
graph = {
    0: [1, 2],
    1: [0],
    2: [0],
    3: [4],
    4: [3]
}
print(funcImp(graph))
```","{0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3]}","[[0, 1, 2], [3, 4]]",,FAIL,FALSE,name 'graph' is not defined
49,1,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def dfs(node):
    if node is None:
        return
    
    # Process the current node
    print(node.value)
    
    # Recursively traverse the left subtree
    dfs(node.left)
    
    # Recursively traverse the right subtree
    dfs(node.right)

# Test case 1: Create a binary tree with three nodes
root = Node(1)
root.left = Node(2)
root.right = Node(3)

print(""Test case 1:"")
dfs(root)
# Output: 1 2 3

# Test case 2: Create a binary tree with five nodes
root = Node(4)
root.left = Node(5)
root.right = Node(6)
root.left.left = Node(7)
root.left.right = Node(8)

print(""Test case 2:"")
dfs(root)
# Output: 4 5 7 8 6

# Test case 3: Create an empty binary tree
print(""Test case 3:"")
dfs(None)
# Output: (no output)

```","# Test case 1: Create a binary tree with three nodes
root = Node(1)
root.left = Node(2)
root.right = Node(3)","[1, 2, 3]","[1, 2, 3]",PASS,TRUE,N/A
49,2,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def dfs(node):
    if node is None:
        return
    
    # Process the current node
    print(node.value)
    
    # Recursively traverse the left subtree
    dfs(node.left)
    
    # Recursively traverse the right subtree
    dfs(node.right)

# Test case 1: Create a binary tree with three nodes
root = Node(1)
root.left = Node(2)
root.right = Node(3)

print(""Test case 1:"")
dfs(root)
# Output: 1 2 3

# Test case 2: Create a binary tree with five nodes
root = Node(4)
root.left = Node(5)
root.right = Node(6)
root.left.left = Node(7)
root.left.right = Node(8)

print(""Test case 2:"")
dfs(root)
# Output: 4 5 7 8 6

# Test case 3: Create an empty binary tree
print(""Test case 3:"")
dfs(None)
# Output: (no output)

```","# Test case 2: Create a binary tree with five nodes
root = Node(4)
root.left = Node(5)
root.right = Node(6)
root.left.left = Node(7)
root.left.right = Node(8)","[4, 5, 7, 8, 6]","[4, 5, 7, 8, 6]",PASS,TRUE,N/A
49,3,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def dfs(node):
    if node is None:
        return
    
    # Process the current node
    print(node.value)
    
    # Recursively traverse the left subtree
    dfs(node.left)
    
    # Recursively traverse the right subtree
    dfs(node.right)

# Test case 1: Create a binary tree with three nodes
root = Node(1)
root.left = Node(2)
root.right = Node(3)

print(""Test case 1:"")
dfs(root)
# Output: 1 2 3

# Test case 2: Create a binary tree with five nodes
root = Node(4)
root.left = Node(5)
root.right = Node(6)
root.left.left = Node(7)
root.left.right = Node(8)

print(""Test case 2:"")
dfs(root)
# Output: 4 5 7 8 6

# Test case 3: Create an empty binary tree
print(""Test case 3:"")
dfs(None)
# Output: (no output)

```",# Test case 3: Create an empty binary tree,[],,FAIL,FALSE,N/A
50,1,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a visited set to keep track of visited nodes
    visited = set()

    # Create a recursion stack to detect cycles
    recursion_stack = set()

    # Helper function to perform DFS traversal
    def dfs(node):
        # Add the current node to the visited set and recursion stack
        visited.add(node)
        recursion_stack.add(node)

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            # If the neighbor is not visited, recursively call dfs on it
            if neighbor not in visited:
                if dfs(neighbor):
                    return True

            # If the neighbor is already in the recursion stack, a cycle is detected
            elif neighbor in recursion_stack:
                return True

        # Remove the current node from the recursion stack after exploring all its neighbors
        recursion_stack.remove(node)

        return False

    # Iterate over all nodes in the graph and perform DFS traversal on unvisited nodes
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases

# Test case 1: Graph with no cycles
graph1 = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': [],
    'D': []
}
print(funcImp(graph1))  # Output: False

# Test case 2: Graph with a cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}
print(funcImp(graph2))  # Output: True

# Test case 3: Empty graph
graph3 = {}
print(funcImp(graph3))  # Output: False

# Test case 4: Graph with a self-loop (A -> A)
graph4 = {
    'A': ['A']
}
print(funcImp(graph4))  # Output: True
```","{'A': ['B', 'C'], 'B': ['D'], 'C': [], 'D': []}",FALSE,FALSE,PASS,TRUE,N/A
50,2,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a visited set to keep track of visited nodes
    visited = set()

    # Create a recursion stack to detect cycles
    recursion_stack = set()

    # Helper function to perform DFS traversal
    def dfs(node):
        # Add the current node to the visited set and recursion stack
        visited.add(node)
        recursion_stack.add(node)

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            # If the neighbor is not visited, recursively call dfs on it
            if neighbor not in visited:
                if dfs(neighbor):
                    return True

            # If the neighbor is already in the recursion stack, a cycle is detected
            elif neighbor in recursion_stack:
                return True

        # Remove the current node from the recursion stack after exploring all its neighbors
        recursion_stack.remove(node)

        return False

    # Iterate over all nodes in the graph and perform DFS traversal on unvisited nodes
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases

# Test case 1: Graph with no cycles
graph1 = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': [],
    'D': []
}
print(funcImp(graph1))  # Output: False

# Test case 2: Graph with a cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}
print(funcImp(graph2))  # Output: True

# Test case 3: Empty graph
graph3 = {}
print(funcImp(graph3))  # Output: False

# Test case 4: Graph with a self-loop (A -> A)
graph4 = {
    'A': ['A']
}
print(funcImp(graph4))  # Output: True
```","{'A': ['B'], 'B': ['C'], 'C': ['A']}",TRUE,TRUE,PASS,TRUE,N/A
50,3,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a visited set to keep track of visited nodes
    visited = set()

    # Create a recursion stack to detect cycles
    recursion_stack = set()

    # Helper function to perform DFS traversal
    def dfs(node):
        # Add the current node to the visited set and recursion stack
        visited.add(node)
        recursion_stack.add(node)

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            # If the neighbor is not visited, recursively call dfs on it
            if neighbor not in visited:
                if dfs(neighbor):
                    return True

            # If the neighbor is already in the recursion stack, a cycle is detected
            elif neighbor in recursion_stack:
                return True

        # Remove the current node from the recursion stack after exploring all its neighbors
        recursion_stack.remove(node)

        return False

    # Iterate over all nodes in the graph and perform DFS traversal on unvisited nodes
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases

# Test case 1: Graph with no cycles
graph1 = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': [],
    'D': []
}
print(funcImp(graph1))  # Output: False

# Test case 2: Graph with a cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}
print(funcImp(graph2))  # Output: True

# Test case 3: Empty graph
graph3 = {}
print(funcImp(graph3))  # Output: False

# Test case 4: Graph with a self-loop (A -> A)
graph4 = {
    'A': ['A']
}
print(funcImp(graph4))  # Output: True
```",{},FALSE,FALSE,PASS,TRUE,N/A
50,4,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    # Create a visited set to keep track of visited nodes
    visited = set()

    # Create a recursion stack to detect cycles
    recursion_stack = set()

    # Helper function to perform DFS traversal
    def dfs(node):
        # Add the current node to the visited set and recursion stack
        visited.add(node)
        recursion_stack.add(node)

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            # If the neighbor is not visited, recursively call dfs on it
            if neighbor not in visited:
                if dfs(neighbor):
                    return True

            # If the neighbor is already in the recursion stack, a cycle is detected
            elif neighbor in recursion_stack:
                return True

        # Remove the current node from the recursion stack after exploring all its neighbors
        recursion_stack.remove(node)

        return False

    # Iterate over all nodes in the graph and perform DFS traversal on unvisited nodes
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True

    return False


# Test cases

# Test case 1: Graph with no cycles
graph1 = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': [],
    'D': []
}
print(funcImp(graph1))  # Output: False

# Test case 2: Graph with a cycle (A -> B -> C -> A)
graph2 = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}
print(funcImp(graph2))  # Output: True

# Test case 3: Empty graph
graph3 = {}
print(funcImp(graph3))  # Output: False

# Test case 4: Graph with a self-loop (A -> A)
graph4 = {
    'A': ['A']
}
print(funcImp(graph4))  # Output: True
```",{'A': ['A']},TRUE,TRUE,PASS,TRUE,N/A
