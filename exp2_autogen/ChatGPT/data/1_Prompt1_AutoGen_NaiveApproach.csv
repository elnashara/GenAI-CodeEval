problem_number,index,category,problem_type,problem,solution_prompt,solution,test_input,expected,actual,status,pass,exception
1,0,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive integers
    assert funcImp(2, 3) == 5, ""Test case 1 failed""
    
    # Test case 2: Negative integers
    assert funcImp(-1, -1) == -2, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative integers
    assert funcImp(-5, 10) == 5, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the integers
    assert funcImp(0, 5) == 5, ""Test case 4 failed""
    
    # Test case 5: Both integers are zero
    assert funcImp(0, 0) == 0, ""Test case 5 failed""
    
    # Test case 6: Large integers
    assert funcImp(1000000, 2000000) == 3000000, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test cases
run_tests()
```","(2, 3)",5,5,PASS,TRUE,
1,1,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive integers
    assert funcImp(2, 3) == 5, ""Test case 1 failed""
    
    # Test case 2: Negative integers
    assert funcImp(-1, -1) == -2, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative integers
    assert funcImp(-5, 10) == 5, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the integers
    assert funcImp(0, 5) == 5, ""Test case 4 failed""
    
    # Test case 5: Both integers are zero
    assert funcImp(0, 0) == 0, ""Test case 5 failed""
    
    # Test case 6: Large integers
    assert funcImp(1000000, 2000000) == 3000000, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test cases
run_tests()
```","(-1, -1)",-2,-2,PASS,TRUE,
1,2,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive integers
    assert funcImp(2, 3) == 5, ""Test case 1 failed""
    
    # Test case 2: Negative integers
    assert funcImp(-1, -1) == -2, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative integers
    assert funcImp(-5, 10) == 5, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the integers
    assert funcImp(0, 5) == 5, ""Test case 4 failed""
    
    # Test case 5: Both integers are zero
    assert funcImp(0, 0) == 0, ""Test case 5 failed""
    
    # Test case 6: Large integers
    assert funcImp(1000000, 2000000) == 3000000, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test cases
run_tests()
```","(-5, 10)",5,5,PASS,TRUE,
1,3,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive integers
    assert funcImp(2, 3) == 5, ""Test case 1 failed""
    
    # Test case 2: Negative integers
    assert funcImp(-1, -1) == -2, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative integers
    assert funcImp(-5, 10) == 5, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the integers
    assert funcImp(0, 5) == 5, ""Test case 4 failed""
    
    # Test case 5: Both integers are zero
    assert funcImp(0, 0) == 0, ""Test case 5 failed""
    
    # Test case 6: Large integers
    assert funcImp(1000000, 2000000) == 3000000, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test cases
run_tests()
```","(0, 5)",5,5,PASS,TRUE,
1,4,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive integers
    assert funcImp(2, 3) == 5, ""Test case 1 failed""
    
    # Test case 2: Negative integers
    assert funcImp(-1, -1) == -2, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative integers
    assert funcImp(-5, 10) == 5, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the integers
    assert funcImp(0, 5) == 5, ""Test case 4 failed""
    
    # Test case 5: Both integers are zero
    assert funcImp(0, 0) == 0, ""Test case 5 failed""
    
    # Test case 6: Large integers
    assert funcImp(1000000, 2000000) == 3000000, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test cases
run_tests()
```","(0, 0)",0,0,PASS,TRUE,
1,5,easy,Finding the sum of two numbers,Write a program that takes two integers as input and calculates their sum.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program that takes two integers as input and calculates their sum.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(a, b):
    """"""
    This function takes two integers as input and returns their sum.
    
    Parameters:
    a (int): The first integer.
    b (int): The second integer.
    
    Returns:
    int: The sum of the two integers.
    """"""
    return a + b

# Test cases to verify the correctness of the funcImp function
def run_tests():
    # Test case 1: Positive integers
    assert funcImp(2, 3) == 5, ""Test case 1 failed""
    
    # Test case 2: Negative integers
    assert funcImp(-1, -1) == -2, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative integers
    assert funcImp(-5, 10) == 5, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the integers
    assert funcImp(0, 5) == 5, ""Test case 4 failed""
    
    # Test case 5: Both integers are zero
    assert funcImp(0, 0) == 0, ""Test case 5 failed""
    
    # Test case 6: Large integers
    assert funcImp(1000000, 2000000) == 3000000, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test cases
run_tests()
```","(1000000, 2000000)",3000000,3000000,PASS,TRUE,
2,0,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level
def funcImp(a, b):
    """"""
    This function takes two floating-point numbers as input and returns their sum.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of the two input numbers.
    """"""
    return a + b

# Test the function with various test cases
def test_funcImp():
    # Test case 1: Positive numbers
    assert funcImp(1.5, 2.5) == 4.0, ""Test case 1 failed""
    
    # Test case 2: Negative numbers
    assert funcImp(-1.5, -2.5) == -4.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(1.5, -2.5) == -1.0, ""Test case 3 failed""
    
    # Test case 4: Zero
    assert funcImp(0.0, 0.0) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(1e10, 1e10) == 2e10, ""Test case 5 failed""
    
    # Test case 6: Small numbers
    assert funcImp(1e-10, 1e-10) == 2e-10, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test function
test_funcImp()
```","(1.5, 2.5)",4,4,PASS,TRUE,
2,1,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level
def funcImp(a, b):
    """"""
    This function takes two floating-point numbers as input and returns their sum.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of the two input numbers.
    """"""
    return a + b

# Test the function with various test cases
def test_funcImp():
    # Test case 1: Positive numbers
    assert funcImp(1.5, 2.5) == 4.0, ""Test case 1 failed""
    
    # Test case 2: Negative numbers
    assert funcImp(-1.5, -2.5) == -4.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(1.5, -2.5) == -1.0, ""Test case 3 failed""
    
    # Test case 4: Zero
    assert funcImp(0.0, 0.0) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(1e10, 1e10) == 2e10, ""Test case 5 failed""
    
    # Test case 6: Small numbers
    assert funcImp(1e-10, 1e-10) == 2e-10, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test function
test_funcImp()
```","(-1.5, -2.5)",-4,-4,PASS,TRUE,
2,2,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level
def funcImp(a, b):
    """"""
    This function takes two floating-point numbers as input and returns their sum.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of the two input numbers.
    """"""
    return a + b

# Test the function with various test cases
def test_funcImp():
    # Test case 1: Positive numbers
    assert funcImp(1.5, 2.5) == 4.0, ""Test case 1 failed""
    
    # Test case 2: Negative numbers
    assert funcImp(-1.5, -2.5) == -4.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(1.5, -2.5) == -1.0, ""Test case 3 failed""
    
    # Test case 4: Zero
    assert funcImp(0.0, 0.0) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(1e10, 1e10) == 2e10, ""Test case 5 failed""
    
    # Test case 6: Small numbers
    assert funcImp(1e-10, 1e-10) == 2e-10, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test function
test_funcImp()
```","(1.5, -2.5)",-1,-1,PASS,TRUE,
2,3,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level
def funcImp(a, b):
    """"""
    This function takes two floating-point numbers as input and returns their sum.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of the two input numbers.
    """"""
    return a + b

# Test the function with various test cases
def test_funcImp():
    # Test case 1: Positive numbers
    assert funcImp(1.5, 2.5) == 4.0, ""Test case 1 failed""
    
    # Test case 2: Negative numbers
    assert funcImp(-1.5, -2.5) == -4.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(1.5, -2.5) == -1.0, ""Test case 3 failed""
    
    # Test case 4: Zero
    assert funcImp(0.0, 0.0) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(1e10, 1e10) == 2e10, ""Test case 5 failed""
    
    # Test case 6: Small numbers
    assert funcImp(1e-10, 1e-10) == 2e-10, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test function
test_funcImp()
```","(0.0, 0.0)",0,0,PASS,TRUE,
2,4,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level
def funcImp(a, b):
    """"""
    This function takes two floating-point numbers as input and returns their sum.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of the two input numbers.
    """"""
    return a + b

# Test the function with various test cases
def test_funcImp():
    # Test case 1: Positive numbers
    assert funcImp(1.5, 2.5) == 4.0, ""Test case 1 failed""
    
    # Test case 2: Negative numbers
    assert funcImp(-1.5, -2.5) == -4.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(1.5, -2.5) == -1.0, ""Test case 3 failed""
    
    # Test case 4: Zero
    assert funcImp(0.0, 0.0) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(1e10, 1e10) == 2e10, ""Test case 5 failed""
    
    # Test case 6: Small numbers
    assert funcImp(1e-10, 1e-10) == 2e-10, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test function
test_funcImp()
```","(10000000000.0, 10000000000.0)",20000000000,20000000000,PASS,TRUE,
2,5,easy,Finding the sum of two numbers,Implement a function that returns the sum of two floating-point numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the sum of two floating-point numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Define the function 'funcImp' at the root level
def funcImp(a, b):
    """"""
    This function takes two floating-point numbers as input and returns their sum.
    
    Parameters:
    a (float): The first floating-point number.
    b (float): The second floating-point number.
    
    Returns:
    float: The sum of the two input numbers.
    """"""
    return a + b

# Test the function with various test cases
def test_funcImp():
    # Test case 1: Positive numbers
    assert funcImp(1.5, 2.5) == 4.0, ""Test case 1 failed""
    
    # Test case 2: Negative numbers
    assert funcImp(-1.5, -2.5) == -4.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(1.5, -2.5) == -1.0, ""Test case 3 failed""
    
    # Test case 4: Zero
    assert funcImp(0.0, 0.0) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(1e10, 1e10) == 2e10, ""Test case 5 failed""
    
    # Test case 6: Small numbers
    assert funcImp(1e-10, 1e-10) == 2e-10, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Execute the test function
test_funcImp()
```","(1e-10, 1e-10)",2.00E-10,2.00E-10,PASS,TRUE,
3,0,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings as input, converts them to integers,
    and returns their sum. If the strings cannot be converted to integers,
    it raises a ValueError.
    
    Parameters:
    num_str1 (str): The first numeric string.
    num_str2 (str): The second numeric string.
    
    Returns:
    int: The sum of the two integers.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(num_str1)
        num2 = int(num_str2)
        
        # Return the sum of the two integers
        return num1 + num2
    except ValueError:
        # Raise an error if the conversion fails
        raise ValueError(""Both inputs must be strings representing integers."")

# Test cases to verify the correctness of the function
def run_tests():
    # Test case 1: Normal case with positive numbers
    assert funcImp(""123"", ""456"") == 579, ""Test case 1 failed""
    
    # Test case 2: Normal case with negative numbers
    assert funcImp(""-123"", ""-456"") == -579, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(""123"", ""-456"") == -333, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the inputs
    assert funcImp(""0"", ""456"") == 456, ""Test case 4 failed""
    
    # Test case 5: Both inputs are zero
    assert funcImp(""0"", ""0"") == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp(""12345678901234567890"", ""98765432109876543210"") == 111111111011111111100, ""Test case 6 failed""
    
    # Test case 7: Invalid input (non-numeric string)
    try:
        funcImp(""abc"", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 7 failed""
    
    # Test case 8: Empty string input
    try:
        funcImp("""", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
run_tests()
```","('123', '456')",579,579,PASS,TRUE,
3,1,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings as input, converts them to integers,
    and returns their sum. If the strings cannot be converted to integers,
    it raises a ValueError.
    
    Parameters:
    num_str1 (str): The first numeric string.
    num_str2 (str): The second numeric string.
    
    Returns:
    int: The sum of the two integers.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(num_str1)
        num2 = int(num_str2)
        
        # Return the sum of the two integers
        return num1 + num2
    except ValueError:
        # Raise an error if the conversion fails
        raise ValueError(""Both inputs must be strings representing integers."")

# Test cases to verify the correctness of the function
def run_tests():
    # Test case 1: Normal case with positive numbers
    assert funcImp(""123"", ""456"") == 579, ""Test case 1 failed""
    
    # Test case 2: Normal case with negative numbers
    assert funcImp(""-123"", ""-456"") == -579, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(""123"", ""-456"") == -333, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the inputs
    assert funcImp(""0"", ""456"") == 456, ""Test case 4 failed""
    
    # Test case 5: Both inputs are zero
    assert funcImp(""0"", ""0"") == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp(""12345678901234567890"", ""98765432109876543210"") == 111111111011111111100, ""Test case 6 failed""
    
    # Test case 7: Invalid input (non-numeric string)
    try:
        funcImp(""abc"", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 7 failed""
    
    # Test case 8: Empty string input
    try:
        funcImp("""", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
run_tests()
```","('-123', '-456')",-579,-579,PASS,TRUE,
3,2,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings as input, converts them to integers,
    and returns their sum. If the strings cannot be converted to integers,
    it raises a ValueError.
    
    Parameters:
    num_str1 (str): The first numeric string.
    num_str2 (str): The second numeric string.
    
    Returns:
    int: The sum of the two integers.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(num_str1)
        num2 = int(num_str2)
        
        # Return the sum of the two integers
        return num1 + num2
    except ValueError:
        # Raise an error if the conversion fails
        raise ValueError(""Both inputs must be strings representing integers."")

# Test cases to verify the correctness of the function
def run_tests():
    # Test case 1: Normal case with positive numbers
    assert funcImp(""123"", ""456"") == 579, ""Test case 1 failed""
    
    # Test case 2: Normal case with negative numbers
    assert funcImp(""-123"", ""-456"") == -579, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(""123"", ""-456"") == -333, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the inputs
    assert funcImp(""0"", ""456"") == 456, ""Test case 4 failed""
    
    # Test case 5: Both inputs are zero
    assert funcImp(""0"", ""0"") == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp(""12345678901234567890"", ""98765432109876543210"") == 111111111011111111100, ""Test case 6 failed""
    
    # Test case 7: Invalid input (non-numeric string)
    try:
        funcImp(""abc"", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 7 failed""
    
    # Test case 8: Empty string input
    try:
        funcImp("""", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
run_tests()
```","('123', '-456')",-333,-333,PASS,TRUE,
3,3,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings as input, converts them to integers,
    and returns their sum. If the strings cannot be converted to integers,
    it raises a ValueError.
    
    Parameters:
    num_str1 (str): The first numeric string.
    num_str2 (str): The second numeric string.
    
    Returns:
    int: The sum of the two integers.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(num_str1)
        num2 = int(num_str2)
        
        # Return the sum of the two integers
        return num1 + num2
    except ValueError:
        # Raise an error if the conversion fails
        raise ValueError(""Both inputs must be strings representing integers."")

# Test cases to verify the correctness of the function
def run_tests():
    # Test case 1: Normal case with positive numbers
    assert funcImp(""123"", ""456"") == 579, ""Test case 1 failed""
    
    # Test case 2: Normal case with negative numbers
    assert funcImp(""-123"", ""-456"") == -579, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(""123"", ""-456"") == -333, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the inputs
    assert funcImp(""0"", ""456"") == 456, ""Test case 4 failed""
    
    # Test case 5: Both inputs are zero
    assert funcImp(""0"", ""0"") == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp(""12345678901234567890"", ""98765432109876543210"") == 111111111011111111100, ""Test case 6 failed""
    
    # Test case 7: Invalid input (non-numeric string)
    try:
        funcImp(""abc"", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 7 failed""
    
    # Test case 8: Empty string input
    try:
        funcImp("""", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
run_tests()
```","('0', '456')",456,456,PASS,TRUE,
3,4,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings as input, converts them to integers,
    and returns their sum. If the strings cannot be converted to integers,
    it raises a ValueError.
    
    Parameters:
    num_str1 (str): The first numeric string.
    num_str2 (str): The second numeric string.
    
    Returns:
    int: The sum of the two integers.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(num_str1)
        num2 = int(num_str2)
        
        # Return the sum of the two integers
        return num1 + num2
    except ValueError:
        # Raise an error if the conversion fails
        raise ValueError(""Both inputs must be strings representing integers."")

# Test cases to verify the correctness of the function
def run_tests():
    # Test case 1: Normal case with positive numbers
    assert funcImp(""123"", ""456"") == 579, ""Test case 1 failed""
    
    # Test case 2: Normal case with negative numbers
    assert funcImp(""-123"", ""-456"") == -579, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(""123"", ""-456"") == -333, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the inputs
    assert funcImp(""0"", ""456"") == 456, ""Test case 4 failed""
    
    # Test case 5: Both inputs are zero
    assert funcImp(""0"", ""0"") == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp(""12345678901234567890"", ""98765432109876543210"") == 111111111011111111100, ""Test case 6 failed""
    
    # Test case 7: Invalid input (non-numeric string)
    try:
        funcImp(""abc"", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 7 failed""
    
    # Test case 8: Empty string input
    try:
        funcImp("""", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
run_tests()
```","('0', '0')",0,0,PASS,TRUE,
3,5,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings as input, converts them to integers,
    and returns their sum. If the strings cannot be converted to integers,
    it raises a ValueError.
    
    Parameters:
    num_str1 (str): The first numeric string.
    num_str2 (str): The second numeric string.
    
    Returns:
    int: The sum of the two integers.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(num_str1)
        num2 = int(num_str2)
        
        # Return the sum of the two integers
        return num1 + num2
    except ValueError:
        # Raise an error if the conversion fails
        raise ValueError(""Both inputs must be strings representing integers."")

# Test cases to verify the correctness of the function
def run_tests():
    # Test case 1: Normal case with positive numbers
    assert funcImp(""123"", ""456"") == 579, ""Test case 1 failed""
    
    # Test case 2: Normal case with negative numbers
    assert funcImp(""-123"", ""-456"") == -579, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(""123"", ""-456"") == -333, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the inputs
    assert funcImp(""0"", ""456"") == 456, ""Test case 4 failed""
    
    # Test case 5: Both inputs are zero
    assert funcImp(""0"", ""0"") == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp(""12345678901234567890"", ""98765432109876543210"") == 111111111011111111100, ""Test case 6 failed""
    
    # Test case 7: Invalid input (non-numeric string)
    try:
        funcImp(""abc"", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 7 failed""
    
    # Test case 8: Empty string input
    try:
        funcImp("""", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
run_tests()
```","('12345678901234567890', '98765432109876543210')",1.11E+20,1.11E+20,PASS,TRUE,
3,6,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings as input, converts them to integers,
    and returns their sum. If the strings cannot be converted to integers,
    it raises a ValueError.
    
    Parameters:
    num_str1 (str): The first numeric string.
    num_str2 (str): The second numeric string.
    
    Returns:
    int: The sum of the two integers.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(num_str1)
        num2 = int(num_str2)
        
        # Return the sum of the two integers
        return num1 + num2
    except ValueError:
        # Raise an error if the conversion fails
        raise ValueError(""Both inputs must be strings representing integers."")

# Test cases to verify the correctness of the function
def run_tests():
    # Test case 1: Normal case with positive numbers
    assert funcImp(""123"", ""456"") == 579, ""Test case 1 failed""
    
    # Test case 2: Normal case with negative numbers
    assert funcImp(""-123"", ""-456"") == -579, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(""123"", ""-456"") == -333, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the inputs
    assert funcImp(""0"", ""456"") == 456, ""Test case 4 failed""
    
    # Test case 5: Both inputs are zero
    assert funcImp(""0"", ""0"") == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp(""12345678901234567890"", ""98765432109876543210"") == 111111111011111111100, ""Test case 6 failed""
    
    # Test case 7: Invalid input (non-numeric string)
    try:
        funcImp(""abc"", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 7 failed""
    
    # Test case 8: Empty string input
    try:
        funcImp("""", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
run_tests()
```","('abc', '123')",,,PASS,TRUE,Both inputs must be strings representing integers.
3,7,easy,Finding the sum of two numbers,"Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.","## Problem Statement
        - Develop a Python script to solve the problem: 'Write a function that takes two strings containing numeric values, converts them to integers, and returns their sum.'

        ## Solution Development
        - Create a Python function named 'funcImp' that implements the solution.
        - Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

        ## Script Requirements
        - The script should define the 'funcImp' function at the root level, not inside any class or other function.
        - Include comments in the script to explain the logic and functionality of the 'funcImp' function.
        - Test the function within the script to ensure it's correctly defined and functioning as expected.

        ## Test Case Execution
        - Execute the 'funcImp' function with various test cases to verify its correctness.
        - Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

        ## Test Case Preparation
        - Prepare a set of test cases, including edge cases, to thoroughly test the function.
        - Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

        ## Execution Process
        - Run each test case through the 'funcImp' function.
        - Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_str1, num_str2):
    """"""
    This function takes two strings as input, converts them to integers,
    and returns their sum. If the strings cannot be converted to integers,
    it raises a ValueError.
    
    Parameters:
    num_str1 (str): The first numeric string.
    num_str2 (str): The second numeric string.
    
    Returns:
    int: The sum of the two integers.
    """"""
    try:
        # Convert the input strings to integers
        num1 = int(num_str1)
        num2 = int(num_str2)
        
        # Return the sum of the two integers
        return num1 + num2
    except ValueError:
        # Raise an error if the conversion fails
        raise ValueError(""Both inputs must be strings representing integers."")

# Test cases to verify the correctness of the function
def run_tests():
    # Test case 1: Normal case with positive numbers
    assert funcImp(""123"", ""456"") == 579, ""Test case 1 failed""
    
    # Test case 2: Normal case with negative numbers
    assert funcImp(""-123"", ""-456"") == -579, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp(""123"", ""-456"") == -333, ""Test case 3 failed""
    
    # Test case 4: Zero as one of the inputs
    assert funcImp(""0"", ""456"") == 456, ""Test case 4 failed""
    
    # Test case 5: Both inputs are zero
    assert funcImp(""0"", ""0"") == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp(""12345678901234567890"", ""98765432109876543210"") == 111111111011111111100, ""Test case 6 failed""
    
    # Test case 7: Invalid input (non-numeric string)
    try:
        funcImp(""abc"", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 7 failed""
    
    # Test case 8: Empty string input
    try:
        funcImp("""", ""123"")
    except ValueError:
        pass
    else:
        assert False, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
run_tests()
```","('', '123')",,,PASS,TRUE,Both inputs must be strings representing integers.
4,0,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum as a binary string.
    
    Parameters:
    bin1 (str): A binary number represented as a string.
    bin2 (str): Another binary number represented as a string.
    
    Returns:
    str: The sum of the two binary numbers represented as a binary string.
    """"""
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    # Calculate the sum of the two integers
    sum_num = num1 + num2
    
    # Convert the sum back to a binary string and remove the '0b' prefix
    return bin(sum_num)[2:]

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Simple addition
    assert funcImp(""101"", ""110"") == ""1011"", ""Test case 1 failed""
    
    # Test case 2: Addition with carry
    assert funcImp(""1111"", ""1"") == ""10000"", ""Test case 2 failed""
    
    # Test case 3: Zero addition
    assert funcImp(""0"", ""0"") == ""0"", ""Test case 3 failed""
    
    # Test case 4: Different lengths
    assert funcImp(""1010"", ""110"") == ""10000"", ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(""110110101011"", ""101010101010"") == ""1100001010101"", ""Test case 5 failed""
    
    # Test case 6: One operand is zero
    assert funcImp(""0"", ""101010"") == ""101010"", ""Test case 6 failed""
    
    # Test case 7: Both operands are the same
    assert funcImp(""111"", ""111"") == ""1110"", ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(101, 110)",1011,1011,PASS,TRUE,
4,1,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum as a binary string.
    
    Parameters:
    bin1 (str): A binary number represented as a string.
    bin2 (str): Another binary number represented as a string.
    
    Returns:
    str: The sum of the two binary numbers represented as a binary string.
    """"""
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    # Calculate the sum of the two integers
    sum_num = num1 + num2
    
    # Convert the sum back to a binary string and remove the '0b' prefix
    return bin(sum_num)[2:]

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Simple addition
    assert funcImp(""101"", ""110"") == ""1011"", ""Test case 1 failed""
    
    # Test case 2: Addition with carry
    assert funcImp(""1111"", ""1"") == ""10000"", ""Test case 2 failed""
    
    # Test case 3: Zero addition
    assert funcImp(""0"", ""0"") == ""0"", ""Test case 3 failed""
    
    # Test case 4: Different lengths
    assert funcImp(""1010"", ""110"") == ""10000"", ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(""110110101011"", ""101010101010"") == ""1100001010101"", ""Test case 5 failed""
    
    # Test case 6: One operand is zero
    assert funcImp(""0"", ""101010"") == ""101010"", ""Test case 6 failed""
    
    # Test case 7: Both operands are the same
    assert funcImp(""111"", ""111"") == ""1110"", ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(1111, 1)",10000,10000,PASS,TRUE,
4,2,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum as a binary string.
    
    Parameters:
    bin1 (str): A binary number represented as a string.
    bin2 (str): Another binary number represented as a string.
    
    Returns:
    str: The sum of the two binary numbers represented as a binary string.
    """"""
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    # Calculate the sum of the two integers
    sum_num = num1 + num2
    
    # Convert the sum back to a binary string and remove the '0b' prefix
    return bin(sum_num)[2:]

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Simple addition
    assert funcImp(""101"", ""110"") == ""1011"", ""Test case 1 failed""
    
    # Test case 2: Addition with carry
    assert funcImp(""1111"", ""1"") == ""10000"", ""Test case 2 failed""
    
    # Test case 3: Zero addition
    assert funcImp(""0"", ""0"") == ""0"", ""Test case 3 failed""
    
    # Test case 4: Different lengths
    assert funcImp(""1010"", ""110"") == ""10000"", ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(""110110101011"", ""101010101010"") == ""1100001010101"", ""Test case 5 failed""
    
    # Test case 6: One operand is zero
    assert funcImp(""0"", ""101010"") == ""101010"", ""Test case 6 failed""
    
    # Test case 7: Both operands are the same
    assert funcImp(""111"", ""111"") == ""1110"", ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(0, 0)",0,0,PASS,TRUE,
4,3,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum as a binary string.
    
    Parameters:
    bin1 (str): A binary number represented as a string.
    bin2 (str): Another binary number represented as a string.
    
    Returns:
    str: The sum of the two binary numbers represented as a binary string.
    """"""
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    # Calculate the sum of the two integers
    sum_num = num1 + num2
    
    # Convert the sum back to a binary string and remove the '0b' prefix
    return bin(sum_num)[2:]

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Simple addition
    assert funcImp(""101"", ""110"") == ""1011"", ""Test case 1 failed""
    
    # Test case 2: Addition with carry
    assert funcImp(""1111"", ""1"") == ""10000"", ""Test case 2 failed""
    
    # Test case 3: Zero addition
    assert funcImp(""0"", ""0"") == ""0"", ""Test case 3 failed""
    
    # Test case 4: Different lengths
    assert funcImp(""1010"", ""110"") == ""10000"", ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(""110110101011"", ""101010101010"") == ""1100001010101"", ""Test case 5 failed""
    
    # Test case 6: One operand is zero
    assert funcImp(""0"", ""101010"") == ""101010"", ""Test case 6 failed""
    
    # Test case 7: Both operands are the same
    assert funcImp(""111"", ""111"") == ""1110"", ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(1010, 110)",10000,10000,PASS,TRUE,
4,4,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum as a binary string.
    
    Parameters:
    bin1 (str): A binary number represented as a string.
    bin2 (str): Another binary number represented as a string.
    
    Returns:
    str: The sum of the two binary numbers represented as a binary string.
    """"""
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    # Calculate the sum of the two integers
    sum_num = num1 + num2
    
    # Convert the sum back to a binary string and remove the '0b' prefix
    return bin(sum_num)[2:]

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Simple addition
    assert funcImp(""101"", ""110"") == ""1011"", ""Test case 1 failed""
    
    # Test case 2: Addition with carry
    assert funcImp(""1111"", ""1"") == ""10000"", ""Test case 2 failed""
    
    # Test case 3: Zero addition
    assert funcImp(""0"", ""0"") == ""0"", ""Test case 3 failed""
    
    # Test case 4: Different lengths
    assert funcImp(""1010"", ""110"") == ""10000"", ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(""110110101011"", ""101010101010"") == ""1100001010101"", ""Test case 5 failed""
    
    # Test case 6: One operand is zero
    assert funcImp(""0"", ""101010"") == ""101010"", ""Test case 6 failed""
    
    # Test case 7: Both operands are the same
    assert funcImp(""111"", ""111"") == ""1110"", ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(110110101011, 101010101010)",1.10E+12,1.10E+12,PASS,TRUE,
4,5,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum as a binary string.
    
    Parameters:
    bin1 (str): A binary number represented as a string.
    bin2 (str): Another binary number represented as a string.
    
    Returns:
    str: The sum of the two binary numbers represented as a binary string.
    """"""
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    # Calculate the sum of the two integers
    sum_num = num1 + num2
    
    # Convert the sum back to a binary string and remove the '0b' prefix
    return bin(sum_num)[2:]

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Simple addition
    assert funcImp(""101"", ""110"") == ""1011"", ""Test case 1 failed""
    
    # Test case 2: Addition with carry
    assert funcImp(""1111"", ""1"") == ""10000"", ""Test case 2 failed""
    
    # Test case 3: Zero addition
    assert funcImp(""0"", ""0"") == ""0"", ""Test case 3 failed""
    
    # Test case 4: Different lengths
    assert funcImp(""1010"", ""110"") == ""10000"", ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(""110110101011"", ""101010101010"") == ""1100001010101"", ""Test case 5 failed""
    
    # Test case 6: One operand is zero
    assert funcImp(""0"", ""101010"") == ""101010"", ""Test case 6 failed""
    
    # Test case 7: Both operands are the same
    assert funcImp(""111"", ""111"") == ""1110"", ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(0, 101010)",101010,101010,PASS,TRUE,
4,6,easy,Finding the sum of two numbers,Develop an algorithm to find the sum of two binary numbers represented as strings.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of two binary numbers represented as strings.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(bin1, bin2):
    """"""
    This function takes two binary numbers represented as strings and returns their sum as a binary string.
    
    Parameters:
    bin1 (str): A binary number represented as a string.
    bin2 (str): Another binary number represented as a string.
    
    Returns:
    str: The sum of the two binary numbers represented as a binary string.
    """"""
    # Convert binary strings to integers
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    # Calculate the sum of the two integers
    sum_num = num1 + num2
    
    # Convert the sum back to a binary string and remove the '0b' prefix
    return bin(sum_num)[2:]

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Simple addition
    assert funcImp(""101"", ""110"") == ""1011"", ""Test case 1 failed""
    
    # Test case 2: Addition with carry
    assert funcImp(""1111"", ""1"") == ""10000"", ""Test case 2 failed""
    
    # Test case 3: Zero addition
    assert funcImp(""0"", ""0"") == ""0"", ""Test case 3 failed""
    
    # Test case 4: Different lengths
    assert funcImp(""1010"", ""110"") == ""10000"", ""Test case 4 failed""
    
    # Test case 5: Large numbers
    assert funcImp(""110110101011"", ""101010101010"") == ""1100001010101"", ""Test case 5 failed""
    
    # Test case 6: One operand is zero
    assert funcImp(""0"", ""101010"") == ""101010"", ""Test case 6 failed""
    
    # Test case 7: Both operands are the same
    assert funcImp(""111"", ""111"") == ""1110"", ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(111, 111)",1110,1110,PASS,TRUE,
5,0,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end, inclusive.
    """"""
    # Initialize the sum to 0
    total_sum = 0
    
    # Iterate through the range from start to end, inclusive
    for num in range(start, end + 1):
        # Check if the number is odd
        if num % 2 != 0:
            # Add the odd number to the total sum
            total_sum += num
    
    # Return the total sum of odd numbers
    return total_sum

# Test cases to verify the correctness of the function
print(funcImp(1, 10))  # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(5, 15))  # Expected output: 55 (5 + 7 + 9 + 11 + 13 + 15)
print(funcImp(0, 0))   # Expected output: 0 (no odd numbers)
print(funcImp(-5, 5))  # Expected output: 0 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(10, 20)) # Expected output: 75 (11 + 13 + 15 + 17 + 19)
```","(1, 10)",25,25,PASS,TRUE,
5,1,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end, inclusive.
    """"""
    # Initialize the sum to 0
    total_sum = 0
    
    # Iterate through the range from start to end, inclusive
    for num in range(start, end + 1):
        # Check if the number is odd
        if num % 2 != 0:
            # Add the odd number to the total sum
            total_sum += num
    
    # Return the total sum of odd numbers
    return total_sum

# Test cases to verify the correctness of the function
print(funcImp(1, 10))  # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(5, 15))  # Expected output: 55 (5 + 7 + 9 + 11 + 13 + 15)
print(funcImp(0, 0))   # Expected output: 0 (no odd numbers)
print(funcImp(-5, 5))  # Expected output: 0 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(10, 20)) # Expected output: 75 (11 + 13 + 15 + 17 + 19)
```","(5, 15)",60,60,PASS,TRUE,
5,2,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end, inclusive.
    """"""
    # Initialize the sum to 0
    total_sum = 0
    
    # Iterate through the range from start to end, inclusive
    for num in range(start, end + 1):
        # Check if the number is odd
        if num % 2 != 0:
            # Add the odd number to the total sum
            total_sum += num
    
    # Return the total sum of odd numbers
    return total_sum

# Test cases to verify the correctness of the function
print(funcImp(1, 10))  # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(5, 15))  # Expected output: 55 (5 + 7 + 9 + 11 + 13 + 15)
print(funcImp(0, 0))   # Expected output: 0 (no odd numbers)
print(funcImp(-5, 5))  # Expected output: 0 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(10, 20)) # Expected output: 75 (11 + 13 + 15 + 17 + 19)
```","(0, 0)",0,0,PASS,TRUE,
5,3,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end, inclusive.
    """"""
    # Initialize the sum to 0
    total_sum = 0
    
    # Iterate through the range from start to end, inclusive
    for num in range(start, end + 1):
        # Check if the number is odd
        if num % 2 != 0:
            # Add the odd number to the total sum
            total_sum += num
    
    # Return the total sum of odd numbers
    return total_sum

# Test cases to verify the correctness of the function
print(funcImp(1, 10))  # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(5, 15))  # Expected output: 55 (5 + 7 + 9 + 11 + 13 + 15)
print(funcImp(0, 0))   # Expected output: 0 (no odd numbers)
print(funcImp(-5, 5))  # Expected output: 0 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(10, 20)) # Expected output: 75 (11 + 13 + 15 + 17 + 19)
```","(-5, 5)",0,0,PASS,TRUE,
5,4,easy,Finding the sum of two numbers,Create a function that finds the sum of all odd numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a function that finds the sum of all odd numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all odd numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer.
    end (int): The ending integer.
    
    Returns:
    int: The sum of all odd numbers between start and end, inclusive.
    """"""
    # Initialize the sum to 0
    total_sum = 0
    
    # Iterate through the range from start to end, inclusive
    for num in range(start, end + 1):
        # Check if the number is odd
        if num % 2 != 0:
            # Add the odd number to the total sum
            total_sum += num
    
    # Return the total sum of odd numbers
    return total_sum

# Test cases to verify the correctness of the function
print(funcImp(1, 10))  # Expected output: 25 (1 + 3 + 5 + 7 + 9)
print(funcImp(5, 15))  # Expected output: 55 (5 + 7 + 9 + 11 + 13 + 15)
print(funcImp(0, 0))   # Expected output: 0 (no odd numbers)
print(funcImp(-5, 5))  # Expected output: 0 (-5 + -3 + -1 + 1 + 3 + 5)
print(funcImp(10, 20)) # Expected output: 75 (11 + 13 + 15 + 17 + 19)
```","(10, 20)",75,75,PASS,TRUE,
6,0,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    int: The sum of all prime numbers between start and end (inclusive).
    """"""
    
    def is_prime(n):
        """"""
        Helper function to determine if a number is prime.
        
        Parameters:
        n (int): The number to check for primality.
        
        Returns:
        bool: True if n is a prime number, False otherwise.
        """"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Calculate the sum of all prime numbers in the range [start, end]
    prime_sum = 0
    for num in range(start, end + 1):
        if is_prime(num):
            prime_sum += num
    
    return prime_sum

# Test cases to verify the correctness of the function
print(funcImp(10, 20))  # Expected output: 60 (primes are 11, 13, 17, 19)
print(funcImp(1, 10))   # Expected output: 17 (primes are 2, 3, 5, 7)
print(funcImp(20, 30))  # Expected output: 52 (primes are 23, 29)
print(funcImp(0, 1))    # Expected output: 0 (no primes)
print(funcImp(2, 2))    # Expected output: 2 (2 is prime)
```","(10, 20)",60,60,PASS,TRUE,
6,1,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    int: The sum of all prime numbers between start and end (inclusive).
    """"""
    
    def is_prime(n):
        """"""
        Helper function to determine if a number is prime.
        
        Parameters:
        n (int): The number to check for primality.
        
        Returns:
        bool: True if n is a prime number, False otherwise.
        """"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Calculate the sum of all prime numbers in the range [start, end]
    prime_sum = 0
    for num in range(start, end + 1):
        if is_prime(num):
            prime_sum += num
    
    return prime_sum

# Test cases to verify the correctness of the function
print(funcImp(10, 20))  # Expected output: 60 (primes are 11, 13, 17, 19)
print(funcImp(1, 10))   # Expected output: 17 (primes are 2, 3, 5, 7)
print(funcImp(20, 30))  # Expected output: 52 (primes are 23, 29)
print(funcImp(0, 1))    # Expected output: 0 (no primes)
print(funcImp(2, 2))    # Expected output: 2 (2 is prime)
```","(1, 10)",17,17,PASS,TRUE,
6,2,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    int: The sum of all prime numbers between start and end (inclusive).
    """"""
    
    def is_prime(n):
        """"""
        Helper function to determine if a number is prime.
        
        Parameters:
        n (int): The number to check for primality.
        
        Returns:
        bool: True if n is a prime number, False otherwise.
        """"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Calculate the sum of all prime numbers in the range [start, end]
    prime_sum = 0
    for num in range(start, end + 1):
        if is_prime(num):
            prime_sum += num
    
    return prime_sum

# Test cases to verify the correctness of the function
print(funcImp(10, 20))  # Expected output: 60 (primes are 11, 13, 17, 19)
print(funcImp(1, 10))   # Expected output: 17 (primes are 2, 3, 5, 7)
print(funcImp(20, 30))  # Expected output: 52 (primes are 23, 29)
print(funcImp(0, 1))    # Expected output: 0 (no primes)
print(funcImp(2, 2))    # Expected output: 2 (2 is prime)
```","(20, 30)",52,52,PASS,TRUE,
6,3,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    int: The sum of all prime numbers between start and end (inclusive).
    """"""
    
    def is_prime(n):
        """"""
        Helper function to determine if a number is prime.
        
        Parameters:
        n (int): The number to check for primality.
        
        Returns:
        bool: True if n is a prime number, False otherwise.
        """"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Calculate the sum of all prime numbers in the range [start, end]
    prime_sum = 0
    for num in range(start, end + 1):
        if is_prime(num):
            prime_sum += num
    
    return prime_sum

# Test cases to verify the correctness of the function
print(funcImp(10, 20))  # Expected output: 60 (primes are 11, 13, 17, 19)
print(funcImp(1, 10))   # Expected output: 17 (primes are 2, 3, 5, 7)
print(funcImp(20, 30))  # Expected output: 52 (primes are 23, 29)
print(funcImp(0, 1))    # Expected output: 0 (no primes)
print(funcImp(2, 2))    # Expected output: 2 (2 is prime)
```","(0, 1)",0,0,PASS,TRUE,
6,4,easy,Finding the sum of two numbers,Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write an algorithm to find the sum of all prime numbers between two given integers (inclusive).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers between two given integers (inclusive).
    
    Parameters:
    start (int): The starting integer of the range.
    end (int): The ending integer of the range.
    
    Returns:
    int: The sum of all prime numbers between start and end (inclusive).
    """"""
    
    def is_prime(n):
        """"""
        Helper function to determine if a number is prime.
        
        Parameters:
        n (int): The number to check for primality.
        
        Returns:
        bool: True if n is a prime number, False otherwise.
        """"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Calculate the sum of all prime numbers in the range [start, end]
    prime_sum = 0
    for num in range(start, end + 1):
        if is_prime(num):
            prime_sum += num
    
    return prime_sum

# Test cases to verify the correctness of the function
print(funcImp(10, 20))  # Expected output: 60 (primes are 11, 13, 17, 19)
print(funcImp(1, 10))   # Expected output: 17 (primes are 2, 3, 5, 7)
print(funcImp(20, 30))  # Expected output: 52 (primes are 23, 29)
print(funcImp(0, 1))    # Expected output: 0 (no primes)
print(funcImp(2, 2))    # Expected output: 2 (2 is prime)
```","(2, 2)",2,2,PASS,TRUE,
7,0,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.

    Parameters:
    numbers (list): A list of numbers (int or float).

    Returns:
    float: The average of the numbers in the list.
    """"""
    if not numbers:  # Check if the list is empty
        return 0.0

    total_sum = 0  # Initialize sum to 0
    count = 0  # Initialize count to 0

    # Iterate over the list to calculate the sum
    for number in numbers:
        total_sum += number
        count += 1

    # Calculate the average
    average = total_sum / count

    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: List with a mix of positive and negative numbers
    assert funcImp([-1, 2, -3, 4, -5]) == -0.6, ""Test case 3 failed""
    
    # Test case 4: List with a single number
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0.0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,
7,1,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.

    Parameters:
    numbers (list): A list of numbers (int or float).

    Returns:
    float: The average of the numbers in the list.
    """"""
    if not numbers:  # Check if the list is empty
        return 0.0

    total_sum = 0  # Initialize sum to 0
    count = 0  # Initialize count to 0

    # Iterate over the list to calculate the sum
    for number in numbers:
        total_sum += number
        count += 1

    # Calculate the average
    average = total_sum / count

    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: List with a mix of positive and negative numbers
    assert funcImp([-1, 2, -3, 4, -5]) == -0.6, ""Test case 3 failed""
    
    # Test case 4: List with a single number
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0.0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, -2, -3, -4, -5]",-3,-3,PASS,TRUE,
7,2,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.

    Parameters:
    numbers (list): A list of numbers (int or float).

    Returns:
    float: The average of the numbers in the list.
    """"""
    if not numbers:  # Check if the list is empty
        return 0.0

    total_sum = 0  # Initialize sum to 0
    count = 0  # Initialize count to 0

    # Iterate over the list to calculate the sum
    for number in numbers:
        total_sum += number
        count += 1

    # Calculate the average
    average = total_sum / count

    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: List with a mix of positive and negative numbers
    assert funcImp([-1, 2, -3, 4, -5]) == -0.6, ""Test case 3 failed""
    
    # Test case 4: List with a single number
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0.0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, 2, -3, 4, -5]",-0.6,-0.6,PASS,TRUE,
7,3,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.

    Parameters:
    numbers (list): A list of numbers (int or float).

    Returns:
    float: The average of the numbers in the list.
    """"""
    if not numbers:  # Check if the list is empty
        return 0.0

    total_sum = 0  # Initialize sum to 0
    count = 0  # Initialize count to 0

    # Iterate over the list to calculate the sum
    for number in numbers:
        total_sum += number
        count += 1

    # Calculate the average
    average = total_sum / count

    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: List with a mix of positive and negative numbers
    assert funcImp([-1, 2, -3, 4, -5]) == -0.6, ""Test case 3 failed""
    
    # Test case 4: List with a single number
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0.0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[10],10,10,PASS,TRUE,
7,4,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.

    Parameters:
    numbers (list): A list of numbers (int or float).

    Returns:
    float: The average of the numbers in the list.
    """"""
    if not numbers:  # Check if the list is empty
        return 0.0

    total_sum = 0  # Initialize sum to 0
    count = 0  # Initialize count to 0

    # Iterate over the list to calculate the sum
    for number in numbers:
        total_sum += number
        count += 1

    # Calculate the average
    average = total_sum / count

    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: List with a mix of positive and negative numbers
    assert funcImp([-1, 2, -3, 4, -5]) == -0.6, ""Test case 3 failed""
    
    # Test case 4: List with a single number
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0.0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],0,0,PASS,TRUE,
7,5,easy,Calculating the average of a list of numbers,Write a program to calculate the average of a list of numbers using a for loop.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to calculate the average of a list of numbers using a for loop.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using a for loop.

    Parameters:
    numbers (list): A list of numbers (int or float).

    Returns:
    float: The average of the numbers in the list.
    """"""
    if not numbers:  # Check if the list is empty
        return 0.0

    total_sum = 0  # Initialize sum to 0
    count = 0  # Initialize count to 0

    # Iterate over the list to calculate the sum
    for number in numbers:
        total_sum += number
        count += 1

    # Calculate the average
    average = total_sum / count

    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: List with a mix of positive and negative numbers
    assert funcImp([-1, 2, -3, 4, -5]) == -0.6, ""Test case 3 failed""
    
    # Test case 4: List with a single number
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0.0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1.5, 2.5, 3.5]",2.5,2.5,PASS,TRUE,
8,0,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using recursion.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Base case: if the list is empty, return 0
    if not numbers:
        return 0
    
    # Recursive function to calculate the sum of the list
    def recursive_sum(nums, n):
        # Base case for recursion: if the list is empty, return 0
        if n == 0:
            return 0
        # Recursive case: sum the last element and the sum of the rest
        return nums[n-1] + recursive_sum(nums, n-1)
    
    # Calculate the sum of the list using the recursive function
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate the average
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with one element
    assert funcImp([10]) == 10.0, ""Test case 2 failed""
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 3 failed""
    
    # Test case 4: List with mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,
8,1,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using recursion.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Base case: if the list is empty, return 0
    if not numbers:
        return 0
    
    # Recursive function to calculate the sum of the list
    def recursive_sum(nums, n):
        # Base case for recursion: if the list is empty, return 0
        if n == 0:
            return 0
        # Recursive case: sum the last element and the sum of the rest
        return nums[n-1] + recursive_sum(nums, n-1)
    
    # Calculate the sum of the list using the recursive function
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate the average
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with one element
    assert funcImp([10]) == 10.0, ""Test case 2 failed""
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 3 failed""
    
    # Test case 4: List with mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[10],10,10,PASS,TRUE,
8,2,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using recursion.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Base case: if the list is empty, return 0
    if not numbers:
        return 0
    
    # Recursive function to calculate the sum of the list
    def recursive_sum(nums, n):
        # Base case for recursion: if the list is empty, return 0
        if n == 0:
            return 0
        # Recursive case: sum the last element and the sum of the rest
        return nums[n-1] + recursive_sum(nums, n-1)
    
    # Calculate the sum of the list using the recursive function
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate the average
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with one element
    assert funcImp([10]) == 10.0, ""Test case 2 failed""
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 3 failed""
    
    # Test case 4: List with mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, -2, -3, -4, -5]",-3,-3,PASS,TRUE,
8,3,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using recursion.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Base case: if the list is empty, return 0
    if not numbers:
        return 0
    
    # Recursive function to calculate the sum of the list
    def recursive_sum(nums, n):
        # Base case for recursion: if the list is empty, return 0
        if n == 0:
            return 0
        # Recursive case: sum the last element and the sum of the rest
        return nums[n-1] + recursive_sum(nums, n-1)
    
    # Calculate the sum of the list using the recursive function
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate the average
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with one element
    assert funcImp([10]) == 10.0, ""Test case 2 failed""
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 3 failed""
    
    # Test case 4: List with mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, 1, -2, 2, -3, 3]",0,0,PASS,TRUE,
8,4,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using recursion.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Base case: if the list is empty, return 0
    if not numbers:
        return 0
    
    # Recursive function to calculate the sum of the list
    def recursive_sum(nums, n):
        # Base case for recursion: if the list is empty, return 0
        if n == 0:
            return 0
        # Recursive case: sum the last element and the sum of the rest
        return nums[n-1] + recursive_sum(nums, n-1)
    
    # Calculate the sum of the list using the recursive function
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate the average
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with one element
    assert funcImp([10]) == 10.0, ""Test case 2 failed""
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 3 failed""
    
    # Test case 4: List with mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],0,0,PASS,TRUE,
8,5,easy,Calculating the average of a list of numbers,Implement a function that takes in a list of numbers and returns the average using recursion.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that takes in a list of numbers and returns the average using recursion.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers using recursion.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Base case: if the list is empty, return 0
    if not numbers:
        return 0
    
    # Recursive function to calculate the sum of the list
    def recursive_sum(nums, n):
        # Base case for recursion: if the list is empty, return 0
        if n == 0:
            return 0
        # Recursive case: sum the last element and the sum of the rest
        return nums[n-1] + recursive_sum(nums, n-1)
    
    # Calculate the sum of the list using the recursive function
    total_sum = recursive_sum(numbers, len(numbers))
    
    # Calculate the average
    average = total_sum / len(numbers)
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with one element
    assert funcImp([10]) == 10.0, ""Test case 2 failed""
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 3 failed""
    
    # Test case 4: List with mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: List with floating point numbers
    assert funcImp([1.5, 2.5, 3.5]) == 2.5, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1.5, 2.5, 3.5]",2.5,2.5,PASS,TRUE,
9,0,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions or libraries.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Initialize sum and count variables
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        # Add the number to the total sum
        total_sum += number
        # Increment the count of numbers
        count += 1
    
    # Calculate the average by dividing the total sum by the count
    # Handle the case where the list might be empty to avoid division by zero
    if count == 0:
        return 0  # or raise an exception if preferred
    else:
        average = total_sum / count
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: Case with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 3 failed""
    
    # Test case 4: Single element list
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp([1000000, 2000000, 3000000]) == 2000000.0, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,
9,1,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions or libraries.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Initialize sum and count variables
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        # Add the number to the total sum
        total_sum += number
        # Increment the count of numbers
        count += 1
    
    # Calculate the average by dividing the total sum by the count
    # Handle the case where the list might be empty to avoid division by zero
    if count == 0:
        return 0  # or raise an exception if preferred
    else:
        average = total_sum / count
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: Case with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 3 failed""
    
    # Test case 4: Single element list
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp([1000000, 2000000, 3000000]) == 2000000.0, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, -2, -3, -4, -5]",-3,-3,PASS,TRUE,
9,2,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions or libraries.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Initialize sum and count variables
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        # Add the number to the total sum
        total_sum += number
        # Increment the count of numbers
        count += 1
    
    # Calculate the average by dividing the total sum by the count
    # Handle the case where the list might be empty to avoid division by zero
    if count == 0:
        return 0  # or raise an exception if preferred
    else:
        average = total_sum / count
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: Case with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 3 failed""
    
    # Test case 4: Single element list
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp([1000000, 2000000, 3000000]) == 2000000.0, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, 1, -2, 2, -3, 3]",0,0,PASS,TRUE,
9,3,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions or libraries.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Initialize sum and count variables
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        # Add the number to the total sum
        total_sum += number
        # Increment the count of numbers
        count += 1
    
    # Calculate the average by dividing the total sum by the count
    # Handle the case where the list might be empty to avoid division by zero
    if count == 0:
        return 0  # or raise an exception if preferred
    else:
        average = total_sum / count
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: Case with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 3 failed""
    
    # Test case 4: Single element list
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp([1000000, 2000000, 3000000]) == 2000000.0, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[10],10,10,PASS,TRUE,
9,4,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions or libraries.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Initialize sum and count variables
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        # Add the number to the total sum
        total_sum += number
        # Increment the count of numbers
        count += 1
    
    # Calculate the average by dividing the total sum by the count
    # Handle the case where the list might be empty to avoid division by zero
    if count == 0:
        return 0  # or raise an exception if preferred
    else:
        average = total_sum / count
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: Case with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 3 failed""
    
    # Test case 4: Single element list
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp([1000000, 2000000, 3000000]) == 2000000.0, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],0,0,PASS,TRUE,
9,5,easy,Calculating the average of a list of numbers,Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that calculates the average of a list of numbers without using any built-in functions or libraries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    Calculate the average of a list of numbers without using any built-in functions or libraries.
    
    :param numbers: List of numbers
    :return: Average of the numbers
    """"""
    # Initialize sum and count variables
    total_sum = 0
    count = 0
    
    # Iterate over each number in the list
    for number in numbers:
        # Add the number to the total sum
        total_sum += number
        # Increment the count of numbers
        count += 1
    
    # Calculate the average by dividing the total sum by the count
    # Handle the case where the list might be empty to avoid division by zero
    if count == 0:
        return 0  # or raise an exception if preferred
    else:
        average = total_sum / count
    
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: Case with negative numbers
    assert funcImp([-1, -2, -3, -4, -5]) == -3.0, ""Test case 2 failed""
    
    # Test case 3: Mixed positive and negative numbers
    assert funcImp([-1, 1, -2, 2, -3, 3]) == 0.0, ""Test case 3 failed""
    
    # Test case 4: Single element list
    assert funcImp([10]) == 10.0, ""Test case 4 failed""
    
    # Test case 5: Empty list
    assert funcImp([]) == 0, ""Test case 5 failed""
    
    # Test case 6: Large numbers
    assert funcImp([1000000, 2000000, 3000000]) == 2000000.0, ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1000000, 2000000, 3000000]",2000000,2000000,PASS,TRUE,
10,0,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers.
    It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    numbers (list): A list of elements that are expected to be numbers.
    
    Returns:
    float: The average of the valid numbers in the list.
    None: If the list is empty or contains no valid numbers.
    """"""
    if not numbers:
        # Return None if the list is empty
        return None
    
    # Filter out invalid entries (non-numeric)
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    if not valid_numbers:
        # Return None if there are no valid numbers
        return None
    
    # Calculate the average of valid numbers
    average = sum(valid_numbers) / len(valid_numbers)
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with valid numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with invalid entries
    assert funcImp([1, 'a', 3, None, 5]) == 3.0, ""Test case 2 failed""
    
    # Test case 3: List with all invalid entries
    assert funcImp(['a', 'b', None, 'c']) is None, ""Test case 3 failed""
    
    # Test case 4: Empty list
    assert funcImp([]) is None, ""Test case 4 failed""
    
    # Test case 5: List with a single valid number
    assert funcImp([10]) == 10.0, ""Test case 5 failed""
    
    # Test case 6: List with mixed valid and invalid numbers
    assert funcImp([1.5, 2.5, 'x', 3.5]) == 2.5, ""Test case 6 failed""
    
    # Test case 7: List with negative numbers
    assert funcImp([-1, -2, -3, -4]) == -2.5, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]",3,3,PASS,TRUE,
10,1,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers.
    It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    numbers (list): A list of elements that are expected to be numbers.
    
    Returns:
    float: The average of the valid numbers in the list.
    None: If the list is empty or contains no valid numbers.
    """"""
    if not numbers:
        # Return None if the list is empty
        return None
    
    # Filter out invalid entries (non-numeric)
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    if not valid_numbers:
        # Return None if there are no valid numbers
        return None
    
    # Calculate the average of valid numbers
    average = sum(valid_numbers) / len(valid_numbers)
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with valid numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with invalid entries
    assert funcImp([1, 'a', 3, None, 5]) == 3.0, ""Test case 2 failed""
    
    # Test case 3: List with all invalid entries
    assert funcImp(['a', 'b', None, 'c']) is None, ""Test case 3 failed""
    
    # Test case 4: Empty list
    assert funcImp([]) is None, ""Test case 4 failed""
    
    # Test case 5: List with a single valid number
    assert funcImp([10]) == 10.0, ""Test case 5 failed""
    
    # Test case 6: List with mixed valid and invalid numbers
    assert funcImp([1.5, 2.5, 'x', 3.5]) == 2.5, ""Test case 6 failed""
    
    # Test case 7: List with negative numbers
    assert funcImp([-1, -2, -3, -4]) == -2.5, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 'a', 3, None, 5]",3,3,PASS,TRUE,
10,2,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers.
    It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    numbers (list): A list of elements that are expected to be numbers.
    
    Returns:
    float: The average of the valid numbers in the list.
    None: If the list is empty or contains no valid numbers.
    """"""
    if not numbers:
        # Return None if the list is empty
        return None
    
    # Filter out invalid entries (non-numeric)
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    if not valid_numbers:
        # Return None if there are no valid numbers
        return None
    
    # Calculate the average of valid numbers
    average = sum(valid_numbers) / len(valid_numbers)
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with valid numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with invalid entries
    assert funcImp([1, 'a', 3, None, 5]) == 3.0, ""Test case 2 failed""
    
    # Test case 3: List with all invalid entries
    assert funcImp(['a', 'b', None, 'c']) is None, ""Test case 3 failed""
    
    # Test case 4: Empty list
    assert funcImp([]) is None, ""Test case 4 failed""
    
    # Test case 5: List with a single valid number
    assert funcImp([10]) == 10.0, ""Test case 5 failed""
    
    # Test case 6: List with mixed valid and invalid numbers
    assert funcImp([1.5, 2.5, 'x', 3.5]) == 2.5, ""Test case 6 failed""
    
    # Test case 7: List with negative numbers
    assert funcImp([-1, -2, -3, -4]) == -2.5, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","['a', 'b', None, 'c']",,,PASS,TRUE,
10,3,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers.
    It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    numbers (list): A list of elements that are expected to be numbers.
    
    Returns:
    float: The average of the valid numbers in the list.
    None: If the list is empty or contains no valid numbers.
    """"""
    if not numbers:
        # Return None if the list is empty
        return None
    
    # Filter out invalid entries (non-numeric)
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    if not valid_numbers:
        # Return None if there are no valid numbers
        return None
    
    # Calculate the average of valid numbers
    average = sum(valid_numbers) / len(valid_numbers)
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with valid numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with invalid entries
    assert funcImp([1, 'a', 3, None, 5]) == 3.0, ""Test case 2 failed""
    
    # Test case 3: List with all invalid entries
    assert funcImp(['a', 'b', None, 'c']) is None, ""Test case 3 failed""
    
    # Test case 4: Empty list
    assert funcImp([]) is None, ""Test case 4 failed""
    
    # Test case 5: List with a single valid number
    assert funcImp([10]) == 10.0, ""Test case 5 failed""
    
    # Test case 6: List with mixed valid and invalid numbers
    assert funcImp([1.5, 2.5, 'x', 3.5]) == 2.5, ""Test case 6 failed""
    
    # Test case 7: List with negative numbers
    assert funcImp([-1, -2, -3, -4]) == -2.5, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],,,PASS,TRUE,
10,4,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers.
    It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    numbers (list): A list of elements that are expected to be numbers.
    
    Returns:
    float: The average of the valid numbers in the list.
    None: If the list is empty or contains no valid numbers.
    """"""
    if not numbers:
        # Return None if the list is empty
        return None
    
    # Filter out invalid entries (non-numeric)
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    if not valid_numbers:
        # Return None if there are no valid numbers
        return None
    
    # Calculate the average of valid numbers
    average = sum(valid_numbers) / len(valid_numbers)
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with valid numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with invalid entries
    assert funcImp([1, 'a', 3, None, 5]) == 3.0, ""Test case 2 failed""
    
    # Test case 3: List with all invalid entries
    assert funcImp(['a', 'b', None, 'c']) is None, ""Test case 3 failed""
    
    # Test case 4: Empty list
    assert funcImp([]) is None, ""Test case 4 failed""
    
    # Test case 5: List with a single valid number
    assert funcImp([10]) == 10.0, ""Test case 5 failed""
    
    # Test case 6: List with mixed valid and invalid numbers
    assert funcImp([1.5, 2.5, 'x', 3.5]) == 2.5, ""Test case 6 failed""
    
    # Test case 7: List with negative numbers
    assert funcImp([-1, -2, -3, -4]) == -2.5, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[10],10,10,PASS,TRUE,
10,5,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers.
    It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    numbers (list): A list of elements that are expected to be numbers.
    
    Returns:
    float: The average of the valid numbers in the list.
    None: If the list is empty or contains no valid numbers.
    """"""
    if not numbers:
        # Return None if the list is empty
        return None
    
    # Filter out invalid entries (non-numeric)
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    if not valid_numbers:
        # Return None if there are no valid numbers
        return None
    
    # Calculate the average of valid numbers
    average = sum(valid_numbers) / len(valid_numbers)
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with valid numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with invalid entries
    assert funcImp([1, 'a', 3, None, 5]) == 3.0, ""Test case 2 failed""
    
    # Test case 3: List with all invalid entries
    assert funcImp(['a', 'b', None, 'c']) is None, ""Test case 3 failed""
    
    # Test case 4: Empty list
    assert funcImp([]) is None, ""Test case 4 failed""
    
    # Test case 5: List with a single valid number
    assert funcImp([10]) == 10.0, ""Test case 5 failed""
    
    # Test case 6: List with mixed valid and invalid numbers
    assert funcImp([1.5, 2.5, 'x', 3.5]) == 2.5, ""Test case 6 failed""
    
    # Test case 7: List with negative numbers
    assert funcImp([-1, -2, -3, -4]) == -2.5, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1.5, 2.5, 'x', 3.5]",2.5,2.5,PASS,TRUE,
10,6,easy,Calculating the average of a list of numbers,"Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to find the average of a list of numbers, handling cases where the list is empty or contains invalid entries.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function calculates the average of a list of numbers.
    It handles cases where the list is empty or contains invalid entries.
    
    Parameters:
    numbers (list): A list of elements that are expected to be numbers.
    
    Returns:
    float: The average of the valid numbers in the list.
    None: If the list is empty or contains no valid numbers.
    """"""
    if not numbers:
        # Return None if the list is empty
        return None
    
    # Filter out invalid entries (non-numeric)
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]
    
    if not valid_numbers:
        # Return None if there are no valid numbers
        return None
    
    # Calculate the average of valid numbers
    average = sum(valid_numbers) / len(valid_numbers)
    return average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with valid numbers
    assert funcImp([1, 2, 3, 4, 5]) == 3.0, ""Test case 1 failed""
    
    # Test case 2: List with invalid entries
    assert funcImp([1, 'a', 3, None, 5]) == 3.0, ""Test case 2 failed""
    
    # Test case 3: List with all invalid entries
    assert funcImp(['a', 'b', None, 'c']) is None, ""Test case 3 failed""
    
    # Test case 4: Empty list
    assert funcImp([]) is None, ""Test case 4 failed""
    
    # Test case 5: List with a single valid number
    assert funcImp([10]) == 10.0, ""Test case 5 failed""
    
    # Test case 6: List with mixed valid and invalid numbers
    assert funcImp([1.5, 2.5, 'x', 3.5]) == 2.5, ""Test case 6 failed""
    
    # Test case 7: List with negative numbers
    assert funcImp([-1, -2, -3, -4]) == -2.5, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, -2, -3, -4]",-2.5,-2.5,PASS,TRUE,
11,0,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.

    :param numbers: List of numbers for which the weighted average is to be calculated.
    :param weights: List of weights corresponding to each number.
    :return: The weighted average of the numbers.
    """"""
    if len(numbers) != len(weights):
        raise ValueError(""The length of numbers and weights must be the same."")
    
    if not numbers or not weights:
        raise ValueError(""The numbers and weights lists must not be empty."")
    
    total_weight = sum(weights)
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    weighted_sum = sum(n * w for n, w in zip(numbers, weights))
    weighted_average = weighted_sum / total_weight
    
    return weighted_average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [10, 20, 30]
    weights = [1, 2, 3]
    expected = (10*1 + 20*2 + 30*3) / (1 + 2 + 3)
    assert funcImp(numbers, weights) == expected, ""Test case 1 failed""

    # Test case 2: All weights are equal
    numbers = [10, 20, 30]
    weights = [1, 1, 1]
    expected = sum(numbers) / len(numbers)
    assert funcImp(numbers, weights) == expected, ""Test case 2 failed""

    # Test case 3: Single element
    numbers = [50]
    weights = [5]
    expected = 50
    assert funcImp(numbers, weights) == expected, ""Test case 3 failed""

    # Test case 4: Zero weights
    try:
        numbers = [10, 20, 30]
        weights = [0, 0, 0]
        funcImp(numbers, weights)
        assert False, ""Test case 4 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 5: Empty lists
    try:
        numbers = []
        weights = []
        funcImp(numbers, weights)
        assert False, ""Test case 5 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 6: Different lengths
    try:
        numbers = [10, 20]
        weights = [1]
        funcImp(numbers, weights)
        assert False, ""Test case 6 failed - should have raised ValueError""
    except ValueError:
        pass

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([10, 20, 30], [1, 2, 3])",23.33333333,23.33333333,PASS,TRUE,
11,1,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.

    :param numbers: List of numbers for which the weighted average is to be calculated.
    :param weights: List of weights corresponding to each number.
    :return: The weighted average of the numbers.
    """"""
    if len(numbers) != len(weights):
        raise ValueError(""The length of numbers and weights must be the same."")
    
    if not numbers or not weights:
        raise ValueError(""The numbers and weights lists must not be empty."")
    
    total_weight = sum(weights)
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    weighted_sum = sum(n * w for n, w in zip(numbers, weights))
    weighted_average = weighted_sum / total_weight
    
    return weighted_average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [10, 20, 30]
    weights = [1, 2, 3]
    expected = (10*1 + 20*2 + 30*3) / (1 + 2 + 3)
    assert funcImp(numbers, weights) == expected, ""Test case 1 failed""

    # Test case 2: All weights are equal
    numbers = [10, 20, 30]
    weights = [1, 1, 1]
    expected = sum(numbers) / len(numbers)
    assert funcImp(numbers, weights) == expected, ""Test case 2 failed""

    # Test case 3: Single element
    numbers = [50]
    weights = [5]
    expected = 50
    assert funcImp(numbers, weights) == expected, ""Test case 3 failed""

    # Test case 4: Zero weights
    try:
        numbers = [10, 20, 30]
        weights = [0, 0, 0]
        funcImp(numbers, weights)
        assert False, ""Test case 4 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 5: Empty lists
    try:
        numbers = []
        weights = []
        funcImp(numbers, weights)
        assert False, ""Test case 5 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 6: Different lengths
    try:
        numbers = [10, 20]
        weights = [1]
        funcImp(numbers, weights)
        assert False, ""Test case 6 failed - should have raised ValueError""
    except ValueError:
        pass

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([10, 20, 30], [1, 1, 1])",20,20,PASS,TRUE,
11,2,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.

    :param numbers: List of numbers for which the weighted average is to be calculated.
    :param weights: List of weights corresponding to each number.
    :return: The weighted average of the numbers.
    """"""
    if len(numbers) != len(weights):
        raise ValueError(""The length of numbers and weights must be the same."")
    
    if not numbers or not weights:
        raise ValueError(""The numbers and weights lists must not be empty."")
    
    total_weight = sum(weights)
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    weighted_sum = sum(n * w for n, w in zip(numbers, weights))
    weighted_average = weighted_sum / total_weight
    
    return weighted_average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [10, 20, 30]
    weights = [1, 2, 3]
    expected = (10*1 + 20*2 + 30*3) / (1 + 2 + 3)
    assert funcImp(numbers, weights) == expected, ""Test case 1 failed""

    # Test case 2: All weights are equal
    numbers = [10, 20, 30]
    weights = [1, 1, 1]
    expected = sum(numbers) / len(numbers)
    assert funcImp(numbers, weights) == expected, ""Test case 2 failed""

    # Test case 3: Single element
    numbers = [50]
    weights = [5]
    expected = 50
    assert funcImp(numbers, weights) == expected, ""Test case 3 failed""

    # Test case 4: Zero weights
    try:
        numbers = [10, 20, 30]
        weights = [0, 0, 0]
        funcImp(numbers, weights)
        assert False, ""Test case 4 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 5: Empty lists
    try:
        numbers = []
        weights = []
        funcImp(numbers, weights)
        assert False, ""Test case 5 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 6: Different lengths
    try:
        numbers = [10, 20]
        weights = [1]
        funcImp(numbers, weights)
        assert False, ""Test case 6 failed - should have raised ValueError""
    except ValueError:
        pass

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([50], [5])",50,50,PASS,TRUE,
11,3,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.

    :param numbers: List of numbers for which the weighted average is to be calculated.
    :param weights: List of weights corresponding to each number.
    :return: The weighted average of the numbers.
    """"""
    if len(numbers) != len(weights):
        raise ValueError(""The length of numbers and weights must be the same."")
    
    if not numbers or not weights:
        raise ValueError(""The numbers and weights lists must not be empty."")
    
    total_weight = sum(weights)
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    weighted_sum = sum(n * w for n, w in zip(numbers, weights))
    weighted_average = weighted_sum / total_weight
    
    return weighted_average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [10, 20, 30]
    weights = [1, 2, 3]
    expected = (10*1 + 20*2 + 30*3) / (1 + 2 + 3)
    assert funcImp(numbers, weights) == expected, ""Test case 1 failed""

    # Test case 2: All weights are equal
    numbers = [10, 20, 30]
    weights = [1, 1, 1]
    expected = sum(numbers) / len(numbers)
    assert funcImp(numbers, weights) == expected, ""Test case 2 failed""

    # Test case 3: Single element
    numbers = [50]
    weights = [5]
    expected = 50
    assert funcImp(numbers, weights) == expected, ""Test case 3 failed""

    # Test case 4: Zero weights
    try:
        numbers = [10, 20, 30]
        weights = [0, 0, 0]
        funcImp(numbers, weights)
        assert False, ""Test case 4 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 5: Empty lists
    try:
        numbers = []
        weights = []
        funcImp(numbers, weights)
        assert False, ""Test case 5 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 6: Different lengths
    try:
        numbers = [10, 20]
        weights = [1]
        funcImp(numbers, weights)
        assert False, ""Test case 6 failed - should have raised ValueError""
    except ValueError:
        pass

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([10, 20, 30], [0, 0, 0])",,,FAIL,FALSE,The sum of weights must not be zero.
11,4,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.

    :param numbers: List of numbers for which the weighted average is to be calculated.
    :param weights: List of weights corresponding to each number.
    :return: The weighted average of the numbers.
    """"""
    if len(numbers) != len(weights):
        raise ValueError(""The length of numbers and weights must be the same."")
    
    if not numbers or not weights:
        raise ValueError(""The numbers and weights lists must not be empty."")
    
    total_weight = sum(weights)
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    weighted_sum = sum(n * w for n, w in zip(numbers, weights))
    weighted_average = weighted_sum / total_weight
    
    return weighted_average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [10, 20, 30]
    weights = [1, 2, 3]
    expected = (10*1 + 20*2 + 30*3) / (1 + 2 + 3)
    assert funcImp(numbers, weights) == expected, ""Test case 1 failed""

    # Test case 2: All weights are equal
    numbers = [10, 20, 30]
    weights = [1, 1, 1]
    expected = sum(numbers) / len(numbers)
    assert funcImp(numbers, weights) == expected, ""Test case 2 failed""

    # Test case 3: Single element
    numbers = [50]
    weights = [5]
    expected = 50
    assert funcImp(numbers, weights) == expected, ""Test case 3 failed""

    # Test case 4: Zero weights
    try:
        numbers = [10, 20, 30]
        weights = [0, 0, 0]
        funcImp(numbers, weights)
        assert False, ""Test case 4 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 5: Empty lists
    try:
        numbers = []
        weights = []
        funcImp(numbers, weights)
        assert False, ""Test case 5 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 6: Different lengths
    try:
        numbers = [10, 20]
        weights = [1]
        funcImp(numbers, weights)
        assert False, ""Test case 6 failed - should have raised ValueError""
    except ValueError:
        pass

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([], [])",,,FAIL,FALSE,The numbers and weights lists must not be empty.
11,5,easy,Calculating the average of a list of numbers,"Develop a program that calculates the weighted average of a list of numbers, given their respective weights.","## Problem Statement
- Develop a Python script to solve the problem: 'Develop a program that calculates the weighted average of a list of numbers, given their respective weights.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, weights):
    """"""
    Calculate the weighted average of a list of numbers given their respective weights.

    :param numbers: List of numbers for which the weighted average is to be calculated.
    :param weights: List of weights corresponding to each number.
    :return: The weighted average of the numbers.
    """"""
    if len(numbers) != len(weights):
        raise ValueError(""The length of numbers and weights must be the same."")
    
    if not numbers or not weights:
        raise ValueError(""The numbers and weights lists must not be empty."")
    
    total_weight = sum(weights)
    if total_weight == 0:
        raise ValueError(""The sum of weights must not be zero."")
    
    weighted_sum = sum(n * w for n, w in zip(numbers, weights))
    weighted_average = weighted_sum / total_weight
    
    return weighted_average

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [10, 20, 30]
    weights = [1, 2, 3]
    expected = (10*1 + 20*2 + 30*3) / (1 + 2 + 3)
    assert funcImp(numbers, weights) == expected, ""Test case 1 failed""

    # Test case 2: All weights are equal
    numbers = [10, 20, 30]
    weights = [1, 1, 1]
    expected = sum(numbers) / len(numbers)
    assert funcImp(numbers, weights) == expected, ""Test case 2 failed""

    # Test case 3: Single element
    numbers = [50]
    weights = [5]
    expected = 50
    assert funcImp(numbers, weights) == expected, ""Test case 3 failed""

    # Test case 4: Zero weights
    try:
        numbers = [10, 20, 30]
        weights = [0, 0, 0]
        funcImp(numbers, weights)
        assert False, ""Test case 4 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 5: Empty lists
    try:
        numbers = []
        weights = []
        funcImp(numbers, weights)
        assert False, ""Test case 5 failed - should have raised ValueError""
    except ValueError:
        pass

    # Test case 6: Different lengths
    try:
        numbers = [10, 20]
        weights = [1]
        funcImp(numbers, weights)
        assert False, ""Test case 6 failed - should have raised ValueError""
    except ValueError:
        pass

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([10, 20], [1])",,,FAIL,FALSE,The length of numbers and weights must be the same.
12,0,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median of a list of numbers and calculates the average
    of all values greater than or equal to the median.
    
    :param numbers: List of numbers
    :return: Average of numbers greater than or equal to the median
    """"""
    if not numbers:
        return None  # Return None if the list is empty
    
    # Sort the list to find the median
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    # Find the median
    if n % 2 == 1:
        median = sorted_numbers[n // 2]
    else:
        median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2
    
    # Filter numbers greater than or equal to the median
    greater_or_equal = [num for num in numbers if num >= median]
    
    # Calculate the average of these numbers
    if greater_or_equal:
        average = sum(greater_or_equal) / len(greater_or_equal)
    else:
        average = None  # In case there are no numbers greater than or equal to the median
    
    return average

# Test cases to verify the solution
test_cases = [
    ([1, 3, 3, 6, 7, 8, 9], 7.5),  # Median is 6, average of [6, 7, 8, 9] is 7.5
    ([1, 2, 3, 4, 5], 4.0),        # Median is 3, average of [3, 4, 5] is 4.0
    ([1, 2, 3, 4], 3.5),           # Median is 2.5, average of [3, 4] is 3.5
    ([5, 5, 5, 5], 5.0),           # Median is 5, average of [5, 5, 5, 5] is 5.0
    ([10], 10.0),                  # Median is 10, average of [10] is 10.0
    ([], None),                    # Empty list, return None
]

# Execute test cases
for i, (numbers, expected) in enumerate(test_cases):
    result = funcImp(numbers)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} == {expected}"")
```","[1, 3, 3, 6, 7, 8, 9]",7.5,7.5,PASS,TRUE,
12,1,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median of a list of numbers and calculates the average
    of all values greater than or equal to the median.
    
    :param numbers: List of numbers
    :return: Average of numbers greater than or equal to the median
    """"""
    if not numbers:
        return None  # Return None if the list is empty
    
    # Sort the list to find the median
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    # Find the median
    if n % 2 == 1:
        median = sorted_numbers[n // 2]
    else:
        median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2
    
    # Filter numbers greater than or equal to the median
    greater_or_equal = [num for num in numbers if num >= median]
    
    # Calculate the average of these numbers
    if greater_or_equal:
        average = sum(greater_or_equal) / len(greater_or_equal)
    else:
        average = None  # In case there are no numbers greater than or equal to the median
    
    return average

# Test cases to verify the solution
test_cases = [
    ([1, 3, 3, 6, 7, 8, 9], 7.5),  # Median is 6, average of [6, 7, 8, 9] is 7.5
    ([1, 2, 3, 4, 5], 4.0),        # Median is 3, average of [3, 4, 5] is 4.0
    ([1, 2, 3, 4], 3.5),           # Median is 2.5, average of [3, 4] is 3.5
    ([5, 5, 5, 5], 5.0),           # Median is 5, average of [5, 5, 5, 5] is 5.0
    ([10], 10.0),                  # Median is 10, average of [10] is 10.0
    ([], None),                    # Empty list, return None
]

# Execute test cases
for i, (numbers, expected) in enumerate(test_cases):
    result = funcImp(numbers)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} == {expected}"")
```","[1, 2, 3, 4, 5]",4,4,PASS,TRUE,
12,2,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median of a list of numbers and calculates the average
    of all values greater than or equal to the median.
    
    :param numbers: List of numbers
    :return: Average of numbers greater than or equal to the median
    """"""
    if not numbers:
        return None  # Return None if the list is empty
    
    # Sort the list to find the median
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    # Find the median
    if n % 2 == 1:
        median = sorted_numbers[n // 2]
    else:
        median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2
    
    # Filter numbers greater than or equal to the median
    greater_or_equal = [num for num in numbers if num >= median]
    
    # Calculate the average of these numbers
    if greater_or_equal:
        average = sum(greater_or_equal) / len(greater_or_equal)
    else:
        average = None  # In case there are no numbers greater than or equal to the median
    
    return average

# Test cases to verify the solution
test_cases = [
    ([1, 3, 3, 6, 7, 8, 9], 7.5),  # Median is 6, average of [6, 7, 8, 9] is 7.5
    ([1, 2, 3, 4, 5], 4.0),        # Median is 3, average of [3, 4, 5] is 4.0
    ([1, 2, 3, 4], 3.5),           # Median is 2.5, average of [3, 4] is 3.5
    ([5, 5, 5, 5], 5.0),           # Median is 5, average of [5, 5, 5, 5] is 5.0
    ([10], 10.0),                  # Median is 10, average of [10] is 10.0
    ([], None),                    # Empty list, return None
]

# Execute test cases
for i, (numbers, expected) in enumerate(test_cases):
    result = funcImp(numbers)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} == {expected}"")
```","[1, 2, 3, 4]",3.5,3.5,PASS,TRUE,
12,3,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median of a list of numbers and calculates the average
    of all values greater than or equal to the median.
    
    :param numbers: List of numbers
    :return: Average of numbers greater than or equal to the median
    """"""
    if not numbers:
        return None  # Return None if the list is empty
    
    # Sort the list to find the median
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    # Find the median
    if n % 2 == 1:
        median = sorted_numbers[n // 2]
    else:
        median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2
    
    # Filter numbers greater than or equal to the median
    greater_or_equal = [num for num in numbers if num >= median]
    
    # Calculate the average of these numbers
    if greater_or_equal:
        average = sum(greater_or_equal) / len(greater_or_equal)
    else:
        average = None  # In case there are no numbers greater than or equal to the median
    
    return average

# Test cases to verify the solution
test_cases = [
    ([1, 3, 3, 6, 7, 8, 9], 7.5),  # Median is 6, average of [6, 7, 8, 9] is 7.5
    ([1, 2, 3, 4, 5], 4.0),        # Median is 3, average of [3, 4, 5] is 4.0
    ([1, 2, 3, 4], 3.5),           # Median is 2.5, average of [3, 4] is 3.5
    ([5, 5, 5, 5], 5.0),           # Median is 5, average of [5, 5, 5, 5] is 5.0
    ([10], 10.0),                  # Median is 10, average of [10] is 10.0
    ([], None),                    # Empty list, return None
]

# Execute test cases
for i, (numbers, expected) in enumerate(test_cases):
    result = funcImp(numbers)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} == {expected}"")
```","[5, 5, 5, 5]",5,5,PASS,TRUE,
12,4,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median of a list of numbers and calculates the average
    of all values greater than or equal to the median.
    
    :param numbers: List of numbers
    :return: Average of numbers greater than or equal to the median
    """"""
    if not numbers:
        return None  # Return None if the list is empty
    
    # Sort the list to find the median
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    # Find the median
    if n % 2 == 1:
        median = sorted_numbers[n // 2]
    else:
        median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2
    
    # Filter numbers greater than or equal to the median
    greater_or_equal = [num for num in numbers if num >= median]
    
    # Calculate the average of these numbers
    if greater_or_equal:
        average = sum(greater_or_equal) / len(greater_or_equal)
    else:
        average = None  # In case there are no numbers greater than or equal to the median
    
    return average

# Test cases to verify the solution
test_cases = [
    ([1, 3, 3, 6, 7, 8, 9], 7.5),  # Median is 6, average of [6, 7, 8, 9] is 7.5
    ([1, 2, 3, 4, 5], 4.0),        # Median is 3, average of [3, 4, 5] is 4.0
    ([1, 2, 3, 4], 3.5),           # Median is 2.5, average of [3, 4] is 3.5
    ([5, 5, 5, 5], 5.0),           # Median is 5, average of [5, 5, 5, 5] is 5.0
    ([10], 10.0),                  # Median is 10, average of [10] is 10.0
    ([], None),                    # Empty list, return None
]

# Execute test cases
for i, (numbers, expected) in enumerate(test_cases):
    result = funcImp(numbers)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} == {expected}"")
```",[10],10,10,PASS,TRUE,
12,5,easy,Calculating the average of a list of numbers,Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a function that finds the median (middle value) of a list of numbers and then calculates the average of all values greater than or equal to the median.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers):
    """"""
    This function finds the median of a list of numbers and calculates the average
    of all values greater than or equal to the median.
    
    :param numbers: List of numbers
    :return: Average of numbers greater than or equal to the median
    """"""
    if not numbers:
        return None  # Return None if the list is empty
    
    # Sort the list to find the median
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    # Find the median
    if n % 2 == 1:
        median = sorted_numbers[n // 2]
    else:
        median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2
    
    # Filter numbers greater than or equal to the median
    greater_or_equal = [num for num in numbers if num >= median]
    
    # Calculate the average of these numbers
    if greater_or_equal:
        average = sum(greater_or_equal) / len(greater_or_equal)
    else:
        average = None  # In case there are no numbers greater than or equal to the median
    
    return average

# Test cases to verify the solution
test_cases = [
    ([1, 3, 3, 6, 7, 8, 9], 7.5),  # Median is 6, average of [6, 7, 8, 9] is 7.5
    ([1, 2, 3, 4, 5], 4.0),        # Median is 3, average of [3, 4, 5] is 4.0
    ([1, 2, 3, 4], 3.5),           # Median is 2.5, average of [3, 4] is 3.5
    ([5, 5, 5, 5], 5.0),           # Median is 5, average of [5, 5, 5, 5] is 5.0
    ([10], 10.0),                  # Median is 10, average of [10] is 10.0
    ([], None),                    # Empty list, return None
]

# Execute test cases
for i, (numbers, expected) in enumerate(test_cases):
    result = funcImp(numbers)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} == {expected}"")
```",[],,,PASS,TRUE,
13,0,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average of a list of numbers over a specified window size.

    :param numbers: List of numbers to calculate the moving average for.
    :param window_size: The size of the sliding window.
    :return: A list of moving averages.
    """"""
    if window_size <= 0:
        raise ValueError(""Window size must be positive"")
    if not numbers:
        return []

    moving_averages = []
    window_sum = 0
    for i in range(len(numbers)):
        window_sum += numbers[i]
        if i >= window_size:
            window_sum -= numbers[i - window_size]
        if i >= window_size - 1:
            moving_averages.append(window_sum / window_size)

    return moving_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [1, 2, 3, 4, 5]
    window_size = 3
    expected_output = [2.0, 3.0, 4.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 2: Window size of 1 (should return the same list)
    numbers = [1, 2, 3, 4, 5]
    window_size = 1
    expected_output = [1, 2, 3, 4, 5]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 3: Window size equal to the list size (should return one element)
    numbers = [1, 2, 3, 4, 5]
    window_size = 5
    expected_output = [3.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 4: Empty list
    numbers = []
    window_size = 3
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 5: Window size larger than the list size (should return empty list)
    numbers = [1, 2, 3]
    window_size = 4
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 6: Negative numbers
    numbers = [-1, -2, -3, -4, -5]
    window_size = 2
    expected_output = [-1.5, -2.5, -3.5, -4.5]
    assert funcImp(numbers, window_size) == expected_output

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 3)","[2.0, 3.0, 4.0]","[2.0, 3.0, 4.0]",PASS,TRUE,
13,1,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average of a list of numbers over a specified window size.

    :param numbers: List of numbers to calculate the moving average for.
    :param window_size: The size of the sliding window.
    :return: A list of moving averages.
    """"""
    if window_size <= 0:
        raise ValueError(""Window size must be positive"")
    if not numbers:
        return []

    moving_averages = []
    window_sum = 0
    for i in range(len(numbers)):
        window_sum += numbers[i]
        if i >= window_size:
            window_sum -= numbers[i - window_size]
        if i >= window_size - 1:
            moving_averages.append(window_sum / window_size)

    return moving_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [1, 2, 3, 4, 5]
    window_size = 3
    expected_output = [2.0, 3.0, 4.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 2: Window size of 1 (should return the same list)
    numbers = [1, 2, 3, 4, 5]
    window_size = 1
    expected_output = [1, 2, 3, 4, 5]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 3: Window size equal to the list size (should return one element)
    numbers = [1, 2, 3, 4, 5]
    window_size = 5
    expected_output = [3.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 4: Empty list
    numbers = []
    window_size = 3
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 5: Window size larger than the list size (should return empty list)
    numbers = [1, 2, 3]
    window_size = 4
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 6: Negative numbers
    numbers = [-1, -2, -3, -4, -5]
    window_size = 2
    expected_output = [-1.5, -2.5, -3.5, -4.5]
    assert funcImp(numbers, window_size) == expected_output

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 1)","[1, 2, 3, 4, 5]","[1.0, 2.0, 3.0, 4.0, 5.0]",PASS,TRUE,
13,2,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average of a list of numbers over a specified window size.

    :param numbers: List of numbers to calculate the moving average for.
    :param window_size: The size of the sliding window.
    :return: A list of moving averages.
    """"""
    if window_size <= 0:
        raise ValueError(""Window size must be positive"")
    if not numbers:
        return []

    moving_averages = []
    window_sum = 0
    for i in range(len(numbers)):
        window_sum += numbers[i]
        if i >= window_size:
            window_sum -= numbers[i - window_size]
        if i >= window_size - 1:
            moving_averages.append(window_sum / window_size)

    return moving_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [1, 2, 3, 4, 5]
    window_size = 3
    expected_output = [2.0, 3.0, 4.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 2: Window size of 1 (should return the same list)
    numbers = [1, 2, 3, 4, 5]
    window_size = 1
    expected_output = [1, 2, 3, 4, 5]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 3: Window size equal to the list size (should return one element)
    numbers = [1, 2, 3, 4, 5]
    window_size = 5
    expected_output = [3.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 4: Empty list
    numbers = []
    window_size = 3
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 5: Window size larger than the list size (should return empty list)
    numbers = [1, 2, 3]
    window_size = 4
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 6: Negative numbers
    numbers = [-1, -2, -3, -4, -5]
    window_size = 2
    expected_output = [-1.5, -2.5, -3.5, -4.5]
    assert funcImp(numbers, window_size) == expected_output

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 5)",[3.0],[3.0],PASS,TRUE,
13,3,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average of a list of numbers over a specified window size.

    :param numbers: List of numbers to calculate the moving average for.
    :param window_size: The size of the sliding window.
    :return: A list of moving averages.
    """"""
    if window_size <= 0:
        raise ValueError(""Window size must be positive"")
    if not numbers:
        return []

    moving_averages = []
    window_sum = 0
    for i in range(len(numbers)):
        window_sum += numbers[i]
        if i >= window_size:
            window_sum -= numbers[i - window_size]
        if i >= window_size - 1:
            moving_averages.append(window_sum / window_size)

    return moving_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [1, 2, 3, 4, 5]
    window_size = 3
    expected_output = [2.0, 3.0, 4.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 2: Window size of 1 (should return the same list)
    numbers = [1, 2, 3, 4, 5]
    window_size = 1
    expected_output = [1, 2, 3, 4, 5]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 3: Window size equal to the list size (should return one element)
    numbers = [1, 2, 3, 4, 5]
    window_size = 5
    expected_output = [3.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 4: Empty list
    numbers = []
    window_size = 3
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 5: Window size larger than the list size (should return empty list)
    numbers = [1, 2, 3]
    window_size = 4
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 6: Negative numbers
    numbers = [-1, -2, -3, -4, -5]
    window_size = 2
    expected_output = [-1.5, -2.5, -3.5, -4.5]
    assert funcImp(numbers, window_size) == expected_output

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([], 3)",[],[],PASS,TRUE,
13,4,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average of a list of numbers over a specified window size.

    :param numbers: List of numbers to calculate the moving average for.
    :param window_size: The size of the sliding window.
    :return: A list of moving averages.
    """"""
    if window_size <= 0:
        raise ValueError(""Window size must be positive"")
    if not numbers:
        return []

    moving_averages = []
    window_sum = 0
    for i in range(len(numbers)):
        window_sum += numbers[i]
        if i >= window_size:
            window_sum -= numbers[i - window_size]
        if i >= window_size - 1:
            moving_averages.append(window_sum / window_size)

    return moving_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [1, 2, 3, 4, 5]
    window_size = 3
    expected_output = [2.0, 3.0, 4.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 2: Window size of 1 (should return the same list)
    numbers = [1, 2, 3, 4, 5]
    window_size = 1
    expected_output = [1, 2, 3, 4, 5]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 3: Window size equal to the list size (should return one element)
    numbers = [1, 2, 3, 4, 5]
    window_size = 5
    expected_output = [3.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 4: Empty list
    numbers = []
    window_size = 3
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 5: Window size larger than the list size (should return empty list)
    numbers = [1, 2, 3]
    window_size = 4
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 6: Negative numbers
    numbers = [-1, -2, -3, -4, -5]
    window_size = 2
    expected_output = [-1.5, -2.5, -3.5, -4.5]
    assert funcImp(numbers, window_size) == expected_output

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3], 4)",[],[],PASS,TRUE,
13,5,easy,Calculating the average of a list of numbers,Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an algorithm to calculate the moving average (average over a sliding window) for each element in a given list.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(numbers, window_size):
    """"""
    Calculate the moving average of a list of numbers over a specified window size.

    :param numbers: List of numbers to calculate the moving average for.
    :param window_size: The size of the sliding window.
    :return: A list of moving averages.
    """"""
    if window_size <= 0:
        raise ValueError(""Window size must be positive"")
    if not numbers:
        return []

    moving_averages = []
    window_sum = 0
    for i in range(len(numbers)):
        window_sum += numbers[i]
        if i >= window_size:
            window_sum -= numbers[i - window_size]
        if i >= window_size - 1:
            moving_averages.append(window_sum / window_size)

    return moving_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    numbers = [1, 2, 3, 4, 5]
    window_size = 3
    expected_output = [2.0, 3.0, 4.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 2: Window size of 1 (should return the same list)
    numbers = [1, 2, 3, 4, 5]
    window_size = 1
    expected_output = [1, 2, 3, 4, 5]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 3: Window size equal to the list size (should return one element)
    numbers = [1, 2, 3, 4, 5]
    window_size = 5
    expected_output = [3.0]
    assert funcImp(numbers, window_size) == expected_output

    # Test case 4: Empty list
    numbers = []
    window_size = 3
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 5: Window size larger than the list size (should return empty list)
    numbers = [1, 2, 3]
    window_size = 4
    expected_output = []
    assert funcImp(numbers, window_size) == expected_output

    # Test case 6: Negative numbers
    numbers = [-1, -2, -3, -4, -5]
    window_size = 2
    expected_output = [-1.5, -2.5, -3.5, -4.5]
    assert funcImp(numbers, window_size) == expected_output

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([-1, -2, -3, -4, -5], 2)","[-1.5, -2.5, -3.5, -4.5]","[-1.5, -2.5, -3.5, -4.5]",PASS,TRUE,
14,0,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in the array.
    
    Parameters:
    arr (list of float/int): The input array for which running averages are to be calculated.
    
    Returns:
    list of float: A list containing the running averages.
    """"""
    if not arr:
        return []
    
    running_averages = []
    cumulative_sum = 0
    
    for i, value in enumerate(arr):
        cumulative_sum += value
        running_average = cumulative_sum / (i + 1)
        running_averages.append(running_average)
    
    return running_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive integers
    arr1 = [1, 2, 3, 4, 5]
    expected1 = [1.0, 1.5, 2.0, 2.5, 3.0]
    assert funcImp(arr1) == expected1, f""Test case 1 failed: {funcImp(arr1)} != {expected1}""
    
    # Test case 2: Array with negative and positive numbers
    arr2 = [-1, 1, -1, 1]
    expected2 = [-1.0, 0.0, -0.3333333333333333, 0.0]
    assert funcImp(arr2) == expected2, f""Test case 2 failed: {funcImp(arr2)} != {expected2}""
    
    # Test case 3: Array with a single element
    arr3 = [10]
    expected3 = [10.0]
    assert funcImp(arr3) == expected3, f""Test case 3 failed: {funcImp(arr3)} != {expected3}""
    
    # Test case 4: Empty array
    arr4 = []
    expected4 = []
    assert funcImp(arr4) == expected4, f""Test case 4 failed: {funcImp(arr4)} != {expected4}""
    
    # Test case 5: Array with floating point numbers
    arr5 = [1.5, 2.5, 3.5]
    expected5 = [1.5, 2.0, 2.5]
    assert funcImp(arr5) == expected5, f""Test case 5 failed: {funcImp(arr5)} != {expected5}""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]","[1.0, 1.5, 2.0, 2.5, 3.0]","[1.0, 1.5, 2.0, 2.5, 3.0]",PASS,TRUE,
14,1,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in the array.
    
    Parameters:
    arr (list of float/int): The input array for which running averages are to be calculated.
    
    Returns:
    list of float: A list containing the running averages.
    """"""
    if not arr:
        return []
    
    running_averages = []
    cumulative_sum = 0
    
    for i, value in enumerate(arr):
        cumulative_sum += value
        running_average = cumulative_sum / (i + 1)
        running_averages.append(running_average)
    
    return running_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive integers
    arr1 = [1, 2, 3, 4, 5]
    expected1 = [1.0, 1.5, 2.0, 2.5, 3.0]
    assert funcImp(arr1) == expected1, f""Test case 1 failed: {funcImp(arr1)} != {expected1}""
    
    # Test case 2: Array with negative and positive numbers
    arr2 = [-1, 1, -1, 1]
    expected2 = [-1.0, 0.0, -0.3333333333333333, 0.0]
    assert funcImp(arr2) == expected2, f""Test case 2 failed: {funcImp(arr2)} != {expected2}""
    
    # Test case 3: Array with a single element
    arr3 = [10]
    expected3 = [10.0]
    assert funcImp(arr3) == expected3, f""Test case 3 failed: {funcImp(arr3)} != {expected3}""
    
    # Test case 4: Empty array
    arr4 = []
    expected4 = []
    assert funcImp(arr4) == expected4, f""Test case 4 failed: {funcImp(arr4)} != {expected4}""
    
    # Test case 5: Array with floating point numbers
    arr5 = [1.5, 2.5, 3.5]
    expected5 = [1.5, 2.0, 2.5]
    assert funcImp(arr5) == expected5, f""Test case 5 failed: {funcImp(arr5)} != {expected5}""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, 1, -1, 1]","[-1.0, 0.0, -0.3333333333333333, 0.0]","[-1.0, 0.0, -0.3333333333333333, 0.0]",PASS,TRUE,
14,2,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in the array.
    
    Parameters:
    arr (list of float/int): The input array for which running averages are to be calculated.
    
    Returns:
    list of float: A list containing the running averages.
    """"""
    if not arr:
        return []
    
    running_averages = []
    cumulative_sum = 0
    
    for i, value in enumerate(arr):
        cumulative_sum += value
        running_average = cumulative_sum / (i + 1)
        running_averages.append(running_average)
    
    return running_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive integers
    arr1 = [1, 2, 3, 4, 5]
    expected1 = [1.0, 1.5, 2.0, 2.5, 3.0]
    assert funcImp(arr1) == expected1, f""Test case 1 failed: {funcImp(arr1)} != {expected1}""
    
    # Test case 2: Array with negative and positive numbers
    arr2 = [-1, 1, -1, 1]
    expected2 = [-1.0, 0.0, -0.3333333333333333, 0.0]
    assert funcImp(arr2) == expected2, f""Test case 2 failed: {funcImp(arr2)} != {expected2}""
    
    # Test case 3: Array with a single element
    arr3 = [10]
    expected3 = [10.0]
    assert funcImp(arr3) == expected3, f""Test case 3 failed: {funcImp(arr3)} != {expected3}""
    
    # Test case 4: Empty array
    arr4 = []
    expected4 = []
    assert funcImp(arr4) == expected4, f""Test case 4 failed: {funcImp(arr4)} != {expected4}""
    
    # Test case 5: Array with floating point numbers
    arr5 = [1.5, 2.5, 3.5]
    expected5 = [1.5, 2.0, 2.5]
    assert funcImp(arr5) == expected5, f""Test case 5 failed: {funcImp(arr5)} != {expected5}""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[10],[10.0],[10.0],PASS,TRUE,
14,3,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in the array.
    
    Parameters:
    arr (list of float/int): The input array for which running averages are to be calculated.
    
    Returns:
    list of float: A list containing the running averages.
    """"""
    if not arr:
        return []
    
    running_averages = []
    cumulative_sum = 0
    
    for i, value in enumerate(arr):
        cumulative_sum += value
        running_average = cumulative_sum / (i + 1)
        running_averages.append(running_average)
    
    return running_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive integers
    arr1 = [1, 2, 3, 4, 5]
    expected1 = [1.0, 1.5, 2.0, 2.5, 3.0]
    assert funcImp(arr1) == expected1, f""Test case 1 failed: {funcImp(arr1)} != {expected1}""
    
    # Test case 2: Array with negative and positive numbers
    arr2 = [-1, 1, -1, 1]
    expected2 = [-1.0, 0.0, -0.3333333333333333, 0.0]
    assert funcImp(arr2) == expected2, f""Test case 2 failed: {funcImp(arr2)} != {expected2}""
    
    # Test case 3: Array with a single element
    arr3 = [10]
    expected3 = [10.0]
    assert funcImp(arr3) == expected3, f""Test case 3 failed: {funcImp(arr3)} != {expected3}""
    
    # Test case 4: Empty array
    arr4 = []
    expected4 = []
    assert funcImp(arr4) == expected4, f""Test case 4 failed: {funcImp(arr4)} != {expected4}""
    
    # Test case 5: Array with floating point numbers
    arr5 = [1.5, 2.5, 3.5]
    expected5 = [1.5, 2.0, 2.5]
    assert funcImp(arr5) == expected5, f""Test case 5 failed: {funcImp(arr5)} != {expected5}""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],[],[],PASS,TRUE,
14,4,easy,Calculating the average of a list of numbers,"Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to calculate the running average (average up to current position) for each element in an array, without modifying the original array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Calculate the running average for each element in the array.
    
    Parameters:
    arr (list of float/int): The input array for which running averages are to be calculated.
    
    Returns:
    list of float: A list containing the running averages.
    """"""
    if not arr:
        return []
    
    running_averages = []
    cumulative_sum = 0
    
    for i, value in enumerate(arr):
        cumulative_sum += value
        running_average = cumulative_sum / (i + 1)
        running_averages.append(running_average)
    
    return running_averages

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with positive integers
    arr1 = [1, 2, 3, 4, 5]
    expected1 = [1.0, 1.5, 2.0, 2.5, 3.0]
    assert funcImp(arr1) == expected1, f""Test case 1 failed: {funcImp(arr1)} != {expected1}""
    
    # Test case 2: Array with negative and positive numbers
    arr2 = [-1, 1, -1, 1]
    expected2 = [-1.0, 0.0, -0.3333333333333333, 0.0]
    assert funcImp(arr2) == expected2, f""Test case 2 failed: {funcImp(arr2)} != {expected2}""
    
    # Test case 3: Array with a single element
    arr3 = [10]
    expected3 = [10.0]
    assert funcImp(arr3) == expected3, f""Test case 3 failed: {funcImp(arr3)} != {expected3}""
    
    # Test case 4: Empty array
    arr4 = []
    expected4 = []
    assert funcImp(arr4) == expected4, f""Test case 4 failed: {funcImp(arr4)} != {expected4}""
    
    # Test case 5: Array with floating point numbers
    arr5 = [1.5, 2.5, 3.5]
    expected5 = [1.5, 2.0, 2.5]
    assert funcImp(arr5) == expected5, f""Test case 5 failed: {funcImp(arr5)} != {expected5}""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1.5, 2.5, 3.5]","[1.5, 2.0, 2.5]","[1.5, 2.0, 2.5]",PASS,TRUE,
15,0,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",2,TRUE,TRUE,PASS,TRUE,
15,1,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",3,TRUE,TRUE,PASS,TRUE,
15,2,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",4,FALSE,FALSE,PASS,TRUE,
15,3,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",5,TRUE,TRUE,PASS,TRUE,
15,4,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",10,FALSE,FALSE,PASS,TRUE,
15,5,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",13,TRUE,TRUE,PASS,TRUE,
15,6,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",17,TRUE,TRUE,PASS,TRUE,
15,7,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",19,TRUE,TRUE,PASS,TRUE,
15,8,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",20,FALSE,FALSE,PASS,TRUE,
15,9,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",23,TRUE,TRUE,PASS,TRUE,
15,10,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",25,FALSE,FALSE,PASS,TRUE,
15,11,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",29,TRUE,TRUE,PASS,TRUE,
15,12,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",31,TRUE,TRUE,PASS,TRUE,
15,13,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",37,TRUE,TRUE,PASS,TRUE,
15,14,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",41,TRUE,TRUE,PASS,TRUE,
15,15,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",43,TRUE,TRUE,PASS,TRUE,
15,16,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",47,TRUE,TRUE,PASS,TRUE,
15,17,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",53,TRUE,TRUE,PASS,TRUE,
15,18,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",59,TRUE,TRUE,PASS,TRUE,
15,19,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",61,TRUE,TRUE,PASS,TRUE,
15,20,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",67,TRUE,TRUE,PASS,TRUE,
15,21,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",71,TRUE,TRUE,PASS,TRUE,
15,22,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",73,TRUE,TRUE,PASS,TRUE,
15,23,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",79,TRUE,TRUE,PASS,TRUE,
15,24,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",83,TRUE,TRUE,PASS,TRUE,
15,25,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",89,TRUE,TRUE,PASS,TRUE,
15,26,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",97,TRUE,TRUE,PASS,TRUE,
15,27,easy,Checking if a number is prime,Write a program to check if a given number is prime or not.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to check if a given number is prime or not.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Check if a given number is prime.
    
    Parameters:
    n (int): The number to check for primality.
    
    Returns:
    bool: True if the number is prime, False otherwise.
    """"""
    # Edge case: numbers less than or equal to 1 are not prime
    if n <= 1:
        return False
    
    # Check divisibility from 2 to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # If no divisors are found, the number is prime
    return True

# Test cases to verify the correctness of the function
test_cases = [2, 3, 4, 5, 10, 13, 17, 19, 20, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 100]

# Execute the test cases
for number in test_cases:
    print(f""Is {number} a prime number? {funcImp(number)}"")
```",100,FALSE,FALSE,PASS,TRUE,
16,0,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",0,2,2,PASS,TRUE,
16,1,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",1,2,2,PASS,TRUE,
16,2,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",2,3,3,PASS,TRUE,
16,3,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",3,5,5,PASS,TRUE,
16,4,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",10,11,11,PASS,TRUE,
16,5,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",17,19,19,PASS,TRUE,
16,6,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",20,23,23,PASS,TRUE,
16,7,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",100,101,101,PASS,TRUE,
16,8,easy,Checking if a number is prime,Implement a function that returns the smallest prime number greater than a given input.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a function that returns the smallest prime number greater than a given input.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Helper function to check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Function to find the smallest prime number greater than the given input.
    
    Parameters:
    n (int): The input number.
    
    Returns:
    int: The smallest prime number greater than n.
    """"""
    # Start checking from the next number
    candidate = n + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        (0, 2),  # Smallest prime greater than 0 is 2
        (1, 2),  # Smallest prime greater than 1 is 2
        (2, 3),  # Smallest prime greater than 2 is 3
        (3, 5),  # Smallest prime greater than 3 is 5
        (10, 11),  # Smallest prime greater than 10 is 11
        (17, 19),  # Smallest prime greater than 17 is 19
        (20, 23),  # Smallest prime greater than 20 is 23
        (100, 101),  # Smallest prime greater than 100 is 101
        (1000, 1009),  # Smallest prime greater than 1000 is 1009
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result})"")

# Run the test cases
test_funcImp()
```",1000,1009,1009,PASS,TRUE,
17,0,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(start, end):
    """"""
    Print all prime numbers between start and end, inclusive.
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    """"""
    for num in range(start, end + 1):
        if is_prime(num):
            print(num)

# Test cases to verify the solution
print(""Prime numbers between 10 and 30:"")
funcImp(10, 30)

print(""\nPrime numbers between 1 and 10:"")
funcImp(1, 10)

print(""\nPrime numbers between 50 and 60:"")
funcImp(50, 60)

print(""\nPrime numbers between 0 and 5:"")
funcImp(0, 5)

print(""\nPrime numbers between 100 and 110:"")
funcImp(100, 110)
```","(10, 30)","[11, 13, 17, 19, 23, 29]","[11, 13, 17, 19, 23, 29]",PASS,TRUE,
17,1,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(start, end):
    """"""
    Print all prime numbers between start and end, inclusive.
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    """"""
    for num in range(start, end + 1):
        if is_prime(num):
            print(num)

# Test cases to verify the solution
print(""Prime numbers between 10 and 30:"")
funcImp(10, 30)

print(""\nPrime numbers between 1 and 10:"")
funcImp(1, 10)

print(""\nPrime numbers between 50 and 60:"")
funcImp(50, 60)

print(""\nPrime numbers between 0 and 5:"")
funcImp(0, 5)

print(""\nPrime numbers between 100 and 110:"")
funcImp(100, 110)
```","(1, 10)","[2, 3, 5, 7]","[2, 3, 5, 7]",PASS,TRUE,
17,2,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(start, end):
    """"""
    Print all prime numbers between start and end, inclusive.
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    """"""
    for num in range(start, end + 1):
        if is_prime(num):
            print(num)

# Test cases to verify the solution
print(""Prime numbers between 10 and 30:"")
funcImp(10, 30)

print(""\nPrime numbers between 1 and 10:"")
funcImp(1, 10)

print(""\nPrime numbers between 50 and 60:"")
funcImp(50, 60)

print(""\nPrime numbers between 0 and 5:"")
funcImp(0, 5)

print(""\nPrime numbers between 100 and 110:"")
funcImp(100, 110)
```","(50, 60)","[53, 59]","[53, 59]",PASS,TRUE,
17,3,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(start, end):
    """"""
    Print all prime numbers between start and end, inclusive.
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    """"""
    for num in range(start, end + 1):
        if is_prime(num):
            print(num)

# Test cases to verify the solution
print(""Prime numbers between 10 and 30:"")
funcImp(10, 30)

print(""\nPrime numbers between 1 and 10:"")
funcImp(1, 10)

print(""\nPrime numbers between 50 and 60:"")
funcImp(50, 60)

print(""\nPrime numbers between 0 and 5:"")
funcImp(0, 5)

print(""\nPrime numbers between 100 and 110:"")
funcImp(100, 110)
```","(0, 5)","[2, 3, 5]","[2, 3, 5]",PASS,TRUE,
17,4,easy,Checking if a number is prime,Create a program that prints all the prime numbers between two given numbers.,"## Problem Statement
- Develop a Python script to solve the problem: 'Create a program that prints all the prime numbers between two given numbers.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(start, end):
    """"""
    Print all prime numbers between start and end, inclusive.
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    """"""
    for num in range(start, end + 1):
        if is_prime(num):
            print(num)

# Test cases to verify the solution
print(""Prime numbers between 10 and 30:"")
funcImp(10, 30)

print(""\nPrime numbers between 1 and 10:"")
funcImp(1, 10)

print(""\nPrime numbers between 50 and 60:"")
funcImp(50, 60)

print(""\nPrime numbers between 0 and 5:"")
funcImp(0, 5)

print(""\nPrime numbers between 100 and 110:"")
funcImp(100, 110)
```","(100, 110)","[101, 103, 107, 109]","[101, 103, 107, 109]",PASS,TRUE,
18,0,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    
    Returns:
    int: The sum of all prime numbers within the range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate through the range and sum up the primes
    for number in range(start, end + 1):
        if is_prime(number):
            sum_of_primes += number
    
    return sum_of_primes

# Test cases to verify the solution
print(funcImp(1, 10))  # Expected output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20)) # Expected output: 60 (11 + 13 + 17 + 19)
print(funcImp(20, 30)) # Expected output: 52 (23 + 29)
print(funcImp(1, 1))   # Expected output: 0 (no primes in this range)
print(funcImp(0, 0))   # Expected output: 0 (no primes in this range)
print(funcImp(2, 2))   # Expected output: 2 (2 is a prime number)
```","(1, 10)",17,17,PASS,TRUE,
18,1,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    
    Returns:
    int: The sum of all prime numbers within the range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate through the range and sum up the primes
    for number in range(start, end + 1):
        if is_prime(number):
            sum_of_primes += number
    
    return sum_of_primes

# Test cases to verify the solution
print(funcImp(1, 10))  # Expected output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20)) # Expected output: 60 (11 + 13 + 17 + 19)
print(funcImp(20, 30)) # Expected output: 52 (23 + 29)
print(funcImp(1, 1))   # Expected output: 0 (no primes in this range)
print(funcImp(0, 0))   # Expected output: 0 (no primes in this range)
print(funcImp(2, 2))   # Expected output: 2 (2 is a prime number)
```","(10, 20)",60,60,PASS,TRUE,
18,2,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    
    Returns:
    int: The sum of all prime numbers within the range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate through the range and sum up the primes
    for number in range(start, end + 1):
        if is_prime(number):
            sum_of_primes += number
    
    return sum_of_primes

# Test cases to verify the solution
print(funcImp(1, 10))  # Expected output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20)) # Expected output: 60 (11 + 13 + 17 + 19)
print(funcImp(20, 30)) # Expected output: 52 (23 + 29)
print(funcImp(1, 1))   # Expected output: 0 (no primes in this range)
print(funcImp(0, 0))   # Expected output: 0 (no primes in this range)
print(funcImp(2, 2))   # Expected output: 2 (2 is a prime number)
```","(20, 30)",52,52,PASS,TRUE,
18,3,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    
    Returns:
    int: The sum of all prime numbers within the range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate through the range and sum up the primes
    for number in range(start, end + 1):
        if is_prime(number):
            sum_of_primes += number
    
    return sum_of_primes

# Test cases to verify the solution
print(funcImp(1, 10))  # Expected output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20)) # Expected output: 60 (11 + 13 + 17 + 19)
print(funcImp(20, 30)) # Expected output: 52 (23 + 29)
print(funcImp(1, 1))   # Expected output: 0 (no primes in this range)
print(funcImp(0, 0))   # Expected output: 0 (no primes in this range)
print(funcImp(2, 2))   # Expected output: 2 (2 is a prime number)
```","(1, 1)",0,0,PASS,TRUE,
18,4,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    
    Returns:
    int: The sum of all prime numbers within the range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate through the range and sum up the primes
    for number in range(start, end + 1):
        if is_prime(number):
            sum_of_primes += number
    
    return sum_of_primes

# Test cases to verify the solution
print(funcImp(1, 10))  # Expected output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20)) # Expected output: 60 (11 + 13 + 17 + 19)
print(funcImp(20, 30)) # Expected output: 52 (23 + 29)
print(funcImp(1, 1))   # Expected output: 0 (no primes in this range)
print(funcImp(0, 0))   # Expected output: 0 (no primes in this range)
print(funcImp(2, 2))   # Expected output: 2 (2 is a prime number)
```","(0, 0)",0,0,PASS,TRUE,
18,5,easy,Checking if a number is prime,Develop an algorithm to find the sum of all prime numbers within a given range.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to find the sum of all prime numbers within a given range.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(start, end):
    """"""
    This function calculates the sum of all prime numbers within a given range [start, end].
    
    Parameters:
    start (int): The starting number of the range.
    end (int): The ending number of the range.
    
    Returns:
    int: The sum of all prime numbers within the range.
    """"""
    
    def is_prime(n):
        """"""Helper function to check if a number is prime.""""""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    # Initialize sum of primes
    sum_of_primes = 0
    
    # Iterate through the range and sum up the primes
    for number in range(start, end + 1):
        if is_prime(number):
            sum_of_primes += number
    
    return sum_of_primes

# Test cases to verify the solution
print(funcImp(1, 10))  # Expected output: 17 (2 + 3 + 5 + 7)
print(funcImp(10, 20)) # Expected output: 60 (11 + 13 + 17 + 19)
print(funcImp(20, 30)) # Expected output: 52 (23 + 29)
print(funcImp(1, 1))   # Expected output: 0 (no primes in this range)
print(funcImp(0, 0))   # Expected output: 0 (no primes in this range)
print(funcImp(2, 2))   # Expected output: 2 (2 is a prime number)
```","(2, 2)",2,2,PASS,TRUE,
19,0,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor of.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    # Handle edge case where n is less than 2
    if n < 2:
        return None
    
    # Initialize the largest prime factor
    largest_prime = None
    
    # Divide n by 2 until it is odd
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_prime = factor
            n //= factor
        factor += 2
    
    # If n is still greater than 2, then it is a prime number
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test cases to verify the correctness of the function
test_cases = [
    (10, 5),  # 10 = 2 * 5
    (15, 5),  # 15 = 3 * 5
    (21, 7),  # 21 = 3 * 7
    (29, 29), # 29 is a prime number
    (44, 11), # 44 = 2 * 2 * 11
    (1, None), # 1 has no prime factors
    (0, None), # 0 has no prime factors
    (-10, None) # Negative numbers have no prime factors
]

# Execute test cases
for i, (input_val, expected) in enumerate(test_cases):
    result = funcImp(input_val)
    assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
    print(f""Test case {i+1} passed: input({input_val}) => output({result})"")
```",10,5,5,PASS,TRUE,
19,1,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor of.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    # Handle edge case where n is less than 2
    if n < 2:
        return None
    
    # Initialize the largest prime factor
    largest_prime = None
    
    # Divide n by 2 until it is odd
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_prime = factor
            n //= factor
        factor += 2
    
    # If n is still greater than 2, then it is a prime number
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test cases to verify the correctness of the function
test_cases = [
    (10, 5),  # 10 = 2 * 5
    (15, 5),  # 15 = 3 * 5
    (21, 7),  # 21 = 3 * 7
    (29, 29), # 29 is a prime number
    (44, 11), # 44 = 2 * 2 * 11
    (1, None), # 1 has no prime factors
    (0, None), # 0 has no prime factors
    (-10, None) # Negative numbers have no prime factors
]

# Execute test cases
for i, (input_val, expected) in enumerate(test_cases):
    result = funcImp(input_val)
    assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
    print(f""Test case {i+1} passed: input({input_val}) => output({result})"")
```",15,5,5,PASS,TRUE,
19,2,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor of.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    # Handle edge case where n is less than 2
    if n < 2:
        return None
    
    # Initialize the largest prime factor
    largest_prime = None
    
    # Divide n by 2 until it is odd
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_prime = factor
            n //= factor
        factor += 2
    
    # If n is still greater than 2, then it is a prime number
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test cases to verify the correctness of the function
test_cases = [
    (10, 5),  # 10 = 2 * 5
    (15, 5),  # 15 = 3 * 5
    (21, 7),  # 21 = 3 * 7
    (29, 29), # 29 is a prime number
    (44, 11), # 44 = 2 * 2 * 11
    (1, None), # 1 has no prime factors
    (0, None), # 0 has no prime factors
    (-10, None) # Negative numbers have no prime factors
]

# Execute test cases
for i, (input_val, expected) in enumerate(test_cases):
    result = funcImp(input_val)
    assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
    print(f""Test case {i+1} passed: input({input_val}) => output({result})"")
```",21,7,7,PASS,TRUE,
19,3,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor of.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    # Handle edge case where n is less than 2
    if n < 2:
        return None
    
    # Initialize the largest prime factor
    largest_prime = None
    
    # Divide n by 2 until it is odd
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_prime = factor
            n //= factor
        factor += 2
    
    # If n is still greater than 2, then it is a prime number
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test cases to verify the correctness of the function
test_cases = [
    (10, 5),  # 10 = 2 * 5
    (15, 5),  # 15 = 3 * 5
    (21, 7),  # 21 = 3 * 7
    (29, 29), # 29 is a prime number
    (44, 11), # 44 = 2 * 2 * 11
    (1, None), # 1 has no prime factors
    (0, None), # 0 has no prime factors
    (-10, None) # Negative numbers have no prime factors
]

# Execute test cases
for i, (input_val, expected) in enumerate(test_cases):
    result = funcImp(input_val)
    assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
    print(f""Test case {i+1} passed: input({input_val}) => output({result})"")
```",29,29,29,PASS,TRUE,
19,4,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor of.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    # Handle edge case where n is less than 2
    if n < 2:
        return None
    
    # Initialize the largest prime factor
    largest_prime = None
    
    # Divide n by 2 until it is odd
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_prime = factor
            n //= factor
        factor += 2
    
    # If n is still greater than 2, then it is a prime number
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test cases to verify the correctness of the function
test_cases = [
    (10, 5),  # 10 = 2 * 5
    (15, 5),  # 15 = 3 * 5
    (21, 7),  # 21 = 3 * 7
    (29, 29), # 29 is a prime number
    (44, 11), # 44 = 2 * 2 * 11
    (1, None), # 1 has no prime factors
    (0, None), # 0 has no prime factors
    (-10, None) # Negative numbers have no prime factors
]

# Execute test cases
for i, (input_val, expected) in enumerate(test_cases):
    result = funcImp(input_val)
    assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
    print(f""Test case {i+1} passed: input({input_val}) => output({result})"")
```",44,11,11,PASS,TRUE,
19,5,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor of.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    # Handle edge case where n is less than 2
    if n < 2:
        return None
    
    # Initialize the largest prime factor
    largest_prime = None
    
    # Divide n by 2 until it is odd
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_prime = factor
            n //= factor
        factor += 2
    
    # If n is still greater than 2, then it is a prime number
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test cases to verify the correctness of the function
test_cases = [
    (10, 5),  # 10 = 2 * 5
    (15, 5),  # 15 = 3 * 5
    (21, 7),  # 21 = 3 * 7
    (29, 29), # 29 is a prime number
    (44, 11), # 44 = 2 * 2 * 11
    (1, None), # 1 has no prime factors
    (0, None), # 0 has no prime factors
    (-10, None) # Negative numbers have no prime factors
]

# Execute test cases
for i, (input_val, expected) in enumerate(test_cases):
    result = funcImp(input_val)
    assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
    print(f""Test case {i+1} passed: input({input_val}) => output({result})"")
```",1,,,PASS,TRUE,
19,6,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor of.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    # Handle edge case where n is less than 2
    if n < 2:
        return None
    
    # Initialize the largest prime factor
    largest_prime = None
    
    # Divide n by 2 until it is odd
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_prime = factor
            n //= factor
        factor += 2
    
    # If n is still greater than 2, then it is a prime number
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test cases to verify the correctness of the function
test_cases = [
    (10, 5),  # 10 = 2 * 5
    (15, 5),  # 15 = 3 * 5
    (21, 7),  # 21 = 3 * 7
    (29, 29), # 29 is a prime number
    (44, 11), # 44 = 2 * 2 * 11
    (1, None), # 1 has no prime factors
    (0, None), # 0 has no prime factors
    (-10, None) # Negative numbers have no prime factors
]

# Execute test cases
for i, (input_val, expected) in enumerate(test_cases):
    result = funcImp(input_val)
    assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
    print(f""Test case {i+1} passed: input({input_val}) => output({result})"")
```",0,,,PASS,TRUE,
19,7,easy,Checking if a number is prime,Design a function to calculate the largest prime factor of a given number.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design a function to calculate the largest prime factor of a given number.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(n):
    """"""
    Calculate the largest prime factor of a given number n.
    
    Parameters:
    n (int): The number to find the largest prime factor of.
    
    Returns:
    int: The largest prime factor of n.
    """"""
    # Handle edge case where n is less than 2
    if n < 2:
        return None
    
    # Initialize the largest prime factor
    largest_prime = None
    
    # Divide n by 2 until it is odd
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # Check for odd factors from 3 onwards
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_prime = factor
            n //= factor
        factor += 2
    
    # If n is still greater than 2, then it is a prime number
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test cases to verify the correctness of the function
test_cases = [
    (10, 5),  # 10 = 2 * 5
    (15, 5),  # 15 = 3 * 5
    (21, 7),  # 21 = 3 * 7
    (29, 29), # 29 is a prime number
    (44, 11), # 44 = 2 * 2 * 11
    (1, None), # 1 has no prime factors
    (0, None), # 0 has no prime factors
    (-10, None) # Negative numbers have no prime factors
]

# Execute test cases
for i, (input_val, expected) in enumerate(test_cases):
    result = funcImp(input_val)
    assert result == expected, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
    print(f""Test case {i+1} passed: input({input_val}) => output({result})"")
```",-10,,,PASS,TRUE,
20,0,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",4,TRUE,TRUE,PASS,TRUE,
20,1,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",6,TRUE,TRUE,PASS,TRUE,
20,2,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",9,TRUE,TRUE,PASS,TRUE,
20,3,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",10,TRUE,TRUE,PASS,TRUE,
20,4,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",15,TRUE,TRUE,PASS,TRUE,
20,5,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",16,FALSE,FALSE,PASS,TRUE,
20,6,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",17,FALSE,FALSE,PASS,TRUE,
20,7,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",21,TRUE,TRUE,PASS,TRUE,
20,8,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",22,TRUE,TRUE,PASS,TRUE,
20,9,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",25,TRUE,TRUE,PASS,TRUE,
20,10,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",28,FALSE,FALSE,PASS,TRUE,
20,11,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",49,TRUE,TRUE,PASS,TRUE,
20,12,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",1,FALSE,FALSE,PASS,TRUE,
20,13,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",0,FALSE,FALSE,PASS,TRUE,
20,14,easy,Checking if a number is prime,Write code to determine if a given number is semiprime (a product of two prime numbers).,"## Problem Statement
- Develop a Python script to solve the problem: 'Write code to determine if a given number is semiprime (a product of two prime numbers).'.

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def funcImp(n):
    """"""
    Determine if a given number is semiprime.
    
    A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers.
    """"""
    if n < 4:  # The smallest semiprime is 4 (2*2)
        return False
    
    # Check for factors up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:  # i is a factor
            other_factor = n // i
            # Check if both factors are prime
            if is_prime(i) and is_prime(other_factor):
                return True
    return False

# Test cases to verify the solution
test_cases = [
    (4, True),    # 2 * 2
    (6, True),    # 2 * 3
    (9, True),    # 3 * 3
    (10, True),   # 2 * 5
    (15, True),   # 3 * 5
    (16, False),  # 2 * 2 * 2 (not semiprime)
    (17, False),  # Prime number
    (21, True),   # 3 * 7
    (22, True),   # 2 * 11
    (25, True),   # 5 * 5
    (28, False),  # 2 * 2 * 7 (not semiprime)
    (49, True),   # 7 * 7
    (1, False),   # Less than 4
    (0, False),   # Less than 4
    (77, True),   # 7 * 11
]

# Execute test cases
for number, expected in test_cases:
    result = funcImp(number)
    print(f""funcImp({number}) = {result}, expected = {expected}, {'PASS' if result == expected else 'FAIL'}"")
```",77,TRUE,TRUE,PASS,TRUE,
21,0,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    
    Bubble Sort works by repeatedly stepping through the list,
    comparing adjacent elements and swapping them if they are in the wrong order.
    This process is repeated until the list is sorted.
    
    Time Complexity:
    - Best case: O(n) when the list is already sorted.
    - Average and Worst case: O(n^2) due to the nested loops.
    """"""
    n = len(arr)
    # Traverse through all elements in the list
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with unsorted numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2, 1]) == [-3, -2, -1, 0, 1, 2]
    
    # Test case 4: List with duplicate numbers
    assert funcImp([3, 3, 2, 1, 2]) == [1, 2, 2, 3, 3]
    
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    
    # Test case 6: Empty list
    assert funcImp([]) == []
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[64, 34, 25, 12, 22, 11, 90]","[11, 12, 22, 25, 34, 64, 90]","[11, 12, 22, 25, 34, 64, 90]",PASS,TRUE,
21,1,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    
    Bubble Sort works by repeatedly stepping through the list,
    comparing adjacent elements and swapping them if they are in the wrong order.
    This process is repeated until the list is sorted.
    
    Time Complexity:
    - Best case: O(n) when the list is already sorted.
    - Average and Worst case: O(n^2) due to the nested loops.
    """"""
    n = len(arr)
    # Traverse through all elements in the list
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with unsorted numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2, 1]) == [-3, -2, -1, 0, 1, 2]
    
    # Test case 4: List with duplicate numbers
    assert funcImp([3, 3, 2, 1, 2]) == [1, 2, 2, 3, 3]
    
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    
    # Test case 6: Empty list
    assert funcImp([]) == []
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,
21,2,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    
    Bubble Sort works by repeatedly stepping through the list,
    comparing adjacent elements and swapping them if they are in the wrong order.
    This process is repeated until the list is sorted.
    
    Time Complexity:
    - Best case: O(n) when the list is already sorted.
    - Average and Worst case: O(n^2) due to the nested loops.
    """"""
    n = len(arr)
    # Traverse through all elements in the list
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with unsorted numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2, 1]) == [-3, -2, -1, 0, 1, 2]
    
    # Test case 4: List with duplicate numbers
    assert funcImp([3, 3, 2, 1, 2]) == [1, 2, 2, 3, 3]
    
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    
    # Test case 6: Empty list
    assert funcImp([]) == []
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, -3, -2, 0, 2, 1]","[-3, -2, -1, 0, 1, 2]","[-3, -2, -1, 0, 1, 2]",PASS,TRUE,
21,3,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    
    Bubble Sort works by repeatedly stepping through the list,
    comparing adjacent elements and swapping them if they are in the wrong order.
    This process is repeated until the list is sorted.
    
    Time Complexity:
    - Best case: O(n) when the list is already sorted.
    - Average and Worst case: O(n^2) due to the nested loops.
    """"""
    n = len(arr)
    # Traverse through all elements in the list
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with unsorted numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2, 1]) == [-3, -2, -1, 0, 1, 2]
    
    # Test case 4: List with duplicate numbers
    assert funcImp([3, 3, 2, 1, 2]) == [1, 2, 2, 3, 3]
    
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    
    # Test case 6: Empty list
    assert funcImp([]) == []
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[3, 3, 2, 1, 2]","[1, 2, 2, 3, 3]","[1, 2, 2, 3, 3]",PASS,TRUE,
21,4,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    
    Bubble Sort works by repeatedly stepping through the list,
    comparing adjacent elements and swapping them if they are in the wrong order.
    This process is repeated until the list is sorted.
    
    Time Complexity:
    - Best case: O(n) when the list is already sorted.
    - Average and Worst case: O(n^2) due to the nested loops.
    """"""
    n = len(arr)
    # Traverse through all elements in the list
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with unsorted numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2, 1]) == [-3, -2, -1, 0, 1, 2]
    
    # Test case 4: List with duplicate numbers
    assert funcImp([3, 3, 2, 1, 2]) == [1, 2, 2, 3, 3]
    
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    
    # Test case 6: Empty list
    assert funcImp([]) == []
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[1],[1],[1],PASS,TRUE,
21,5,medium,Sorting algorithms,Implement the Bubble Sort algorithm and analyze its time complexity.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Bubble Sort algorithm and analyze its time complexity.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function implements the Bubble Sort algorithm.
    It takes a list of numbers as input and returns the sorted list.
    
    Bubble Sort works by repeatedly stepping through the list,
    comparing adjacent elements and swapping them if they are in the wrong order.
    This process is repeated until the list is sorted.
    
    Time Complexity:
    - Best case: O(n) when the list is already sorted.
    - Average and Worst case: O(n^2) due to the nested loops.
    """"""
    n = len(arr)
    # Traverse through all elements in the list
    for i in range(n):
        # Last i elements are already sorted, no need to check them
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with unsorted numbers
    assert funcImp([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]
    
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2, 1]) == [-3, -2, -1, 0, 1, 2]
    
    # Test case 4: List with duplicate numbers
    assert funcImp([3, 3, 2, 1, 2]) == [1, 2, 2, 3, 3]
    
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    
    # Test case 6: Empty list
    assert funcImp([]) == []
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],[],[],PASS,TRUE,
22,0,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result..","```python
def funcImp(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It sorts a list of numbers in ascending order.

    Parameters:
    arr (list): A list of numbers to be sorted.

    Returns:
    list: The sorted list of numbers.
    """"""
    # Traverse from 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13]
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse sorted list
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: List with duplicates
    assert funcImp([3, 1, 2, 3, 1]) == [1, 1, 2, 3, 3]
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    # Test case 7: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[12, 11, 13, 5, 6]","[5, 6, 11, 12, 13]","[5, 6, 11, 12, 13]",PASS,TRUE,
22,1,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result..","```python
def funcImp(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It sorts a list of numbers in ascending order.

    Parameters:
    arr (list): A list of numbers to be sorted.

    Returns:
    list: The sorted list of numbers.
    """"""
    # Traverse from 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13]
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse sorted list
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: List with duplicates
    assert funcImp([3, 1, 2, 3, 1]) == [1, 1, 2, 3, 3]
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    # Test case 7: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,
22,2,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result..","```python
def funcImp(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It sorts a list of numbers in ascending order.

    Parameters:
    arr (list): A list of numbers to be sorted.

    Returns:
    list: The sorted list of numbers.
    """"""
    # Traverse from 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13]
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse sorted list
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: List with duplicates
    assert funcImp([3, 1, 2, 3, 1]) == [1, 1, 2, 3, 3]
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    # Test case 7: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[5, 4, 3, 2, 1]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,
22,3,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result..","```python
def funcImp(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It sorts a list of numbers in ascending order.

    Parameters:
    arr (list): A list of numbers to be sorted.

    Returns:
    list: The sorted list of numbers.
    """"""
    # Traverse from 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13]
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse sorted list
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: List with duplicates
    assert funcImp([3, 1, 2, 3, 1]) == [1, 1, 2, 3, 3]
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    # Test case 7: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[3, 1, 2, 3, 1]","[1, 1, 2, 3, 3]","[1, 1, 2, 3, 3]",PASS,TRUE,
22,4,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result..","```python
def funcImp(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It sorts a list of numbers in ascending order.

    Parameters:
    arr (list): A list of numbers to be sorted.

    Returns:
    list: The sorted list of numbers.
    """"""
    # Traverse from 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13]
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse sorted list
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: List with duplicates
    assert funcImp([3, 1, 2, 3, 1]) == [1, 1, 2, 3, 3]
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    # Test case 7: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[1],[1],[1],PASS,TRUE,
22,5,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result..","```python
def funcImp(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It sorts a list of numbers in ascending order.

    Parameters:
    arr (list): A list of numbers to be sorted.

    Returns:
    list: The sorted list of numbers.
    """"""
    # Traverse from 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13]
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse sorted list
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: List with duplicates
    assert funcImp([3, 1, 2, 3, 1]) == [1, 1, 2, 3, 3]
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    # Test case 7: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],[],[],PASS,TRUE,
22,6,medium,Sorting algorithms,Write a program to implement the Insertion Sort algorithm.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Insertion Sort algorithm.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result..","```python
def funcImp(arr):
    """"""
    This function implements the Insertion Sort algorithm.
    It sorts a list of numbers in ascending order.

    Parameters:
    arr (list): A list of numbers to be sorted.

    Returns:
    list: The sorted list of numbers.
    """"""
    # Traverse from 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13]
    # Test case 2: Already sorted list
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse sorted list
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: List with duplicates
    assert funcImp([3, 1, 2, 3, 1]) == [1, 1, 2, 3, 3]
    # Test case 5: Single element list
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    # Test case 7: List with negative numbers
    assert funcImp([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-1, -3, -2, 0, 2]","[-3, -2, -1, 0, 2]","[-3, -2, -1, 0, 2]",PASS,TRUE,
23,0,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.

    Parameters:
    strings (list): A list of strings to be sorted.

    Returns:
    list: A new list containing the sorted strings.
    """"""
    # Using Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with mixed strings
    assert funcImp([""banana"", ""apple"", ""cherry""]) == [""apple"", ""banana"", ""cherry""]
    
    # Test case 2: Strings with numbers
    assert funcImp([""1apple"", ""2banana"", ""10cherry""]) == [""10cherry"", ""1apple"", ""2banana""]
    
    # Test case 3: Strings with special characters
    assert funcImp([""!apple"", ""#banana"", ""@cherry""]) == [""!apple"", ""#banana"", ""@cherry""]
    
    # Test case 4: Empty list
    assert funcImp([]) == []
    
    # Test case 5: List with one string
    assert funcImp([""single""]) == [""single""]
    
    # Test case 6: Strings with mixed case
    assert funcImp([""Banana"", ""apple"", ""Cherry""]) == [""Banana"", ""Cherry"", ""apple""]
    
    # Test case 7: Strings with spaces
    assert funcImp([""apple pie"", ""apple"", ""banana""]) == [""apple"", ""apple pie"", ""banana""]
    
    # Test case 8: Identical strings
    assert funcImp([""same"", ""same"", ""same""]) == [""same"", ""same"", ""same""]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","['banana', 'apple', 'cherry']","['apple', 'banana', 'cherry']","['apple', 'banana', 'cherry']",PASS,TRUE,
23,1,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.

    Parameters:
    strings (list): A list of strings to be sorted.

    Returns:
    list: A new list containing the sorted strings.
    """"""
    # Using Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with mixed strings
    assert funcImp([""banana"", ""apple"", ""cherry""]) == [""apple"", ""banana"", ""cherry""]
    
    # Test case 2: Strings with numbers
    assert funcImp([""1apple"", ""2banana"", ""10cherry""]) == [""10cherry"", ""1apple"", ""2banana""]
    
    # Test case 3: Strings with special characters
    assert funcImp([""!apple"", ""#banana"", ""@cherry""]) == [""!apple"", ""#banana"", ""@cherry""]
    
    # Test case 4: Empty list
    assert funcImp([]) == []
    
    # Test case 5: List with one string
    assert funcImp([""single""]) == [""single""]
    
    # Test case 6: Strings with mixed case
    assert funcImp([""Banana"", ""apple"", ""Cherry""]) == [""Banana"", ""Cherry"", ""apple""]
    
    # Test case 7: Strings with spaces
    assert funcImp([""apple pie"", ""apple"", ""banana""]) == [""apple"", ""apple pie"", ""banana""]
    
    # Test case 8: Identical strings
    assert funcImp([""same"", ""same"", ""same""]) == [""same"", ""same"", ""same""]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","['1apple', '2banana', '10cherry']","['10cherry', '1apple', '2banana']","['10cherry', '1apple', '2banana']",PASS,TRUE,
23,2,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.

    Parameters:
    strings (list): A list of strings to be sorted.

    Returns:
    list: A new list containing the sorted strings.
    """"""
    # Using Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with mixed strings
    assert funcImp([""banana"", ""apple"", ""cherry""]) == [""apple"", ""banana"", ""cherry""]
    
    # Test case 2: Strings with numbers
    assert funcImp([""1apple"", ""2banana"", ""10cherry""]) == [""10cherry"", ""1apple"", ""2banana""]
    
    # Test case 3: Strings with special characters
    assert funcImp([""!apple"", ""#banana"", ""@cherry""]) == [""!apple"", ""#banana"", ""@cherry""]
    
    # Test case 4: Empty list
    assert funcImp([]) == []
    
    # Test case 5: List with one string
    assert funcImp([""single""]) == [""single""]
    
    # Test case 6: Strings with mixed case
    assert funcImp([""Banana"", ""apple"", ""Cherry""]) == [""Banana"", ""Cherry"", ""apple""]
    
    # Test case 7: Strings with spaces
    assert funcImp([""apple pie"", ""apple"", ""banana""]) == [""apple"", ""apple pie"", ""banana""]
    
    # Test case 8: Identical strings
    assert funcImp([""same"", ""same"", ""same""]) == [""same"", ""same"", ""same""]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","['!apple', '#banana', '@cherry']","['!apple', '#banana', '@cherry']","['!apple', '#banana', '@cherry']",PASS,TRUE,
23,3,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.

    Parameters:
    strings (list): A list of strings to be sorted.

    Returns:
    list: A new list containing the sorted strings.
    """"""
    # Using Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with mixed strings
    assert funcImp([""banana"", ""apple"", ""cherry""]) == [""apple"", ""banana"", ""cherry""]
    
    # Test case 2: Strings with numbers
    assert funcImp([""1apple"", ""2banana"", ""10cherry""]) == [""10cherry"", ""1apple"", ""2banana""]
    
    # Test case 3: Strings with special characters
    assert funcImp([""!apple"", ""#banana"", ""@cherry""]) == [""!apple"", ""#banana"", ""@cherry""]
    
    # Test case 4: Empty list
    assert funcImp([]) == []
    
    # Test case 5: List with one string
    assert funcImp([""single""]) == [""single""]
    
    # Test case 6: Strings with mixed case
    assert funcImp([""Banana"", ""apple"", ""Cherry""]) == [""Banana"", ""Cherry"", ""apple""]
    
    # Test case 7: Strings with spaces
    assert funcImp([""apple pie"", ""apple"", ""banana""]) == [""apple"", ""apple pie"", ""banana""]
    
    # Test case 8: Identical strings
    assert funcImp([""same"", ""same"", ""same""]) == [""same"", ""same"", ""same""]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],[],[],PASS,TRUE,
23,4,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.

    Parameters:
    strings (list): A list of strings to be sorted.

    Returns:
    list: A new list containing the sorted strings.
    """"""
    # Using Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with mixed strings
    assert funcImp([""banana"", ""apple"", ""cherry""]) == [""apple"", ""banana"", ""cherry""]
    
    # Test case 2: Strings with numbers
    assert funcImp([""1apple"", ""2banana"", ""10cherry""]) == [""10cherry"", ""1apple"", ""2banana""]
    
    # Test case 3: Strings with special characters
    assert funcImp([""!apple"", ""#banana"", ""@cherry""]) == [""!apple"", ""#banana"", ""@cherry""]
    
    # Test case 4: Empty list
    assert funcImp([]) == []
    
    # Test case 5: List with one string
    assert funcImp([""single""]) == [""single""]
    
    # Test case 6: Strings with mixed case
    assert funcImp([""Banana"", ""apple"", ""Cherry""]) == [""Banana"", ""Cherry"", ""apple""]
    
    # Test case 7: Strings with spaces
    assert funcImp([""apple pie"", ""apple"", ""banana""]) == [""apple"", ""apple pie"", ""banana""]
    
    # Test case 8: Identical strings
    assert funcImp([""same"", ""same"", ""same""]) == [""same"", ""same"", ""same""]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",['single'],['single'],['single'],PASS,TRUE,
23,5,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.

    Parameters:
    strings (list): A list of strings to be sorted.

    Returns:
    list: A new list containing the sorted strings.
    """"""
    # Using Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with mixed strings
    assert funcImp([""banana"", ""apple"", ""cherry""]) == [""apple"", ""banana"", ""cherry""]
    
    # Test case 2: Strings with numbers
    assert funcImp([""1apple"", ""2banana"", ""10cherry""]) == [""10cherry"", ""1apple"", ""2banana""]
    
    # Test case 3: Strings with special characters
    assert funcImp([""!apple"", ""#banana"", ""@cherry""]) == [""!apple"", ""#banana"", ""@cherry""]
    
    # Test case 4: Empty list
    assert funcImp([]) == []
    
    # Test case 5: List with one string
    assert funcImp([""single""]) == [""single""]
    
    # Test case 6: Strings with mixed case
    assert funcImp([""Banana"", ""apple"", ""Cherry""]) == [""Banana"", ""Cherry"", ""apple""]
    
    # Test case 7: Strings with spaces
    assert funcImp([""apple pie"", ""apple"", ""banana""]) == [""apple"", ""apple pie"", ""banana""]
    
    # Test case 8: Identical strings
    assert funcImp([""same"", ""same"", ""same""]) == [""same"", ""same"", ""same""]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","['Banana', 'apple', 'Cherry']","['Banana', 'Cherry', 'apple']","['Banana', 'Cherry', 'apple']",PASS,TRUE,
23,6,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.

    Parameters:
    strings (list): A list of strings to be sorted.

    Returns:
    list: A new list containing the sorted strings.
    """"""
    # Using Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with mixed strings
    assert funcImp([""banana"", ""apple"", ""cherry""]) == [""apple"", ""banana"", ""cherry""]
    
    # Test case 2: Strings with numbers
    assert funcImp([""1apple"", ""2banana"", ""10cherry""]) == [""10cherry"", ""1apple"", ""2banana""]
    
    # Test case 3: Strings with special characters
    assert funcImp([""!apple"", ""#banana"", ""@cherry""]) == [""!apple"", ""#banana"", ""@cherry""]
    
    # Test case 4: Empty list
    assert funcImp([]) == []
    
    # Test case 5: List with one string
    assert funcImp([""single""]) == [""single""]
    
    # Test case 6: Strings with mixed case
    assert funcImp([""Banana"", ""apple"", ""Cherry""]) == [""Banana"", ""Cherry"", ""apple""]
    
    # Test case 7: Strings with spaces
    assert funcImp([""apple pie"", ""apple"", ""banana""]) == [""apple"", ""apple pie"", ""banana""]
    
    # Test case 8: Identical strings
    assert funcImp([""same"", ""same"", ""same""]) == [""same"", ""same"", ""same""]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","['apple pie', 'apple', 'banana']","['apple', 'apple pie', 'banana']","['apple', 'apple pie', 'banana']",PASS,TRUE,
23,7,medium,Sorting algorithms,Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Design an algorithm to sort an array of strings in lexicographical order using any suitable sorting technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(strings):
    """"""
    Sorts an array of strings in lexicographical order.

    Parameters:
    strings (list): A list of strings to be sorted.

    Returns:
    list: A new list containing the sorted strings.
    """"""
    # Using Python's built-in sorted function to sort the list of strings
    return sorted(strings)

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Normal case with mixed strings
    assert funcImp([""banana"", ""apple"", ""cherry""]) == [""apple"", ""banana"", ""cherry""]
    
    # Test case 2: Strings with numbers
    assert funcImp([""1apple"", ""2banana"", ""10cherry""]) == [""10cherry"", ""1apple"", ""2banana""]
    
    # Test case 3: Strings with special characters
    assert funcImp([""!apple"", ""#banana"", ""@cherry""]) == [""!apple"", ""#banana"", ""@cherry""]
    
    # Test case 4: Empty list
    assert funcImp([]) == []
    
    # Test case 5: List with one string
    assert funcImp([""single""]) == [""single""]
    
    # Test case 6: Strings with mixed case
    assert funcImp([""Banana"", ""apple"", ""Cherry""]) == [""Banana"", ""Cherry"", ""apple""]
    
    # Test case 7: Strings with spaces
    assert funcImp([""apple pie"", ""apple"", ""banana""]) == [""apple"", ""apple pie"", ""banana""]
    
    # Test case 8: Identical strings
    assert funcImp([""same"", ""same"", ""same""]) == [""same"", ""same"", ""same""]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","['same', 'same', 'same']","['same', 'same', 'same']","['same', 'same', 'same']",PASS,TRUE,
24,0,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Selection Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    for i in range(n):
        # Assume the minimum is the first element
        min_index = i
        # Test against elements after i to find the smallest
        for j in range(i+1, n):
            # If this element is less, then it is the new minimum
            if arr[j] < arr[min_index]:
                min_index = j
        # Swap the found minimum element with the first element
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]
    # Test case 2: Already sorted
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse order
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: All elements are the same
    assert funcImp([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2]
    # Test case 5: Single element
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[64, 25, 12, 22, 11]","[11, 12, 22, 25, 64]","[11, 12, 22, 25, 64]",PASS,TRUE,
24,1,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Selection Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    for i in range(n):
        # Assume the minimum is the first element
        min_index = i
        # Test against elements after i to find the smallest
        for j in range(i+1, n):
            # If this element is less, then it is the new minimum
            if arr[j] < arr[min_index]:
                min_index = j
        # Swap the found minimum element with the first element
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]
    # Test case 2: Already sorted
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse order
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: All elements are the same
    assert funcImp([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2]
    # Test case 5: Single element
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,
24,2,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Selection Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    for i in range(n):
        # Assume the minimum is the first element
        min_index = i
        # Test against elements after i to find the smallest
        for j in range(i+1, n):
            # If this element is less, then it is the new minimum
            if arr[j] < arr[min_index]:
                min_index = j
        # Swap the found minimum element with the first element
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]
    # Test case 2: Already sorted
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse order
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: All elements are the same
    assert funcImp([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2]
    # Test case 5: Single element
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[5, 4, 3, 2, 1]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,
24,3,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Selection Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    for i in range(n):
        # Assume the minimum is the first element
        min_index = i
        # Test against elements after i to find the smallest
        for j in range(i+1, n):
            # If this element is less, then it is the new minimum
            if arr[j] < arr[min_index]:
                min_index = j
        # Swap the found minimum element with the first element
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]
    # Test case 2: Already sorted
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse order
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: All elements are the same
    assert funcImp([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2]
    # Test case 5: Single element
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[2, 2, 2, 2, 2]","[2, 2, 2, 2, 2]","[2, 2, 2, 2, 2]",PASS,TRUE,
24,4,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Selection Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    for i in range(n):
        # Assume the minimum is the first element
        min_index = i
        # Test against elements after i to find the smallest
        for j in range(i+1, n):
            # If this element is less, then it is the new minimum
            if arr[j] < arr[min_index]:
                min_index = j
        # Swap the found minimum element with the first element
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]
    # Test case 2: Already sorted
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse order
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: All elements are the same
    assert funcImp([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2]
    # Test case 5: Single element
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[1],[1],[1],PASS,TRUE,
24,5,medium,Sorting algorithms,Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Selection Sort algorithm and discuss its advantages and disadvantages compared to other sorting algorithms.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Implements the Selection Sort algorithm to sort an array in ascending order.
    
    Parameters:
    arr (list): A list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    n = len(arr)
    for i in range(n):
        # Assume the minimum is the first element
        min_index = i
        # Test against elements after i to find the smallest
        for j in range(i+1, n):
            # If this element is less, then it is the new minimum
            if arr[j] < arr[min_index]:
                min_index = j
        # Swap the found minimum element with the first element
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]
    # Test case 2: Already sorted
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    # Test case 3: Reverse order
    assert funcImp([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    # Test case 4: All elements are the same
    assert funcImp([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2]
    # Test case 5: Single element
    assert funcImp([1]) == [1]
    # Test case 6: Empty list
    assert funcImp([]) == []
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],[],[],PASS,TRUE,
25,0,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def funcImp(head):
    """"""
    Sorts a linked list using the Merge Sort algorithm.
    
    :param head: ListNode, the head of the linked list to be sorted
    :return: ListNode, the head of the sorted linked list
    """"""
    # Base case: if the list is empty or has only one element, it's already sorted
    if not head or not head.next:
        return head

    # Function to split the linked list into two halves
    def split(head):
        slow = head
        fast = head
        prev = None
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        prev.next = None
        return head, slow

    # Function to merge two sorted linked lists
    def merge(l1, l2):
        dummy = ListNode()
        tail = dummy
        while l1 and l2:
            if l1.value < l2.value:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next

    # Split the list into two halves
    left, right = split(head)

    # Recursively sort each half
    left = funcImp(left)
    right = funcImp(right)

    # Merge the sorted halves
    return merge(left, right)

# Helper function to create a linked list from a list
def create_linked_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for value in arr[1:]:
        current.next = ListNode(value)
        current = current.next
    return head

# Helper function to convert a linked list to a list
def linked_list_to_list(head):
    result = []
    current = head
    while current:
        result.append(current.value)
        current = current.next
    return result

# Test cases
def test_funcImp():
    # Test case 1: Normal case
    head = create_linked_list([4, 2, 1, 3])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 1 failed""

    # Test case 2: Already sorted list
    head = create_linked_list([1, 2, 3, 4])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 2 failed""

    # Test case 3: Reverse sorted list
    head = create_linked_list([4, 3, 2, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 3 failed""

    # Test case 4: List with duplicates
    head = create_linked_list([4, 2, 2, 3, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 2, 3, 4], ""Test case 4 failed""

    # Test case 5: Single element list
    head = create_linked_list([1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1], ""Test case 5 failed""

    # Test case 6: Empty list
    head = create_linked_list([])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [], ""Test case 6 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[4, 2, 1, 3]","[1, 2, 3, 4]","[1, 2, 3, 4]",PASS,TRUE,
25,1,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def funcImp(head):
    """"""
    Sorts a linked list using the Merge Sort algorithm.
    
    :param head: ListNode, the head of the linked list to be sorted
    :return: ListNode, the head of the sorted linked list
    """"""
    # Base case: if the list is empty or has only one element, it's already sorted
    if not head or not head.next:
        return head

    # Function to split the linked list into two halves
    def split(head):
        slow = head
        fast = head
        prev = None
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        prev.next = None
        return head, slow

    # Function to merge two sorted linked lists
    def merge(l1, l2):
        dummy = ListNode()
        tail = dummy
        while l1 and l2:
            if l1.value < l2.value:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next

    # Split the list into two halves
    left, right = split(head)

    # Recursively sort each half
    left = funcImp(left)
    right = funcImp(right)

    # Merge the sorted halves
    return merge(left, right)

# Helper function to create a linked list from a list
def create_linked_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for value in arr[1:]:
        current.next = ListNode(value)
        current = current.next
    return head

# Helper function to convert a linked list to a list
def linked_list_to_list(head):
    result = []
    current = head
    while current:
        result.append(current.value)
        current = current.next
    return result

# Test cases
def test_funcImp():
    # Test case 1: Normal case
    head = create_linked_list([4, 2, 1, 3])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 1 failed""

    # Test case 2: Already sorted list
    head = create_linked_list([1, 2, 3, 4])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 2 failed""

    # Test case 3: Reverse sorted list
    head = create_linked_list([4, 3, 2, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 3 failed""

    # Test case 4: List with duplicates
    head = create_linked_list([4, 2, 2, 3, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 2, 3, 4], ""Test case 4 failed""

    # Test case 5: Single element list
    head = create_linked_list([1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1], ""Test case 5 failed""

    # Test case 6: Empty list
    head = create_linked_list([])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [], ""Test case 6 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4]","[1, 2, 3, 4]","[1, 2, 3, 4]",PASS,TRUE,
25,2,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def funcImp(head):
    """"""
    Sorts a linked list using the Merge Sort algorithm.
    
    :param head: ListNode, the head of the linked list to be sorted
    :return: ListNode, the head of the sorted linked list
    """"""
    # Base case: if the list is empty or has only one element, it's already sorted
    if not head or not head.next:
        return head

    # Function to split the linked list into two halves
    def split(head):
        slow = head
        fast = head
        prev = None
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        prev.next = None
        return head, slow

    # Function to merge two sorted linked lists
    def merge(l1, l2):
        dummy = ListNode()
        tail = dummy
        while l1 and l2:
            if l1.value < l2.value:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next

    # Split the list into two halves
    left, right = split(head)

    # Recursively sort each half
    left = funcImp(left)
    right = funcImp(right)

    # Merge the sorted halves
    return merge(left, right)

# Helper function to create a linked list from a list
def create_linked_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for value in arr[1:]:
        current.next = ListNode(value)
        current = current.next
    return head

# Helper function to convert a linked list to a list
def linked_list_to_list(head):
    result = []
    current = head
    while current:
        result.append(current.value)
        current = current.next
    return result

# Test cases
def test_funcImp():
    # Test case 1: Normal case
    head = create_linked_list([4, 2, 1, 3])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 1 failed""

    # Test case 2: Already sorted list
    head = create_linked_list([1, 2, 3, 4])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 2 failed""

    # Test case 3: Reverse sorted list
    head = create_linked_list([4, 3, 2, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 3 failed""

    # Test case 4: List with duplicates
    head = create_linked_list([4, 2, 2, 3, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 2, 3, 4], ""Test case 4 failed""

    # Test case 5: Single element list
    head = create_linked_list([1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1], ""Test case 5 failed""

    # Test case 6: Empty list
    head = create_linked_list([])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [], ""Test case 6 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[4, 3, 2, 1]","[1, 2, 3, 4]","[1, 2, 3, 4]",PASS,TRUE,
25,3,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def funcImp(head):
    """"""
    Sorts a linked list using the Merge Sort algorithm.
    
    :param head: ListNode, the head of the linked list to be sorted
    :return: ListNode, the head of the sorted linked list
    """"""
    # Base case: if the list is empty or has only one element, it's already sorted
    if not head or not head.next:
        return head

    # Function to split the linked list into two halves
    def split(head):
        slow = head
        fast = head
        prev = None
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        prev.next = None
        return head, slow

    # Function to merge two sorted linked lists
    def merge(l1, l2):
        dummy = ListNode()
        tail = dummy
        while l1 and l2:
            if l1.value < l2.value:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next

    # Split the list into two halves
    left, right = split(head)

    # Recursively sort each half
    left = funcImp(left)
    right = funcImp(right)

    # Merge the sorted halves
    return merge(left, right)

# Helper function to create a linked list from a list
def create_linked_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for value in arr[1:]:
        current.next = ListNode(value)
        current = current.next
    return head

# Helper function to convert a linked list to a list
def linked_list_to_list(head):
    result = []
    current = head
    while current:
        result.append(current.value)
        current = current.next
    return result

# Test cases
def test_funcImp():
    # Test case 1: Normal case
    head = create_linked_list([4, 2, 1, 3])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 1 failed""

    # Test case 2: Already sorted list
    head = create_linked_list([1, 2, 3, 4])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 2 failed""

    # Test case 3: Reverse sorted list
    head = create_linked_list([4, 3, 2, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 3 failed""

    # Test case 4: List with duplicates
    head = create_linked_list([4, 2, 2, 3, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 2, 3, 4], ""Test case 4 failed""

    # Test case 5: Single element list
    head = create_linked_list([1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1], ""Test case 5 failed""

    # Test case 6: Empty list
    head = create_linked_list([])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [], ""Test case 6 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[4, 2, 2, 3, 1]","[1, 2, 2, 3, 4]","[1, 2, 2, 3, 4]",PASS,TRUE,
25,4,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def funcImp(head):
    """"""
    Sorts a linked list using the Merge Sort algorithm.
    
    :param head: ListNode, the head of the linked list to be sorted
    :return: ListNode, the head of the sorted linked list
    """"""
    # Base case: if the list is empty or has only one element, it's already sorted
    if not head or not head.next:
        return head

    # Function to split the linked list into two halves
    def split(head):
        slow = head
        fast = head
        prev = None
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        prev.next = None
        return head, slow

    # Function to merge two sorted linked lists
    def merge(l1, l2):
        dummy = ListNode()
        tail = dummy
        while l1 and l2:
            if l1.value < l2.value:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next

    # Split the list into two halves
    left, right = split(head)

    # Recursively sort each half
    left = funcImp(left)
    right = funcImp(right)

    # Merge the sorted halves
    return merge(left, right)

# Helper function to create a linked list from a list
def create_linked_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for value in arr[1:]:
        current.next = ListNode(value)
        current = current.next
    return head

# Helper function to convert a linked list to a list
def linked_list_to_list(head):
    result = []
    current = head
    while current:
        result.append(current.value)
        current = current.next
    return result

# Test cases
def test_funcImp():
    # Test case 1: Normal case
    head = create_linked_list([4, 2, 1, 3])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 1 failed""

    # Test case 2: Already sorted list
    head = create_linked_list([1, 2, 3, 4])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 2 failed""

    # Test case 3: Reverse sorted list
    head = create_linked_list([4, 3, 2, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 3 failed""

    # Test case 4: List with duplicates
    head = create_linked_list([4, 2, 2, 3, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 2, 3, 4], ""Test case 4 failed""

    # Test case 5: Single element list
    head = create_linked_list([1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1], ""Test case 5 failed""

    # Test case 6: Empty list
    head = create_linked_list([])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [], ""Test case 6 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[1],[1],[1],PASS,TRUE,
25,5,medium,Sorting algorithms,Develop an algorithm to sort a linked list using the Merge Sort technique.,"## Problem Statement
- Develop a Python script to solve the problem: 'Develop an algorithm to sort a linked list using the Merge Sort technique.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def funcImp(head):
    """"""
    Sorts a linked list using the Merge Sort algorithm.
    
    :param head: ListNode, the head of the linked list to be sorted
    :return: ListNode, the head of the sorted linked list
    """"""
    # Base case: if the list is empty or has only one element, it's already sorted
    if not head or not head.next:
        return head

    # Function to split the linked list into two halves
    def split(head):
        slow = head
        fast = head
        prev = None
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        prev.next = None
        return head, slow

    # Function to merge two sorted linked lists
    def merge(l1, l2):
        dummy = ListNode()
        tail = dummy
        while l1 and l2:
            if l1.value < l2.value:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next

    # Split the list into two halves
    left, right = split(head)

    # Recursively sort each half
    left = funcImp(left)
    right = funcImp(right)

    # Merge the sorted halves
    return merge(left, right)

# Helper function to create a linked list from a list
def create_linked_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for value in arr[1:]:
        current.next = ListNode(value)
        current = current.next
    return head

# Helper function to convert a linked list to a list
def linked_list_to_list(head):
    result = []
    current = head
    while current:
        result.append(current.value)
        current = current.next
    return result

# Test cases
def test_funcImp():
    # Test case 1: Normal case
    head = create_linked_list([4, 2, 1, 3])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 1 failed""

    # Test case 2: Already sorted list
    head = create_linked_list([1, 2, 3, 4])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 2 failed""

    # Test case 3: Reverse sorted list
    head = create_linked_list([4, 3, 2, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 3, 4], ""Test case 3 failed""

    # Test case 4: List with duplicates
    head = create_linked_list([4, 2, 2, 3, 1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1, 2, 2, 3, 4], ""Test case 4 failed""

    # Test case 5: Single element list
    head = create_linked_list([1])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [1], ""Test case 5 failed""

    # Test case 6: Empty list
    head = create_linked_list([])
    sorted_head = funcImp(head)
    assert linked_list_to_list(sorted_head) == [], ""Test case 6 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],[],[],PASS,TRUE,
26,0,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list with the integers sorted in ascending order.
    """"""
    def counting_sort(arr, exp):
        n = len(arr)
        output = [0] * n
        count = [0] * 10

        # Store count of occurrences in count[]
        for i in range(n):
            index = arr[i] // exp
            count[index % 10] += 1

        # Change count[i] so that it contains the actual position of this digit in output[]
        for i in range(1, 10):
            count[i] += count[i - 1]

        # Build the output array
        i = n - 1
        while i >= 0:
            index = arr[i] // exp
            output[count[index % 10] - 1] = arr[i]
            count[index % 10] -= 1
            i -= 1

        # Copy the output array to arr[], so that arr now contains sorted numbers
        for i in range(n):
            arr[i] = output[i]

    # Find the maximum number to know the number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead of passing digit number,
    # exp is passed. exp is 10^i where i is the current digit number
    exp = 1
    while max1 // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: Array with duplicate elements
    assert funcImp([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3]
    
    # Test case 4: Array with single element
    assert funcImp([42]) == [42]
    
    # Test case 5: Array with two elements
    assert funcImp([20, 10]) == [10, 20]
    
    # Test case 6: Array with large numbers
    assert funcImp([123456789, 987654321, 12345678, 87654321]) == [12345678, 87654321, 123456789, 987654321]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[170, 45, 75, 90, 802, 24, 2, 66]","[2, 24, 45, 66, 75, 90, 170, 802]","[2, 24, 45, 66, 75, 90, 170, 802]",PASS,TRUE,
26,1,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list with the integers sorted in ascending order.
    """"""
    def counting_sort(arr, exp):
        n = len(arr)
        output = [0] * n
        count = [0] * 10

        # Store count of occurrences in count[]
        for i in range(n):
            index = arr[i] // exp
            count[index % 10] += 1

        # Change count[i] so that it contains the actual position of this digit in output[]
        for i in range(1, 10):
            count[i] += count[i - 1]

        # Build the output array
        i = n - 1
        while i >= 0:
            index = arr[i] // exp
            output[count[index % 10] - 1] = arr[i]
            count[index % 10] -= 1
            i -= 1

        # Copy the output array to arr[], so that arr now contains sorted numbers
        for i in range(n):
            arr[i] = output[i]

    # Find the maximum number to know the number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead of passing digit number,
    # exp is passed. exp is 10^i where i is the current digit number
    exp = 1
    while max1 // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: Array with duplicate elements
    assert funcImp([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3]
    
    # Test case 4: Array with single element
    assert funcImp([42]) == [42]
    
    # Test case 5: Array with two elements
    assert funcImp([20, 10]) == [10, 20]
    
    # Test case 6: Array with large numbers
    assert funcImp([123456789, 987654321, 12345678, 87654321]) == [12345678, 87654321, 123456789, 987654321]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,
26,2,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list with the integers sorted in ascending order.
    """"""
    def counting_sort(arr, exp):
        n = len(arr)
        output = [0] * n
        count = [0] * 10

        # Store count of occurrences in count[]
        for i in range(n):
            index = arr[i] // exp
            count[index % 10] += 1

        # Change count[i] so that it contains the actual position of this digit in output[]
        for i in range(1, 10):
            count[i] += count[i - 1]

        # Build the output array
        i = n - 1
        while i >= 0:
            index = arr[i] // exp
            output[count[index % 10] - 1] = arr[i]
            count[index % 10] -= 1
            i -= 1

        # Copy the output array to arr[], so that arr now contains sorted numbers
        for i in range(n):
            arr[i] = output[i]

    # Find the maximum number to know the number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead of passing digit number,
    # exp is passed. exp is 10^i where i is the current digit number
    exp = 1
    while max1 // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: Array with duplicate elements
    assert funcImp([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3]
    
    # Test case 4: Array with single element
    assert funcImp([42]) == [42]
    
    # Test case 5: Array with two elements
    assert funcImp([20, 10]) == [10, 20]
    
    # Test case 6: Array with large numbers
    assert funcImp([123456789, 987654321, 12345678, 87654321]) == [12345678, 87654321, 123456789, 987654321]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[3, 3, 3, 3, 3]","[3, 3, 3, 3, 3]","[3, 3, 3, 3, 3]",PASS,TRUE,
26,3,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list with the integers sorted in ascending order.
    """"""
    def counting_sort(arr, exp):
        n = len(arr)
        output = [0] * n
        count = [0] * 10

        # Store count of occurrences in count[]
        for i in range(n):
            index = arr[i] // exp
            count[index % 10] += 1

        # Change count[i] so that it contains the actual position of this digit in output[]
        for i in range(1, 10):
            count[i] += count[i - 1]

        # Build the output array
        i = n - 1
        while i >= 0:
            index = arr[i] // exp
            output[count[index % 10] - 1] = arr[i]
            count[index % 10] -= 1
            i -= 1

        # Copy the output array to arr[], so that arr now contains sorted numbers
        for i in range(n):
            arr[i] = output[i]

    # Find the maximum number to know the number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead of passing digit number,
    # exp is passed. exp is 10^i where i is the current digit number
    exp = 1
    while max1 // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: Array with duplicate elements
    assert funcImp([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3]
    
    # Test case 4: Array with single element
    assert funcImp([42]) == [42]
    
    # Test case 5: Array with two elements
    assert funcImp([20, 10]) == [10, 20]
    
    # Test case 6: Array with large numbers
    assert funcImp([123456789, 987654321, 12345678, 87654321]) == [12345678, 87654321, 123456789, 987654321]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[42],[42],[42],PASS,TRUE,
26,4,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list with the integers sorted in ascending order.
    """"""
    def counting_sort(arr, exp):
        n = len(arr)
        output = [0] * n
        count = [0] * 10

        # Store count of occurrences in count[]
        for i in range(n):
            index = arr[i] // exp
            count[index % 10] += 1

        # Change count[i] so that it contains the actual position of this digit in output[]
        for i in range(1, 10):
            count[i] += count[i - 1]

        # Build the output array
        i = n - 1
        while i >= 0:
            index = arr[i] // exp
            output[count[index % 10] - 1] = arr[i]
            count[index % 10] -= 1
            i -= 1

        # Copy the output array to arr[], so that arr now contains sorted numbers
        for i in range(n):
            arr[i] = output[i]

    # Find the maximum number to know the number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead of passing digit number,
    # exp is passed. exp is 10^i where i is the current digit number
    exp = 1
    while max1 // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: Array with duplicate elements
    assert funcImp([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3]
    
    # Test case 4: Array with single element
    assert funcImp([42]) == [42]
    
    # Test case 5: Array with two elements
    assert funcImp([20, 10]) == [10, 20]
    
    # Test case 6: Array with large numbers
    assert funcImp([123456789, 987654321, 12345678, 87654321]) == [12345678, 87654321, 123456789, 987654321]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[20, 10]","[10, 20]","[10, 20]",PASS,TRUE,
26,5,medium,Sorting algorithms,Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.,"## Problem Statement
- Develop a Python script to solve the problem: 'Write a program to implement the Radix Sort algorithm for sorting positive integers in ascending order.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Radix Sort on a list of positive integers.
    
    Parameters:
    arr (list): A list of positive integers to be sorted.
    
    Returns:
    list: A new list with the integers sorted in ascending order.
    """"""
    def counting_sort(arr, exp):
        n = len(arr)
        output = [0] * n
        count = [0] * 10

        # Store count of occurrences in count[]
        for i in range(n):
            index = arr[i] // exp
            count[index % 10] += 1

        # Change count[i] so that it contains the actual position of this digit in output[]
        for i in range(1, 10):
            count[i] += count[i - 1]

        # Build the output array
        i = n - 1
        while i >= 0:
            index = arr[i] // exp
            output[count[index % 10] - 1] = arr[i]
            count[index % 10] -= 1
            i -= 1

        # Copy the output array to arr[], so that arr now contains sorted numbers
        for i in range(n):
            arr[i] = output[i]

    # Find the maximum number to know the number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead of passing digit number,
    # exp is passed. exp is 10^i where i is the current digit number
    exp = 1
    while max1 // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

    return arr

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Normal case
    assert funcImp([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802]
    
    # Test case 2: Already sorted array
    assert funcImp([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    
    # Test case 3: Array with duplicate elements
    assert funcImp([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3]
    
    # Test case 4: Array with single element
    assert funcImp([42]) == [42]
    
    # Test case 5: Array with two elements
    assert funcImp([20, 10]) == [10, 20]
    
    # Test case 6: Array with large numbers
    assert funcImp([123456789, 987654321, 12345678, 87654321]) == [12345678, 87654321, 123456789, 987654321]
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[123456789, 987654321, 12345678, 87654321]","[12345678, 87654321, 123456789, 987654321]","[12345678, 87654321, 123456789, 987654321]",PASS,TRUE,
27,0,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using the Counting Sort algorithm.
    
    Parameters:
    arr (list of int): The array to be sorted.
    
    Returns:
    list of int: The sorted array.
    """"""
    if not arr:
        return arr
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Initialize the count array
    range_of_elements = max_val - min_val + 1
    count = [0] * range_of_elements
    
    # Store the count of each element
    for num in arr:
        count[num - min_val] += 1
    
    # Modify the count array by adding the previous counts
    for i in range(1, range_of_elements):
        count[i] += count[i - 1]
    
    # Build the output sorted array
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    
    return output

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Normal case with duplicates
    arr1 = [4, 2, 2, 8, 3, 3, 1]
    assert funcImp(arr1) == [1, 2, 2, 3, 3, 4, 8], ""Test case 1 failed""
    
    # Test case 2: Array with all identical elements
    arr2 = [5, 5, 5, 5, 5]
    assert funcImp(arr2) == [5, 5, 5, 5, 5], ""Test case 2 failed""
    
    # Test case 3: Array with negative numbers
    arr3 = [-5, -1, -3, -2, -4, -1]
    assert funcImp(arr3) == [-5, -4, -3, -2, -1, -1], ""Test case 3 failed""
    
    # Test case 4: Empty array
    arr4 = []
    assert funcImp(arr4) == [], ""Test case 4 failed""
    
    # Test case 5: Array with one element
    arr5 = [10]
    assert funcImp(arr5) == [10], ""Test case 5 failed""
    
    # Test case 6: Array with a large range of numbers
    arr6 = [100, 200, 300, 100, 200, 100]
    assert funcImp(arr6) == [100, 100, 100, 200, 200, 300], ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[4, 2, 2, 8, 3, 3, 1]","[1, 2, 2, 3, 3, 4, 8]","[1, 2, 2, 3, 3, 4, 8]",PASS,TRUE,None
27,1,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using the Counting Sort algorithm.
    
    Parameters:
    arr (list of int): The array to be sorted.
    
    Returns:
    list of int: The sorted array.
    """"""
    if not arr:
        return arr
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Initialize the count array
    range_of_elements = max_val - min_val + 1
    count = [0] * range_of_elements
    
    # Store the count of each element
    for num in arr:
        count[num - min_val] += 1
    
    # Modify the count array by adding the previous counts
    for i in range(1, range_of_elements):
        count[i] += count[i - 1]
    
    # Build the output sorted array
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    
    return output

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Normal case with duplicates
    arr1 = [4, 2, 2, 8, 3, 3, 1]
    assert funcImp(arr1) == [1, 2, 2, 3, 3, 4, 8], ""Test case 1 failed""
    
    # Test case 2: Array with all identical elements
    arr2 = [5, 5, 5, 5, 5]
    assert funcImp(arr2) == [5, 5, 5, 5, 5], ""Test case 2 failed""
    
    # Test case 3: Array with negative numbers
    arr3 = [-5, -1, -3, -2, -4, -1]
    assert funcImp(arr3) == [-5, -4, -3, -2, -1, -1], ""Test case 3 failed""
    
    # Test case 4: Empty array
    arr4 = []
    assert funcImp(arr4) == [], ""Test case 4 failed""
    
    # Test case 5: Array with one element
    arr5 = [10]
    assert funcImp(arr5) == [10], ""Test case 5 failed""
    
    # Test case 6: Array with a large range of numbers
    arr6 = [100, 200, 300, 100, 200, 100]
    assert funcImp(arr6) == [100, 100, 100, 200, 200, 300], ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[5, 5, 5, 5, 5]","[5, 5, 5, 5, 5]","[5, 5, 5, 5, 5]",PASS,TRUE,None
27,2,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using the Counting Sort algorithm.
    
    Parameters:
    arr (list of int): The array to be sorted.
    
    Returns:
    list of int: The sorted array.
    """"""
    if not arr:
        return arr
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Initialize the count array
    range_of_elements = max_val - min_val + 1
    count = [0] * range_of_elements
    
    # Store the count of each element
    for num in arr:
        count[num - min_val] += 1
    
    # Modify the count array by adding the previous counts
    for i in range(1, range_of_elements):
        count[i] += count[i - 1]
    
    # Build the output sorted array
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    
    return output

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Normal case with duplicates
    arr1 = [4, 2, 2, 8, 3, 3, 1]
    assert funcImp(arr1) == [1, 2, 2, 3, 3, 4, 8], ""Test case 1 failed""
    
    # Test case 2: Array with all identical elements
    arr2 = [5, 5, 5, 5, 5]
    assert funcImp(arr2) == [5, 5, 5, 5, 5], ""Test case 2 failed""
    
    # Test case 3: Array with negative numbers
    arr3 = [-5, -1, -3, -2, -4, -1]
    assert funcImp(arr3) == [-5, -4, -3, -2, -1, -1], ""Test case 3 failed""
    
    # Test case 4: Empty array
    arr4 = []
    assert funcImp(arr4) == [], ""Test case 4 failed""
    
    # Test case 5: Array with one element
    arr5 = [10]
    assert funcImp(arr5) == [10], ""Test case 5 failed""
    
    # Test case 6: Array with a large range of numbers
    arr6 = [100, 200, 300, 100, 200, 100]
    assert funcImp(arr6) == [100, 100, 100, 200, 200, 300], ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[-5, -1, -3, -2, -4, -1]","[-5, -4, -3, -2, -1, -1]","[-5, -4, -3, -2, -1, -1]",PASS,TRUE,None
27,3,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using the Counting Sort algorithm.
    
    Parameters:
    arr (list of int): The array to be sorted.
    
    Returns:
    list of int: The sorted array.
    """"""
    if not arr:
        return arr
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Initialize the count array
    range_of_elements = max_val - min_val + 1
    count = [0] * range_of_elements
    
    # Store the count of each element
    for num in arr:
        count[num - min_val] += 1
    
    # Modify the count array by adding the previous counts
    for i in range(1, range_of_elements):
        count[i] += count[i - 1]
    
    # Build the output sorted array
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    
    return output

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Normal case with duplicates
    arr1 = [4, 2, 2, 8, 3, 3, 1]
    assert funcImp(arr1) == [1, 2, 2, 3, 3, 4, 8], ""Test case 1 failed""
    
    # Test case 2: Array with all identical elements
    arr2 = [5, 5, 5, 5, 5]
    assert funcImp(arr2) == [5, 5, 5, 5, 5], ""Test case 2 failed""
    
    # Test case 3: Array with negative numbers
    arr3 = [-5, -1, -3, -2, -4, -1]
    assert funcImp(arr3) == [-5, -4, -3, -2, -1, -1], ""Test case 3 failed""
    
    # Test case 4: Empty array
    arr4 = []
    assert funcImp(arr4) == [], ""Test case 4 failed""
    
    # Test case 5: Array with one element
    arr5 = [10]
    assert funcImp(arr5) == [10], ""Test case 5 failed""
    
    # Test case 6: Array with a large range of numbers
    arr6 = [100, 200, 300, 100, 200, 100]
    assert funcImp(arr6) == [100, 100, 100, 200, 200, 300], ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[],[],[],PASS,TRUE,None
27,4,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using the Counting Sort algorithm.
    
    Parameters:
    arr (list of int): The array to be sorted.
    
    Returns:
    list of int: The sorted array.
    """"""
    if not arr:
        return arr
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Initialize the count array
    range_of_elements = max_val - min_val + 1
    count = [0] * range_of_elements
    
    # Store the count of each element
    for num in arr:
        count[num - min_val] += 1
    
    # Modify the count array by adding the previous counts
    for i in range(1, range_of_elements):
        count[i] += count[i - 1]
    
    # Build the output sorted array
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    
    return output

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Normal case with duplicates
    arr1 = [4, 2, 2, 8, 3, 3, 1]
    assert funcImp(arr1) == [1, 2, 2, 3, 3, 4, 8], ""Test case 1 failed""
    
    # Test case 2: Array with all identical elements
    arr2 = [5, 5, 5, 5, 5]
    assert funcImp(arr2) == [5, 5, 5, 5, 5], ""Test case 2 failed""
    
    # Test case 3: Array with negative numbers
    arr3 = [-5, -1, -3, -2, -4, -1]
    assert funcImp(arr3) == [-5, -4, -3, -2, -1, -1], ""Test case 3 failed""
    
    # Test case 4: Empty array
    arr4 = []
    assert funcImp(arr4) == [], ""Test case 4 failed""
    
    # Test case 5: Array with one element
    arr5 = [10]
    assert funcImp(arr5) == [10], ""Test case 5 failed""
    
    # Test case 6: Array with a large range of numbers
    arr6 = [100, 200, 300, 100, 200, 100]
    assert funcImp(arr6) == [100, 100, 100, 200, 200, 300], ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```",[10],[10],[10],PASS,TRUE,None
27,5,medium,Sorting algorithms,"Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.","## Problem Statement
- Develop a Python script to solve the problem: 'Design an efficient algorithm to sort an array with many duplicate elements, such as counting sort or bucket sort.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Sorts an array with many duplicate elements using the Counting Sort algorithm.
    
    Parameters:
    arr (list of int): The array to be sorted.
    
    Returns:
    list of int: The sorted array.
    """"""
    if not arr:
        return arr
    
    # Find the maximum and minimum values in the array
    max_val = max(arr)
    min_val = min(arr)
    
    # Initialize the count array
    range_of_elements = max_val - min_val + 1
    count = [0] * range_of_elements
    
    # Store the count of each element
    for num in arr:
        count[num - min_val] += 1
    
    # Modify the count array by adding the previous counts
    for i in range(1, range_of_elements):
        count[i] += count[i - 1]
    
    # Build the output sorted array
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    
    return output

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Normal case with duplicates
    arr1 = [4, 2, 2, 8, 3, 3, 1]
    assert funcImp(arr1) == [1, 2, 2, 3, 3, 4, 8], ""Test case 1 failed""
    
    # Test case 2: Array with all identical elements
    arr2 = [5, 5, 5, 5, 5]
    assert funcImp(arr2) == [5, 5, 5, 5, 5], ""Test case 2 failed""
    
    # Test case 3: Array with negative numbers
    arr3 = [-5, -1, -3, -2, -4, -1]
    assert funcImp(arr3) == [-5, -4, -3, -2, -1, -1], ""Test case 3 failed""
    
    # Test case 4: Empty array
    arr4 = []
    assert funcImp(arr4) == [], ""Test case 4 failed""
    
    # Test case 5: Array with one element
    arr5 = [10]
    assert funcImp(arr5) == [10], ""Test case 5 failed""
    
    # Test case 6: Array with a large range of numbers
    arr6 = [100, 200, 300, 100, 200, 100]
    assert funcImp(arr6) == [100, 100, 100, 200, 200, 300], ""Test case 6 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","[100, 200, 300, 100, 200, 100]","[100, 100, 100, 200, 200, 300]","[100, 100, 100, 200, 200, 300]",PASS,TRUE,None
28,0,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Heap Sort on a list.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    def heapify(arr, n, i):
        # Find largest among root and children
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and arr[i] < arr[left]:
            largest = left

        if right < n and arr[largest] < arr[right]:
            largest = right

        # Swap and continue heapifying if root is not largest
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

    def heap_sort(arr):
        n = len(arr)

        # Build max heap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)

        # Extract elements
        for i in range(n - 1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]  # swap
            heapify(arr, i, 0)

    # Call the heap_sort function
    heap_sort(arr)
    return arr

# Test cases to verify the implementation
if __name__ == ""__main__"":
    # Test case 1: Random order
    print(funcImp([4, 10, 3, 5, 1]))  # Expected output: [1, 3, 4, 5, 10]

    # Test case 2: Already sorted
    print(funcImp([1, 2, 3, 4, 5]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 3: Reverse order
    print(funcImp([5, 4, 3, 2, 1]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 4: All elements are the same
    print(funcImp([2, 2, 2, 2, 2]))  # Expected output: [2, 2, 2, 2, 2]

    # Test case 5: Single element
    print(funcImp([1]))  # Expected output: [1]

    # Test case 6: Empty list
    print(funcImp([]))  # Expected output: []
```","[4, 10, 3, 5, 1]","[1, 3, 4, 5, 10]","[1, 3, 4, 5, 10]",PASS,TRUE,
28,1,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Heap Sort on a list.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    def heapify(arr, n, i):
        # Find largest among root and children
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and arr[i] < arr[left]:
            largest = left

        if right < n and arr[largest] < arr[right]:
            largest = right

        # Swap and continue heapifying if root is not largest
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

    def heap_sort(arr):
        n = len(arr)

        # Build max heap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)

        # Extract elements
        for i in range(n - 1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]  # swap
            heapify(arr, i, 0)

    # Call the heap_sort function
    heap_sort(arr)
    return arr

# Test cases to verify the implementation
if __name__ == ""__main__"":
    # Test case 1: Random order
    print(funcImp([4, 10, 3, 5, 1]))  # Expected output: [1, 3, 4, 5, 10]

    # Test case 2: Already sorted
    print(funcImp([1, 2, 3, 4, 5]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 3: Reverse order
    print(funcImp([5, 4, 3, 2, 1]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 4: All elements are the same
    print(funcImp([2, 2, 2, 2, 2]))  # Expected output: [2, 2, 2, 2, 2]

    # Test case 5: Single element
    print(funcImp([1]))  # Expected output: [1]

    # Test case 6: Empty list
    print(funcImp([]))  # Expected output: []
```","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,
28,2,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Heap Sort on a list.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    def heapify(arr, n, i):
        # Find largest among root and children
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and arr[i] < arr[left]:
            largest = left

        if right < n and arr[largest] < arr[right]:
            largest = right

        # Swap and continue heapifying if root is not largest
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

    def heap_sort(arr):
        n = len(arr)

        # Build max heap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)

        # Extract elements
        for i in range(n - 1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]  # swap
            heapify(arr, i, 0)

    # Call the heap_sort function
    heap_sort(arr)
    return arr

# Test cases to verify the implementation
if __name__ == ""__main__"":
    # Test case 1: Random order
    print(funcImp([4, 10, 3, 5, 1]))  # Expected output: [1, 3, 4, 5, 10]

    # Test case 2: Already sorted
    print(funcImp([1, 2, 3, 4, 5]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 3: Reverse order
    print(funcImp([5, 4, 3, 2, 1]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 4: All elements are the same
    print(funcImp([2, 2, 2, 2, 2]))  # Expected output: [2, 2, 2, 2, 2]

    # Test case 5: Single element
    print(funcImp([1]))  # Expected output: [1]

    # Test case 6: Empty list
    print(funcImp([]))  # Expected output: []
```","[5, 4, 3, 2, 1]","[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",PASS,TRUE,
28,3,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Heap Sort on a list.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    def heapify(arr, n, i):
        # Find largest among root and children
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and arr[i] < arr[left]:
            largest = left

        if right < n and arr[largest] < arr[right]:
            largest = right

        # Swap and continue heapifying if root is not largest
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

    def heap_sort(arr):
        n = len(arr)

        # Build max heap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)

        # Extract elements
        for i in range(n - 1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]  # swap
            heapify(arr, i, 0)

    # Call the heap_sort function
    heap_sort(arr)
    return arr

# Test cases to verify the implementation
if __name__ == ""__main__"":
    # Test case 1: Random order
    print(funcImp([4, 10, 3, 5, 1]))  # Expected output: [1, 3, 4, 5, 10]

    # Test case 2: Already sorted
    print(funcImp([1, 2, 3, 4, 5]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 3: Reverse order
    print(funcImp([5, 4, 3, 2, 1]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 4: All elements are the same
    print(funcImp([2, 2, 2, 2, 2]))  # Expected output: [2, 2, 2, 2, 2]

    # Test case 5: Single element
    print(funcImp([1]))  # Expected output: [1]

    # Test case 6: Empty list
    print(funcImp([]))  # Expected output: []
```","[2, 2, 2, 2, 2]","[2, 2, 2, 2, 2]","[2, 2, 2, 2, 2]",PASS,TRUE,
28,4,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Heap Sort on a list.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    def heapify(arr, n, i):
        # Find largest among root and children
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and arr[i] < arr[left]:
            largest = left

        if right < n and arr[largest] < arr[right]:
            largest = right

        # Swap and continue heapifying if root is not largest
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

    def heap_sort(arr):
        n = len(arr)

        # Build max heap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)

        # Extract elements
        for i in range(n - 1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]  # swap
            heapify(arr, i, 0)

    # Call the heap_sort function
    heap_sort(arr)
    return arr

# Test cases to verify the implementation
if __name__ == ""__main__"":
    # Test case 1: Random order
    print(funcImp([4, 10, 3, 5, 1]))  # Expected output: [1, 3, 4, 5, 10]

    # Test case 2: Already sorted
    print(funcImp([1, 2, 3, 4, 5]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 3: Reverse order
    print(funcImp([5, 4, 3, 2, 1]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 4: All elements are the same
    print(funcImp([2, 2, 2, 2, 2]))  # Expected output: [2, 2, 2, 2, 2]

    # Test case 5: Single element
    print(funcImp([1]))  # Expected output: [1]

    # Test case 6: Empty list
    print(funcImp([]))  # Expected output: []
```",[1],[1],[1],PASS,TRUE,
28,5,medium,Sorting algorithms,Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement the Heap Sort algorithm and evaluate its time complexity in both best-case and worst-case scenarios.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Function to perform Heap Sort on a list.
    
    Parameters:
    arr (list): The list of elements to be sorted.
    
    Returns:
    list: The sorted list.
    """"""
    def heapify(arr, n, i):
        # Find largest among root and children
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and arr[i] < arr[left]:
            largest = left

        if right < n and arr[largest] < arr[right]:
            largest = right

        # Swap and continue heapifying if root is not largest
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

    def heap_sort(arr):
        n = len(arr)

        # Build max heap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)

        # Extract elements
        for i in range(n - 1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]  # swap
            heapify(arr, i, 0)

    # Call the heap_sort function
    heap_sort(arr)
    return arr

# Test cases to verify the implementation
if __name__ == ""__main__"":
    # Test case 1: Random order
    print(funcImp([4, 10, 3, 5, 1]))  # Expected output: [1, 3, 4, 5, 10]

    # Test case 2: Already sorted
    print(funcImp([1, 2, 3, 4, 5]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 3: Reverse order
    print(funcImp([5, 4, 3, 2, 1]))  # Expected output: [1, 2, 3, 4, 5]

    # Test case 4: All elements are the same
    print(funcImp([2, 2, 2, 2, 2]))  # Expected output: [2, 2, 2, 2, 2]

    # Test case 5: Single element
    print(funcImp([1]))  # Expected output: [1]

    # Test case 6: Empty list
    print(funcImp([]))  # Expected output: []
```",[],[],[],PASS,TRUE,
29,0,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.

    Parameters:
    graph (dict): A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes.
    start: The starting node for the path.
    end: The ending node for the path.

    Returns:
    list: A list of nodes representing the shortest path from start to end. Returns an empty list if no path exists.
    """"""
    # If the start and end nodes are the same, return the start node in a list
    if start == end:
        return [start]
    
    # Initialize a queue for BFS and a set to keep track of visited nodes
    queue = deque([[start]])
    visited = set()

    while queue:
        # Get the first path from the queue
        path = queue.popleft()
        # Get the last node from the path
        node = path[-1]

        # If the node has not been visited
        if node not in visited:
            # Get the neighbors of the node
            neighbors = graph.get(node, [])

            # Go through all neighbor nodes, construct a new path and push it into the queue
            for neighbor in neighbors:
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)

                # Return path if neighbor is the end node
                if neighbor == end:
                    return new_path

            # Mark the node as visited
            visited.add(node)

    # Return an empty list if no path is found
    return []

# Test cases to verify the solution
def test_funcImp():
    graph = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }

    # Test case 1: Shortest path from A to F
    assert funcImp(graph, 'A', 'F') == ['A', 'C', 'F'], ""Test case 1 failed""

    # Test case 2: Shortest path from A to D
    assert funcImp(graph, 'A', 'D') == ['A', 'B', 'D'], ""Test case 2 failed""

    # Test case 3: Shortest path from A to A (same start and end)
    assert funcImp(graph, 'A', 'A') == ['A'], ""Test case 3 failed""

    # Test case 4: No path exists
    graph_no_path = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph_no_path, 'A', 'D') == [], ""Test case 4 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'F')","['A', 'C', 'F']","['A', 'C', 'F']",PASS,TRUE,
29,1,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.

    Parameters:
    graph (dict): A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes.
    start: The starting node for the path.
    end: The ending node for the path.

    Returns:
    list: A list of nodes representing the shortest path from start to end. Returns an empty list if no path exists.
    """"""
    # If the start and end nodes are the same, return the start node in a list
    if start == end:
        return [start]
    
    # Initialize a queue for BFS and a set to keep track of visited nodes
    queue = deque([[start]])
    visited = set()

    while queue:
        # Get the first path from the queue
        path = queue.popleft()
        # Get the last node from the path
        node = path[-1]

        # If the node has not been visited
        if node not in visited:
            # Get the neighbors of the node
            neighbors = graph.get(node, [])

            # Go through all neighbor nodes, construct a new path and push it into the queue
            for neighbor in neighbors:
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)

                # Return path if neighbor is the end node
                if neighbor == end:
                    return new_path

            # Mark the node as visited
            visited.add(node)

    # Return an empty list if no path is found
    return []

# Test cases to verify the solution
def test_funcImp():
    graph = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }

    # Test case 1: Shortest path from A to F
    assert funcImp(graph, 'A', 'F') == ['A', 'C', 'F'], ""Test case 1 failed""

    # Test case 2: Shortest path from A to D
    assert funcImp(graph, 'A', 'D') == ['A', 'B', 'D'], ""Test case 2 failed""

    # Test case 3: Shortest path from A to A (same start and end)
    assert funcImp(graph, 'A', 'A') == ['A'], ""Test case 3 failed""

    # Test case 4: No path exists
    graph_no_path = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph_no_path, 'A', 'D') == [], ""Test case 4 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'D')","['A', 'B', 'D']","['A', 'B', 'D']",PASS,TRUE,
29,2,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.

    Parameters:
    graph (dict): A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes.
    start: The starting node for the path.
    end: The ending node for the path.

    Returns:
    list: A list of nodes representing the shortest path from start to end. Returns an empty list if no path exists.
    """"""
    # If the start and end nodes are the same, return the start node in a list
    if start == end:
        return [start]
    
    # Initialize a queue for BFS and a set to keep track of visited nodes
    queue = deque([[start]])
    visited = set()

    while queue:
        # Get the first path from the queue
        path = queue.popleft()
        # Get the last node from the path
        node = path[-1]

        # If the node has not been visited
        if node not in visited:
            # Get the neighbors of the node
            neighbors = graph.get(node, [])

            # Go through all neighbor nodes, construct a new path and push it into the queue
            for neighbor in neighbors:
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)

                # Return path if neighbor is the end node
                if neighbor == end:
                    return new_path

            # Mark the node as visited
            visited.add(node)

    # Return an empty list if no path is found
    return []

# Test cases to verify the solution
def test_funcImp():
    graph = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }

    # Test case 1: Shortest path from A to F
    assert funcImp(graph, 'A', 'F') == ['A', 'C', 'F'], ""Test case 1 failed""

    # Test case 2: Shortest path from A to D
    assert funcImp(graph, 'A', 'D') == ['A', 'B', 'D'], ""Test case 2 failed""

    # Test case 3: Shortest path from A to A (same start and end)
    assert funcImp(graph, 'A', 'A') == ['A'], ""Test case 3 failed""

    # Test case 4: No path exists
    graph_no_path = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph_no_path, 'A', 'D') == [], ""Test case 4 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'A')",['A'],['A'],PASS,TRUE,
29,3,medium,"Graph traversal (depth-first search, breadth-first search)",Find the shortest path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the shortest path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Find the shortest path between two nodes in an undirected graph using BFS.

    Parameters:
    graph (dict): A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes.
    start: The starting node for the path.
    end: The ending node for the path.

    Returns:
    list: A list of nodes representing the shortest path from start to end. Returns an empty list if no path exists.
    """"""
    # If the start and end nodes are the same, return the start node in a list
    if start == end:
        return [start]
    
    # Initialize a queue for BFS and a set to keep track of visited nodes
    queue = deque([[start]])
    visited = set()

    while queue:
        # Get the first path from the queue
        path = queue.popleft()
        # Get the last node from the path
        node = path[-1]

        # If the node has not been visited
        if node not in visited:
            # Get the neighbors of the node
            neighbors = graph.get(node, [])

            # Go through all neighbor nodes, construct a new path and push it into the queue
            for neighbor in neighbors:
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)

                # Return path if neighbor is the end node
                if neighbor == end:
                    return new_path

            # Mark the node as visited
            visited.add(node)

    # Return an empty list if no path is found
    return []

# Test cases to verify the solution
def test_funcImp():
    graph = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }

    # Test case 1: Shortest path from A to F
    assert funcImp(graph, 'A', 'F') == ['A', 'C', 'F'], ""Test case 1 failed""

    # Test case 2: Shortest path from A to D
    assert funcImp(graph, 'A', 'D') == ['A', 'B', 'D'], ""Test case 2 failed""

    # Test case 3: Shortest path from A to A (same start and end)
    assert funcImp(graph, 'A', 'A') == ['A'], ""Test case 3 failed""

    # Test case 4: No path exists
    graph_no_path = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph_no_path, 'A', 'D') == [], ""Test case 4 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': ['B'], 'B': ['A'], 'C': ['D'], 'D': ['C']}, 'A', 'D')",[],[],PASS,TRUE,
30,0,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_vertices, edges):
    """"""
    Determine if a directed graph contains a cycle using depth-first search (DFS).

    :param num_vertices: Number of vertices in the graph.
    :param edges: List of directed edges in the graph, where each edge is represented as a tuple (u, v).
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    # Create an adjacency list from the edges
    adjacency_list = {i: [] for i in range(num_vertices)}
    for u, v in edges:
        adjacency_list[u].append(v)

    # Initialize visited and recursion stack arrays
    visited = [False] * num_vertices
    rec_stack = [False] * num_vertices

    def dfs(v):
        """"""
        Helper function to perform DFS and detect cycles.

        :param v: Current vertex to process.
        :return: True if a cycle is detected, False otherwise.
        """"""
        # Mark the current node as visited and add it to the recursion stack
        visited[v] = True
        rec_stack[v] = True

        # Recur for all neighbors
        for neighbor in adjacency_list[v]:
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif rec_stack[neighbor]:
                return True

        # Remove the vertex from recursion stack
        rec_stack[v] = False
        return False

    # Call the recursive helper function to detect cycle in different DFS trees
    for node in range(num_vertices):
        if not visited[node]:
            if dfs(node):
                return True

    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Graph with a cycle
    num_vertices1 = 4
    edges1 = [(0, 1), (1, 2), (2, 0), (2, 3)]
    assert funcImp(num_vertices1, edges1) == True, ""Test case 1 failed""

    # Test case 2: Graph without a cycle
    num_vertices2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3)]
    assert funcImp(num_vertices2, edges2) == False, ""Test case 2 failed""

    # Test case 3: Graph with a self-loop
    num_vertices3 = 3
    edges3 = [(0, 1), (1, 2), (2, 2)]
    assert funcImp(num_vertices3, edges3) == True, ""Test case 3 failed""

    # Test case 4: Empty graph
    num_vertices4 = 0
    edges4 = []
    assert funcImp(num_vertices4, edges4) == False, ""Test case 4 failed""

    # Test case 5: Single node with no edges
    num_vertices5 = 1
    edges5 = []
    assert funcImp(num_vertices5, edges5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(4, [(0, 1), (1, 2), (2, 0), (2, 3)])",TRUE,TRUE,PASS,TRUE,
30,1,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_vertices, edges):
    """"""
    Determine if a directed graph contains a cycle using depth-first search (DFS).

    :param num_vertices: Number of vertices in the graph.
    :param edges: List of directed edges in the graph, where each edge is represented as a tuple (u, v).
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    # Create an adjacency list from the edges
    adjacency_list = {i: [] for i in range(num_vertices)}
    for u, v in edges:
        adjacency_list[u].append(v)

    # Initialize visited and recursion stack arrays
    visited = [False] * num_vertices
    rec_stack = [False] * num_vertices

    def dfs(v):
        """"""
        Helper function to perform DFS and detect cycles.

        :param v: Current vertex to process.
        :return: True if a cycle is detected, False otherwise.
        """"""
        # Mark the current node as visited and add it to the recursion stack
        visited[v] = True
        rec_stack[v] = True

        # Recur for all neighbors
        for neighbor in adjacency_list[v]:
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif rec_stack[neighbor]:
                return True

        # Remove the vertex from recursion stack
        rec_stack[v] = False
        return False

    # Call the recursive helper function to detect cycle in different DFS trees
    for node in range(num_vertices):
        if not visited[node]:
            if dfs(node):
                return True

    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Graph with a cycle
    num_vertices1 = 4
    edges1 = [(0, 1), (1, 2), (2, 0), (2, 3)]
    assert funcImp(num_vertices1, edges1) == True, ""Test case 1 failed""

    # Test case 2: Graph without a cycle
    num_vertices2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3)]
    assert funcImp(num_vertices2, edges2) == False, ""Test case 2 failed""

    # Test case 3: Graph with a self-loop
    num_vertices3 = 3
    edges3 = [(0, 1), (1, 2), (2, 2)]
    assert funcImp(num_vertices3, edges3) == True, ""Test case 3 failed""

    # Test case 4: Empty graph
    num_vertices4 = 0
    edges4 = []
    assert funcImp(num_vertices4, edges4) == False, ""Test case 4 failed""

    # Test case 5: Single node with no edges
    num_vertices5 = 1
    edges5 = []
    assert funcImp(num_vertices5, edges5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(4, [(0, 1), (1, 2), (2, 3)])",FALSE,FALSE,PASS,TRUE,
30,2,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_vertices, edges):
    """"""
    Determine if a directed graph contains a cycle using depth-first search (DFS).

    :param num_vertices: Number of vertices in the graph.
    :param edges: List of directed edges in the graph, where each edge is represented as a tuple (u, v).
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    # Create an adjacency list from the edges
    adjacency_list = {i: [] for i in range(num_vertices)}
    for u, v in edges:
        adjacency_list[u].append(v)

    # Initialize visited and recursion stack arrays
    visited = [False] * num_vertices
    rec_stack = [False] * num_vertices

    def dfs(v):
        """"""
        Helper function to perform DFS and detect cycles.

        :param v: Current vertex to process.
        :return: True if a cycle is detected, False otherwise.
        """"""
        # Mark the current node as visited and add it to the recursion stack
        visited[v] = True
        rec_stack[v] = True

        # Recur for all neighbors
        for neighbor in adjacency_list[v]:
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif rec_stack[neighbor]:
                return True

        # Remove the vertex from recursion stack
        rec_stack[v] = False
        return False

    # Call the recursive helper function to detect cycle in different DFS trees
    for node in range(num_vertices):
        if not visited[node]:
            if dfs(node):
                return True

    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Graph with a cycle
    num_vertices1 = 4
    edges1 = [(0, 1), (1, 2), (2, 0), (2, 3)]
    assert funcImp(num_vertices1, edges1) == True, ""Test case 1 failed""

    # Test case 2: Graph without a cycle
    num_vertices2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3)]
    assert funcImp(num_vertices2, edges2) == False, ""Test case 2 failed""

    # Test case 3: Graph with a self-loop
    num_vertices3 = 3
    edges3 = [(0, 1), (1, 2), (2, 2)]
    assert funcImp(num_vertices3, edges3) == True, ""Test case 3 failed""

    # Test case 4: Empty graph
    num_vertices4 = 0
    edges4 = []
    assert funcImp(num_vertices4, edges4) == False, ""Test case 4 failed""

    # Test case 5: Single node with no edges
    num_vertices5 = 1
    edges5 = []
    assert funcImp(num_vertices5, edges5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(3, [(0, 1), (1, 2), (2, 2)])",TRUE,TRUE,PASS,TRUE,
30,3,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_vertices, edges):
    """"""
    Determine if a directed graph contains a cycle using depth-first search (DFS).

    :param num_vertices: Number of vertices in the graph.
    :param edges: List of directed edges in the graph, where each edge is represented as a tuple (u, v).
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    # Create an adjacency list from the edges
    adjacency_list = {i: [] for i in range(num_vertices)}
    for u, v in edges:
        adjacency_list[u].append(v)

    # Initialize visited and recursion stack arrays
    visited = [False] * num_vertices
    rec_stack = [False] * num_vertices

    def dfs(v):
        """"""
        Helper function to perform DFS and detect cycles.

        :param v: Current vertex to process.
        :return: True if a cycle is detected, False otherwise.
        """"""
        # Mark the current node as visited and add it to the recursion stack
        visited[v] = True
        rec_stack[v] = True

        # Recur for all neighbors
        for neighbor in adjacency_list[v]:
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif rec_stack[neighbor]:
                return True

        # Remove the vertex from recursion stack
        rec_stack[v] = False
        return False

    # Call the recursive helper function to detect cycle in different DFS trees
    for node in range(num_vertices):
        if not visited[node]:
            if dfs(node):
                return True

    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Graph with a cycle
    num_vertices1 = 4
    edges1 = [(0, 1), (1, 2), (2, 0), (2, 3)]
    assert funcImp(num_vertices1, edges1) == True, ""Test case 1 failed""

    # Test case 2: Graph without a cycle
    num_vertices2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3)]
    assert funcImp(num_vertices2, edges2) == False, ""Test case 2 failed""

    # Test case 3: Graph with a self-loop
    num_vertices3 = 3
    edges3 = [(0, 1), (1, 2), (2, 2)]
    assert funcImp(num_vertices3, edges3) == True, ""Test case 3 failed""

    # Test case 4: Empty graph
    num_vertices4 = 0
    edges4 = []
    assert funcImp(num_vertices4, edges4) == False, ""Test case 4 failed""

    # Test case 5: Single node with no edges
    num_vertices5 = 1
    edges5 = []
    assert funcImp(num_vertices5, edges5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(0, [])",FALSE,FALSE,PASS,TRUE,
30,4,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if a directed graph contains a cycle using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if a directed graph contains a cycle using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_vertices, edges):
    """"""
    Determine if a directed graph contains a cycle using depth-first search (DFS).

    :param num_vertices: Number of vertices in the graph.
    :param edges: List of directed edges in the graph, where each edge is represented as a tuple (u, v).
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    # Create an adjacency list from the edges
    adjacency_list = {i: [] for i in range(num_vertices)}
    for u, v in edges:
        adjacency_list[u].append(v)

    # Initialize visited and recursion stack arrays
    visited = [False] * num_vertices
    rec_stack = [False] * num_vertices

    def dfs(v):
        """"""
        Helper function to perform DFS and detect cycles.

        :param v: Current vertex to process.
        :return: True if a cycle is detected, False otherwise.
        """"""
        # Mark the current node as visited and add it to the recursion stack
        visited[v] = True
        rec_stack[v] = True

        # Recur for all neighbors
        for neighbor in adjacency_list[v]:
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif rec_stack[neighbor]:
                return True

        # Remove the vertex from recursion stack
        rec_stack[v] = False
        return False

    # Call the recursive helper function to detect cycle in different DFS trees
    for node in range(num_vertices):
        if not visited[node]:
            if dfs(node):
                return True

    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Graph with a cycle
    num_vertices1 = 4
    edges1 = [(0, 1), (1, 2), (2, 0), (2, 3)]
    assert funcImp(num_vertices1, edges1) == True, ""Test case 1 failed""

    # Test case 2: Graph without a cycle
    num_vertices2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3)]
    assert funcImp(num_vertices2, edges2) == False, ""Test case 2 failed""

    # Test case 3: Graph with a self-loop
    num_vertices3 = 3
    edges3 = [(0, 1), (1, 2), (2, 2)]
    assert funcImp(num_vertices3, edges3) == True, ""Test case 3 failed""

    # Test case 4: Empty graph
    num_vertices4 = 0
    edges4 = []
    assert funcImp(num_vertices4, edges4) == False, ""Test case 4 failed""

    # Test case 5: Single node with no edges
    num_vertices5 = 1
    edges5 = []
    assert funcImp(num_vertices5, edges5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","(1, [])",FALSE,FALSE,PASS,TRUE,
31,0,medium,"Graph traversal (depth-first search, breadth-first search)",Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.'
## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.
## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.
## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.
## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.
## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import heapq

def funcImp(graph, start):
    """"""
    Implements Dijkstra's algorithm to find the shortest path from a single source node
    to all other nodes in a weighted graph.

    Parameters:
    graph (dict): A dictionary where keys are node identifiers and values are lists of tuples
                  representing the neighbors and their respective edge weights.
    start (any): The starting node for Dijkstra's algorithm.

    Returns:
    dict: A dictionary where keys are node identifiers and values are the shortest path
          distances from the start node.
    """"""
    # Initialize the priority queue
    priority_queue = []
    # Initialize the shortest path dictionary with infinity
    shortest_paths = {node: float('inf') for node in graph}
    # Set the distance to the start node to zero
    shortest_paths[start] = 0
    # Push the start node into the priority queue
    heapq.heappush(priority_queue, (0, start))

    while priority_queue:
        # Pop the node with the smallest distance
        current_distance, current_node = heapq.heappop(priority_queue)

        # If the popped distance is greater than the recorded shortest path, skip processing
        if current_distance > shortest_paths[current_node]:
            continue

        # Explore neighbors
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight

            # If a shorter path to the neighbor is found
            if distance < shortest_paths[neighbor]:
                shortest_paths[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return shortest_paths

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Simple graph
    graph1 = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2), ('D', 5)],
        'C': [('A', 4), ('B', 2), ('D', 1)],
        'D': [('B', 5), ('C', 1)]
    }
    start1 = 'A'
    expected_output1 = {'A': 0, 'B': 1, 'C': 3, 'D': 4}
    assert funcImp(graph1, start1) == expected_output1

    # Test case 2: Graph with a single node
    graph2 = {
        'A': []
    }
    start2 = 'A'
    expected_output2 = {'A': 0}
    assert funcImp(graph2, start2) == expected_output2

    # Test case 3: Graph with disconnected nodes
    graph3 = {
        'A': [('B', 1)],
        'B': [('A', 1)],
        'C': []
    }
    start3 = 'A'
    expected_output3 = {'A': 0, 'B': 1, 'C': float('inf')}
    assert funcImp(graph3, start3) == expected_output3

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)]}, 'A')","{'A': 0, 'B': 1, 'C': 3, 'D': 4}","{'A': 0, 'B': 1, 'C': 3, 'D': 4}",PASS,TRUE,
31,1,medium,"Graph traversal (depth-first search, breadth-first search)",Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.'
## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.
## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.
## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.
## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.
## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import heapq

def funcImp(graph, start):
    """"""
    Implements Dijkstra's algorithm to find the shortest path from a single source node
    to all other nodes in a weighted graph.

    Parameters:
    graph (dict): A dictionary where keys are node identifiers and values are lists of tuples
                  representing the neighbors and their respective edge weights.
    start (any): The starting node for Dijkstra's algorithm.

    Returns:
    dict: A dictionary where keys are node identifiers and values are the shortest path
          distances from the start node.
    """"""
    # Initialize the priority queue
    priority_queue = []
    # Initialize the shortest path dictionary with infinity
    shortest_paths = {node: float('inf') for node in graph}
    # Set the distance to the start node to zero
    shortest_paths[start] = 0
    # Push the start node into the priority queue
    heapq.heappush(priority_queue, (0, start))

    while priority_queue:
        # Pop the node with the smallest distance
        current_distance, current_node = heapq.heappop(priority_queue)

        # If the popped distance is greater than the recorded shortest path, skip processing
        if current_distance > shortest_paths[current_node]:
            continue

        # Explore neighbors
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight

            # If a shorter path to the neighbor is found
            if distance < shortest_paths[neighbor]:
                shortest_paths[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return shortest_paths

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Simple graph
    graph1 = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2), ('D', 5)],
        'C': [('A', 4), ('B', 2), ('D', 1)],
        'D': [('B', 5), ('C', 1)]
    }
    start1 = 'A'
    expected_output1 = {'A': 0, 'B': 1, 'C': 3, 'D': 4}
    assert funcImp(graph1, start1) == expected_output1

    # Test case 2: Graph with a single node
    graph2 = {
        'A': []
    }
    start2 = 'A'
    expected_output2 = {'A': 0}
    assert funcImp(graph2, start2) == expected_output2

    # Test case 3: Graph with disconnected nodes
    graph3 = {
        'A': [('B', 1)],
        'B': [('A', 1)],
        'C': []
    }
    start3 = 'A'
    expected_output3 = {'A': 0, 'B': 1, 'C': float('inf')}
    assert funcImp(graph3, start3) == expected_output3

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': []}, 'A')",{'A': 0},{'A': 0},PASS,TRUE,
31,2,medium,"Graph traversal (depth-first search, breadth-first search)",Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in a weighted graph.'
## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.
## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.
## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.
## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.
## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
import heapq

def funcImp(graph, start):
    """"""
    Implements Dijkstra's algorithm to find the shortest path from a single source node
    to all other nodes in a weighted graph.

    Parameters:
    graph (dict): A dictionary where keys are node identifiers and values are lists of tuples
                  representing the neighbors and their respective edge weights.
    start (any): The starting node for Dijkstra's algorithm.

    Returns:
    dict: A dictionary where keys are node identifiers and values are the shortest path
          distances from the start node.
    """"""
    # Initialize the priority queue
    priority_queue = []
    # Initialize the shortest path dictionary with infinity
    shortest_paths = {node: float('inf') for node in graph}
    # Set the distance to the start node to zero
    shortest_paths[start] = 0
    # Push the start node into the priority queue
    heapq.heappush(priority_queue, (0, start))

    while priority_queue:
        # Pop the node with the smallest distance
        current_distance, current_node = heapq.heappop(priority_queue)

        # If the popped distance is greater than the recorded shortest path, skip processing
        if current_distance > shortest_paths[current_node]:
            continue

        # Explore neighbors
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight

            # If a shorter path to the neighbor is found
            if distance < shortest_paths[neighbor]:
                shortest_paths[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return shortest_paths

# Test cases to verify the implementation
def test_funcImp():
    # Test case 1: Simple graph
    graph1 = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2), ('D', 5)],
        'C': [('A', 4), ('B', 2), ('D', 1)],
        'D': [('B', 5), ('C', 1)]
    }
    start1 = 'A'
    expected_output1 = {'A': 0, 'B': 1, 'C': 3, 'D': 4}
    assert funcImp(graph1, start1) == expected_output1

    # Test case 2: Graph with a single node
    graph2 = {
        'A': []
    }
    start2 = 'A'
    expected_output2 = {'A': 0}
    assert funcImp(graph2, start2) == expected_output2

    # Test case 3: Graph with disconnected nodes
    graph3 = {
        'A': [('B', 1)],
        'B': [('A', 1)],
        'C': []
    }
    start3 = 'A'
    expected_output3 = {'A': 0, 'B': 1, 'C': float('inf')}
    assert funcImp(graph3, start3) == expected_output3

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': [('B', 1)], 'B': [('A', 1)], 'C': []}, 'A')","{'A': 0, 'B': 1, 'C': inf}","{'A': 0, 'B': 1, 'C': inf}",PASS,TRUE,
32,0,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Check if the given undirected graph is connected using depth-first search (DFS).
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph is connected, False otherwise.
    """"""
    # If the graph is empty, it's considered connected
    if not graph:
        return True
    
    # Start DFS from an arbitrary node (the first key in the dictionary)
    start_node = next(iter(graph))
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from the start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases
def run_tests():
    # Test case 1: A connected graph
    graph1 = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: A disconnected graph
    graph2 = {
        0: [1],
        1: [0],
        2: [3],
        3: [2]
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: A single node graph
    graph3 = {
        0: []
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: True

    # Test case 5: A graph with a single edge
    graph5 = {
        0: [1],
        1: [0]
    }
    print(funcImp(graph5))  # Expected output: True

run_tests()
```","{0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}",TRUE,TRUE,PASS,TRUE,None
32,1,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Check if the given undirected graph is connected using depth-first search (DFS).
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph is connected, False otherwise.
    """"""
    # If the graph is empty, it's considered connected
    if not graph:
        return True
    
    # Start DFS from an arbitrary node (the first key in the dictionary)
    start_node = next(iter(graph))
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from the start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases
def run_tests():
    # Test case 1: A connected graph
    graph1 = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: A disconnected graph
    graph2 = {
        0: [1],
        1: [0],
        2: [3],
        3: [2]
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: A single node graph
    graph3 = {
        0: []
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: True

    # Test case 5: A graph with a single edge
    graph5 = {
        0: [1],
        1: [0]
    }
    print(funcImp(graph5))  # Expected output: True

run_tests()
```","{0: [1], 1: [0], 2: [3], 3: [2]}",FALSE,FALSE,PASS,TRUE,None
32,2,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Check if the given undirected graph is connected using depth-first search (DFS).
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph is connected, False otherwise.
    """"""
    # If the graph is empty, it's considered connected
    if not graph:
        return True
    
    # Start DFS from an arbitrary node (the first key in the dictionary)
    start_node = next(iter(graph))
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from the start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases
def run_tests():
    # Test case 1: A connected graph
    graph1 = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: A disconnected graph
    graph2 = {
        0: [1],
        1: [0],
        2: [3],
        3: [2]
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: A single node graph
    graph3 = {
        0: []
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: True

    # Test case 5: A graph with a single edge
    graph5 = {
        0: [1],
        1: [0]
    }
    print(funcImp(graph5))  # Expected output: True

run_tests()
```",{0: []},TRUE,TRUE,PASS,TRUE,None
32,3,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Check if the given undirected graph is connected using depth-first search (DFS).
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph is connected, False otherwise.
    """"""
    # If the graph is empty, it's considered connected
    if not graph:
        return True
    
    # Start DFS from an arbitrary node (the first key in the dictionary)
    start_node = next(iter(graph))
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from the start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases
def run_tests():
    # Test case 1: A connected graph
    graph1 = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: A disconnected graph
    graph2 = {
        0: [1],
        1: [0],
        2: [3],
        3: [2]
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: A single node graph
    graph3 = {
        0: []
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: True

    # Test case 5: A graph with a single edge
    graph5 = {
        0: [1],
        1: [0]
    }
    print(funcImp(graph5))  # Expected output: True

run_tests()
```",{},TRUE,TRUE,PASS,TRUE,None
32,4,medium,"Graph traversal (depth-first search, breadth-first search)",Check if a given undirected graph is connected or not using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Check if a given undirected graph is connected or not using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Check if the given undirected graph is connected using depth-first search (DFS).
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph is connected, False otherwise.
    """"""
    # If the graph is empty, it's considered connected
    if not graph:
        return True
    
    # Start DFS from an arbitrary node (the first key in the dictionary)
    start_node = next(iter(graph))
    visited = set()
    
    def dfs(node):
        """"""Helper function to perform DFS.""""""
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    # Perform DFS starting from the start_node
    dfs(start_node)
    
    # Check if all nodes were visited
    return len(visited) == len(graph)

# Test cases
def run_tests():
    # Test case 1: A connected graph
    graph1 = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: A disconnected graph
    graph2 = {
        0: [1],
        1: [0],
        2: [3],
        3: [2]
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: A single node graph
    graph3 = {
        0: []
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: True

    # Test case 5: A graph with a single edge
    graph5 = {
        0: [1],
        1: [0]
    }
    print(funcImp(graph5))  # Expected output: True

run_tests()
```","{0: [1], 1: [0]}",TRUE,TRUE,PASS,TRUE,None
33,0,medium,"Graph traversal (depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Perform topological sorting on a directed acyclic graph using depth-first search.

    Parameters:
    graph (dict): A dictionary representing the adjacency list of the graph where
                  keys are node identifiers and values are lists of adjacent nodes.

    Returns:
    list: A list of nodes in topologically sorted order.
    """"""
    # Initialize a set to keep track of visited nodes
    visited = set()
    # Initialize a list to store the topological order
    topological_order = []

    def dfs(node):
        """"""
        Depth-first search helper function to visit nodes and record the topological order.

        Parameters:
        node: The current node being visited.
        """"""
        # Mark the current node as visited
        visited.add(node)
        # Visit all the adjacent nodes
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor)
        # Add the current node to the topological order
        topological_order.append(node)

    # Visit all nodes in the graph
    for node in graph:
        if node not in visited:
            dfs(node)

    # Reverse the topological order to get the correct order
    topological_order.reverse()
    return topological_order

# Test cases to verify the solution
if __name__ == ""__main__"":
    # Test case 1: Simple DAG
    graph1 = {
        'A': ['C'],
        'B': ['C', 'D'],
        'C': ['E'],
        'D': ['F'],
        'E': ['H', 'F'],
        'F': ['G'],
        'G': [],
        'H': []
    }
    print(funcImp(graph1))  # Expected output: A valid topological order, e.g., ['B', 'A', 'D', 'C', 'E', 'H', 'F', 'G']

    # Test case 2: Another DAG
    graph2 = {
        '5': ['11'],
        '7': ['11', '8'],
        '3': ['8', '10'],
        '11': ['2', '9', '10'],
        '8': ['9'],
        '2': [],
        '9': [],
        '10': []
    }
    print(funcImp(graph2))  # Expected output: A valid topological order, e.g., ['7', '5', '11', '3', '8', '10', '9', '2']

    # Test case 3: Single node
    graph3 = {
        'A': []
    }
    print(funcImp(graph3))  # Expected output: ['A']

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []
```","{'A': ['C'], 'B': ['C', 'D'], 'C': ['E'], 'D': ['F'], 'E': ['H', 'F'], 'F': ['G'], 'G': [], 'H': []}","['B', 'D', 'A', 'C', 'E', 'F', 'G', 'H']","['B', 'D', 'A', 'C', 'E', 'F', 'G', 'H']",PASS,TRUE,
33,1,medium,"Graph traversal (depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Perform topological sorting on a directed acyclic graph using depth-first search.

    Parameters:
    graph (dict): A dictionary representing the adjacency list of the graph where
                  keys are node identifiers and values are lists of adjacent nodes.

    Returns:
    list: A list of nodes in topologically sorted order.
    """"""
    # Initialize a set to keep track of visited nodes
    visited = set()
    # Initialize a list to store the topological order
    topological_order = []

    def dfs(node):
        """"""
        Depth-first search helper function to visit nodes and record the topological order.

        Parameters:
        node: The current node being visited.
        """"""
        # Mark the current node as visited
        visited.add(node)
        # Visit all the adjacent nodes
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor)
        # Add the current node to the topological order
        topological_order.append(node)

    # Visit all nodes in the graph
    for node in graph:
        if node not in visited:
            dfs(node)

    # Reverse the topological order to get the correct order
    topological_order.reverse()
    return topological_order

# Test cases to verify the solution
if __name__ == ""__main__"":
    # Test case 1: Simple DAG
    graph1 = {
        'A': ['C'],
        'B': ['C', 'D'],
        'C': ['E'],
        'D': ['F'],
        'E': ['H', 'F'],
        'F': ['G'],
        'G': [],
        'H': []
    }
    print(funcImp(graph1))  # Expected output: A valid topological order, e.g., ['B', 'A', 'D', 'C', 'E', 'H', 'F', 'G']

    # Test case 2: Another DAG
    graph2 = {
        '5': ['11'],
        '7': ['11', '8'],
        '3': ['8', '10'],
        '11': ['2', '9', '10'],
        '8': ['9'],
        '2': [],
        '9': [],
        '10': []
    }
    print(funcImp(graph2))  # Expected output: A valid topological order, e.g., ['7', '5', '11', '3', '8', '10', '9', '2']

    # Test case 3: Single node
    graph3 = {
        'A': []
    }
    print(funcImp(graph3))  # Expected output: ['A']

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []
```","{'5': ['11'], '7': ['11', '8'], '3': ['8', '10'], '11': ['2', '9', '10'], '8': ['9'], '2': [], '9': [], '10': []}","['3', '7', '8', '5', '11', '10', '9', '2']","['3', '7', '8', '5', '11', '10', '9', '2']",PASS,TRUE,
33,2,medium,"Graph traversal (depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Perform topological sorting on a directed acyclic graph using depth-first search.

    Parameters:
    graph (dict): A dictionary representing the adjacency list of the graph where
                  keys are node identifiers and values are lists of adjacent nodes.

    Returns:
    list: A list of nodes in topologically sorted order.
    """"""
    # Initialize a set to keep track of visited nodes
    visited = set()
    # Initialize a list to store the topological order
    topological_order = []

    def dfs(node):
        """"""
        Depth-first search helper function to visit nodes and record the topological order.

        Parameters:
        node: The current node being visited.
        """"""
        # Mark the current node as visited
        visited.add(node)
        # Visit all the adjacent nodes
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor)
        # Add the current node to the topological order
        topological_order.append(node)

    # Visit all nodes in the graph
    for node in graph:
        if node not in visited:
            dfs(node)

    # Reverse the topological order to get the correct order
    topological_order.reverse()
    return topological_order

# Test cases to verify the solution
if __name__ == ""__main__"":
    # Test case 1: Simple DAG
    graph1 = {
        'A': ['C'],
        'B': ['C', 'D'],
        'C': ['E'],
        'D': ['F'],
        'E': ['H', 'F'],
        'F': ['G'],
        'G': [],
        'H': []
    }
    print(funcImp(graph1))  # Expected output: A valid topological order, e.g., ['B', 'A', 'D', 'C', 'E', 'H', 'F', 'G']

    # Test case 2: Another DAG
    graph2 = {
        '5': ['11'],
        '7': ['11', '8'],
        '3': ['8', '10'],
        '11': ['2', '9', '10'],
        '8': ['9'],
        '2': [],
        '9': [],
        '10': []
    }
    print(funcImp(graph2))  # Expected output: A valid topological order, e.g., ['7', '5', '11', '3', '8', '10', '9', '2']

    # Test case 3: Single node
    graph3 = {
        'A': []
    }
    print(funcImp(graph3))  # Expected output: ['A']

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []
```",{'A': []},['A'],['A'],PASS,TRUE,
33,3,medium,"Graph traversal (depth-first search, breadth-first search)",Perform topological sorting on a directed acyclic graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Perform topological sorting on a directed acyclic graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Perform topological sorting on a directed acyclic graph using depth-first search.

    Parameters:
    graph (dict): A dictionary representing the adjacency list of the graph where
                  keys are node identifiers and values are lists of adjacent nodes.

    Returns:
    list: A list of nodes in topologically sorted order.
    """"""
    # Initialize a set to keep track of visited nodes
    visited = set()
    # Initialize a list to store the topological order
    topological_order = []

    def dfs(node):
        """"""
        Depth-first search helper function to visit nodes and record the topological order.

        Parameters:
        node: The current node being visited.
        """"""
        # Mark the current node as visited
        visited.add(node)
        # Visit all the adjacent nodes
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor)
        # Add the current node to the topological order
        topological_order.append(node)

    # Visit all nodes in the graph
    for node in graph:
        if node not in visited:
            dfs(node)

    # Reverse the topological order to get the correct order
    topological_order.reverse()
    return topological_order

# Test cases to verify the solution
if __name__ == ""__main__"":
    # Test case 1: Simple DAG
    graph1 = {
        'A': ['C'],
        'B': ['C', 'D'],
        'C': ['E'],
        'D': ['F'],
        'E': ['H', 'F'],
        'F': ['G'],
        'G': [],
        'H': []
    }
    print(funcImp(graph1))  # Expected output: A valid topological order, e.g., ['B', 'A', 'D', 'C', 'E', 'H', 'F', 'G']

    # Test case 2: Another DAG
    graph2 = {
        '5': ['11'],
        '7': ['11', '8'],
        '3': ['8', '10'],
        '11': ['2', '9', '10'],
        '8': ['9'],
        '2': [],
        '9': [],
        '10': []
    }
    print(funcImp(graph2))  # Expected output: A valid topological order, e.g., ['7', '5', '11', '3', '8', '10', '9', '2']

    # Test case 3: Single node
    graph3 = {
        'A': []
    }
    print(funcImp(graph3))  # Expected output: ['A']

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []
```",{},[],[],PASS,TRUE,
34,0,medium,"Graph traversal (depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end):
    """"""
    Find all paths between two nodes in an undirected graph using DFS.

    :param graph: Dictionary representing the graph as an adjacency list.
    :param start: The starting node.
    :param end: The destination node.
    :return: A list of all paths from start to end.
    """"""
    def dfs(current, destination, path, all_paths):
        # Add the current node to the path
        path.append(current)
        
        # If the current node is the destination, add the path to all_paths
        if current == destination:
            all_paths.append(path.copy())
        else:
            # Explore each adjacent node
            for neighbor in graph.get(current, []):
                if neighbor not in path:  # Avoid cycles
                    dfs(neighbor, destination, path, all_paths)
        
        # Backtrack: remove the current node from the path
        path.pop()

    # List to store all paths
    all_paths = []
    # Start DFS from the start node
    dfs(start, end, [], all_paths)
    return all_paths

# Test cases
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path from A to F
print(""Paths from A to F:"", funcImp(graph, 'A', 'F'))

# Test case 2: Path from A to D
print(""Paths from A to D:"", funcImp(graph, 'A', 'D'))

# Test case 3: Path from B to F
print(""Paths from B to F:"", funcImp(graph, 'B', 'F'))

# Test case 4: Path from C to E
print(""Paths from C to E:"", funcImp(graph, 'C', 'E'))

# Test case 5: Path from D to A (should be empty as D is a leaf)
print(""Paths from D to A:"", funcImp(graph, 'D', 'A'))
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'F')","[['A', 'B', 'E', 'F'], ['A', 'C', 'F']]","[['A', 'B', 'E', 'F'], ['A', 'C', 'F']]",PASS,TRUE,
34,1,medium,"Graph traversal (depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end):
    """"""
    Find all paths between two nodes in an undirected graph using DFS.

    :param graph: Dictionary representing the graph as an adjacency list.
    :param start: The starting node.
    :param end: The destination node.
    :return: A list of all paths from start to end.
    """"""
    def dfs(current, destination, path, all_paths):
        # Add the current node to the path
        path.append(current)
        
        # If the current node is the destination, add the path to all_paths
        if current == destination:
            all_paths.append(path.copy())
        else:
            # Explore each adjacent node
            for neighbor in graph.get(current, []):
                if neighbor not in path:  # Avoid cycles
                    dfs(neighbor, destination, path, all_paths)
        
        # Backtrack: remove the current node from the path
        path.pop()

    # List to store all paths
    all_paths = []
    # Start DFS from the start node
    dfs(start, end, [], all_paths)
    return all_paths

# Test cases
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path from A to F
print(""Paths from A to F:"", funcImp(graph, 'A', 'F'))

# Test case 2: Path from A to D
print(""Paths from A to D:"", funcImp(graph, 'A', 'D'))

# Test case 3: Path from B to F
print(""Paths from B to F:"", funcImp(graph, 'B', 'F'))

# Test case 4: Path from C to E
print(""Paths from C to E:"", funcImp(graph, 'C', 'E'))

# Test case 5: Path from D to A (should be empty as D is a leaf)
print(""Paths from D to A:"", funcImp(graph, 'D', 'A'))
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'D')","[['A', 'B', 'D'], ['A', 'C', 'F', 'E', 'B', 'D']]","[['A', 'B', 'D'], ['A', 'C', 'F', 'E', 'B', 'D']]",PASS,TRUE,
34,2,medium,"Graph traversal (depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end):
    """"""
    Find all paths between two nodes in an undirected graph using DFS.

    :param graph: Dictionary representing the graph as an adjacency list.
    :param start: The starting node.
    :param end: The destination node.
    :return: A list of all paths from start to end.
    """"""
    def dfs(current, destination, path, all_paths):
        # Add the current node to the path
        path.append(current)
        
        # If the current node is the destination, add the path to all_paths
        if current == destination:
            all_paths.append(path.copy())
        else:
            # Explore each adjacent node
            for neighbor in graph.get(current, []):
                if neighbor not in path:  # Avoid cycles
                    dfs(neighbor, destination, path, all_paths)
        
        # Backtrack: remove the current node from the path
        path.pop()

    # List to store all paths
    all_paths = []
    # Start DFS from the start node
    dfs(start, end, [], all_paths)
    return all_paths

# Test cases
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path from A to F
print(""Paths from A to F:"", funcImp(graph, 'A', 'F'))

# Test case 2: Path from A to D
print(""Paths from A to D:"", funcImp(graph, 'A', 'D'))

# Test case 3: Path from B to F
print(""Paths from B to F:"", funcImp(graph, 'B', 'F'))

# Test case 4: Path from C to E
print(""Paths from C to E:"", funcImp(graph, 'C', 'E'))

# Test case 5: Path from D to A (should be empty as D is a leaf)
print(""Paths from D to A:"", funcImp(graph, 'D', 'A'))
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'B', 'F')","[['B', 'A', 'C', 'F'], ['B', 'E', 'F']]","[['B', 'A', 'C', 'F'], ['B', 'E', 'F']]",PASS,TRUE,
34,3,medium,"Graph traversal (depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end):
    """"""
    Find all paths between two nodes in an undirected graph using DFS.

    :param graph: Dictionary representing the graph as an adjacency list.
    :param start: The starting node.
    :param end: The destination node.
    :return: A list of all paths from start to end.
    """"""
    def dfs(current, destination, path, all_paths):
        # Add the current node to the path
        path.append(current)
        
        # If the current node is the destination, add the path to all_paths
        if current == destination:
            all_paths.append(path.copy())
        else:
            # Explore each adjacent node
            for neighbor in graph.get(current, []):
                if neighbor not in path:  # Avoid cycles
                    dfs(neighbor, destination, path, all_paths)
        
        # Backtrack: remove the current node from the path
        path.pop()

    # List to store all paths
    all_paths = []
    # Start DFS from the start node
    dfs(start, end, [], all_paths)
    return all_paths

# Test cases
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path from A to F
print(""Paths from A to F:"", funcImp(graph, 'A', 'F'))

# Test case 2: Path from A to D
print(""Paths from A to D:"", funcImp(graph, 'A', 'D'))

# Test case 3: Path from B to F
print(""Paths from B to F:"", funcImp(graph, 'B', 'F'))

# Test case 4: Path from C to E
print(""Paths from C to E:"", funcImp(graph, 'C', 'E'))

# Test case 5: Path from D to A (should be empty as D is a leaf)
print(""Paths from D to A:"", funcImp(graph, 'D', 'A'))
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'C', 'E')","[['C', 'A', 'B', 'E'], ['C', 'F', 'E']]","[['C', 'A', 'B', 'E'], ['C', 'F', 'E']]",PASS,TRUE,
34,4,medium,"Graph traversal (depth-first search, breadth-first search)",Find all possible paths between two nodes in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find all possible paths between two nodes in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph, start, end):
    """"""
    Find all paths between two nodes in an undirected graph using DFS.

    :param graph: Dictionary representing the graph as an adjacency list.
    :param start: The starting node.
    :param end: The destination node.
    :return: A list of all paths from start to end.
    """"""
    def dfs(current, destination, path, all_paths):
        # Add the current node to the path
        path.append(current)
        
        # If the current node is the destination, add the path to all_paths
        if current == destination:
            all_paths.append(path.copy())
        else:
            # Explore each adjacent node
            for neighbor in graph.get(current, []):
                if neighbor not in path:  # Avoid cycles
                    dfs(neighbor, destination, path, all_paths)
        
        # Backtrack: remove the current node from the path
        path.pop()

    # List to store all paths
    all_paths = []
    # Start DFS from the start node
    dfs(start, end, [], all_paths)
    return all_paths

# Test cases
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Test case 1: Path from A to F
print(""Paths from A to F:"", funcImp(graph, 'A', 'F'))

# Test case 2: Path from A to D
print(""Paths from A to D:"", funcImp(graph, 'A', 'D'))

# Test case 3: Path from B to F
print(""Paths from B to F:"", funcImp(graph, 'B', 'F'))

# Test case 4: Path from C to E
print(""Paths from C to E:"", funcImp(graph, 'C', 'E'))

# Test case 5: Path from D to A (should be empty as D is a leaf)
print(""Paths from D to A:"", funcImp(graph, 'D', 'A'))
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'D', 'A')","[['D', 'B', 'A'], ['D', 'B', 'E', 'F', 'C', 'A']]","[['D', 'B', 'A'], ['D', 'B', 'E', 'F', 'C', 'A']]",PASS,TRUE,
35,0,medium,"Graph traversal (depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Detect and print all cycles in an undirected graph using depth-first search.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    """"""
    def dfs(v, parent, visited, path):
        visited[v] = True
        path.append(v)
        
        for neighbor in graph[v]:
            if not visited[neighbor]:
                dfs(neighbor, v, visited, path)
            elif neighbor != parent and neighbor in path:
                # Cycle detected
                cycle_start_index = path.index(neighbor)
                cycle = path[cycle_start_index:]
                cycles.append(cycle)
        
        path.pop()
    
    visited = {node: False for node in graph}
    cycles = []
    
    for node in graph:
        if not visited[node]:
            dfs(node, None, visited, [])
    
    # Print all unique cycles
    unique_cycles = set(tuple(sorted(cycle)) for cycle in cycles)
    for cycle in unique_cycles:
        print(""Cycle detected:"", cycle)

# Test cases
graph1 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3],
    3: [2, 4],
    4: [3]
}

graph2 = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2, 4],
    4: [3]
}

graph3 = {
    0: [1],
    1: [0, 2],
    2: [1, 3],
    3: [2]
}

print(""Graph 1:"")
funcImp(graph1)
print(""\nGraph 2:"")
funcImp(graph2)
print(""\nGraph 3:"")
funcImp(graph3)
```",0,"{(0, 1, 2)}","{(0, 1, 2)}",PASS,TRUE,None
35,1,medium,"Graph traversal (depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Detect and print all cycles in an undirected graph using depth-first search.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    """"""
    def dfs(v, parent, visited, path):
        visited[v] = True
        path.append(v)
        
        for neighbor in graph[v]:
            if not visited[neighbor]:
                dfs(neighbor, v, visited, path)
            elif neighbor != parent and neighbor in path:
                # Cycle detected
                cycle_start_index = path.index(neighbor)
                cycle = path[cycle_start_index:]
                cycles.append(cycle)
        
        path.pop()
    
    visited = {node: False for node in graph}
    cycles = []
    
    for node in graph:
        if not visited[node]:
            dfs(node, None, visited, [])
    
    # Print all unique cycles
    unique_cycles = set(tuple(sorted(cycle)) for cycle in cycles)
    for cycle in unique_cycles:
        print(""Cycle detected:"", cycle)

# Test cases
graph1 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3],
    3: [2, 4],
    4: [3]
}

graph2 = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2, 4],
    4: [3]
}

graph3 = {
    0: [1],
    1: [0, 2],
    2: [1, 3],
    3: [2]
}

print(""Graph 1:"")
funcImp(graph1)
print(""\nGraph 2:"")
funcImp(graph2)
print(""\nGraph 3:"")
funcImp(graph3)
```",1,"{(0, 1, 2, 3)}","{(0, 1, 2, 3)}",PASS,TRUE,None
35,2,medium,"Graph traversal (depth-first search, breadth-first search)",Detect and print all cycles in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Detect and print all cycles in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Detect and print all cycles in an undirected graph using depth-first search.
    
    :param graph: A dictionary representing an undirected graph where keys are nodes
                  and values are lists of adjacent nodes.
    """"""
    def dfs(v, parent, visited, path):
        visited[v] = True
        path.append(v)
        
        for neighbor in graph[v]:
            if not visited[neighbor]:
                dfs(neighbor, v, visited, path)
            elif neighbor != parent and neighbor in path:
                # Cycle detected
                cycle_start_index = path.index(neighbor)
                cycle = path[cycle_start_index:]
                cycles.append(cycle)
        
        path.pop()
    
    visited = {node: False for node in graph}
    cycles = []
    
    for node in graph:
        if not visited[node]:
            dfs(node, None, visited, [])
    
    # Print all unique cycles
    unique_cycles = set(tuple(sorted(cycle)) for cycle in cycles)
    for cycle in unique_cycles:
        print(""Cycle detected:"", cycle)

# Test cases
graph1 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3],
    3: [2, 4],
    4: [3]
}

graph2 = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2, 4],
    4: [3]
}

graph3 = {
    0: [1],
    1: [0, 2],
    2: [1, 3],
    3: [2]
}

print(""Graph 1:"")
funcImp(graph1)
print(""\nGraph 2:"")
funcImp(graph2)
print(""\nGraph 3:"")
funcImp(graph3)
```",2,set(),set(),PASS,TRUE,None
36,0,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Determine if there exists a path between two nodes in an undirected graph using BFS.

    :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of adjacent nodes.
    :param start: The starting node for the path search.
    :param end: The ending node for the path search.
    :return: True if there is a path from start to end, False otherwise.
    """"""
    if start == end:
        return True

    visited = set()  # To keep track of visited nodes
    queue = deque([start])  # Initialize the queue with the start node

    while queue:
        current = queue.popleft()  # Dequeue a node from the front of the queue
        if current == end:
            return True  # Path found

        visited.add(current)  # Mark the current node as visited

        # Enqueue all adjacent nodes that haven't been visited
        for neighbor in graph.get(current, []):
            if neighbor not in visited:
                queue.append(neighbor)

    return False  # No path found

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with a direct path
    graph1 = {
        'A': ['B', 'C'],
        'B': ['A', 'D'],
        'C': ['A', 'D'],
        'D': ['B', 'C']
    }
    assert funcImp(graph1, 'A', 'D') == True, ""Test case 1 failed""

    # Test case 2: Graph with no path
    graph2 = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph2, 'A', 'D') == False, ""Test case 2 failed""

    # Test case 3: Graph with a single node
    graph3 = {
        'A': []
    }
    assert funcImp(graph3, 'A', 'A') == True, ""Test case 3 failed""

    # Test case 4: Graph with multiple paths
    graph4 = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }
    assert funcImp(graph4, 'A', 'F') == True, ""Test case 4 failed""

    # Test case 5: Graph with no nodes
    graph5 = {}
    assert funcImp(graph5, 'A', 'B') == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'D'], 'D': ['B', 'C']}, 'A', 'D')",TRUE,TRUE,PASS,TRUE,None
36,1,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Determine if there exists a path between two nodes in an undirected graph using BFS.

    :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of adjacent nodes.
    :param start: The starting node for the path search.
    :param end: The ending node for the path search.
    :return: True if there is a path from start to end, False otherwise.
    """"""
    if start == end:
        return True

    visited = set()  # To keep track of visited nodes
    queue = deque([start])  # Initialize the queue with the start node

    while queue:
        current = queue.popleft()  # Dequeue a node from the front of the queue
        if current == end:
            return True  # Path found

        visited.add(current)  # Mark the current node as visited

        # Enqueue all adjacent nodes that haven't been visited
        for neighbor in graph.get(current, []):
            if neighbor not in visited:
                queue.append(neighbor)

    return False  # No path found

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with a direct path
    graph1 = {
        'A': ['B', 'C'],
        'B': ['A', 'D'],
        'C': ['A', 'D'],
        'D': ['B', 'C']
    }
    assert funcImp(graph1, 'A', 'D') == True, ""Test case 1 failed""

    # Test case 2: Graph with no path
    graph2 = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph2, 'A', 'D') == False, ""Test case 2 failed""

    # Test case 3: Graph with a single node
    graph3 = {
        'A': []
    }
    assert funcImp(graph3, 'A', 'A') == True, ""Test case 3 failed""

    # Test case 4: Graph with multiple paths
    graph4 = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }
    assert funcImp(graph4, 'A', 'F') == True, ""Test case 4 failed""

    # Test case 5: Graph with no nodes
    graph5 = {}
    assert funcImp(graph5, 'A', 'B') == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': ['B'], 'B': ['A'], 'C': ['D'], 'D': ['C']}, 'A', 'D')",FALSE,FALSE,PASS,TRUE,None
36,2,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Determine if there exists a path between two nodes in an undirected graph using BFS.

    :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of adjacent nodes.
    :param start: The starting node for the path search.
    :param end: The ending node for the path search.
    :return: True if there is a path from start to end, False otherwise.
    """"""
    if start == end:
        return True

    visited = set()  # To keep track of visited nodes
    queue = deque([start])  # Initialize the queue with the start node

    while queue:
        current = queue.popleft()  # Dequeue a node from the front of the queue
        if current == end:
            return True  # Path found

        visited.add(current)  # Mark the current node as visited

        # Enqueue all adjacent nodes that haven't been visited
        for neighbor in graph.get(current, []):
            if neighbor not in visited:
                queue.append(neighbor)

    return False  # No path found

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with a direct path
    graph1 = {
        'A': ['B', 'C'],
        'B': ['A', 'D'],
        'C': ['A', 'D'],
        'D': ['B', 'C']
    }
    assert funcImp(graph1, 'A', 'D') == True, ""Test case 1 failed""

    # Test case 2: Graph with no path
    graph2 = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph2, 'A', 'D') == False, ""Test case 2 failed""

    # Test case 3: Graph with a single node
    graph3 = {
        'A': []
    }
    assert funcImp(graph3, 'A', 'A') == True, ""Test case 3 failed""

    # Test case 4: Graph with multiple paths
    graph4 = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }
    assert funcImp(graph4, 'A', 'F') == True, ""Test case 4 failed""

    # Test case 5: Graph with no nodes
    graph5 = {}
    assert funcImp(graph5, 'A', 'B') == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': []}, 'A', 'A')",TRUE,TRUE,PASS,TRUE,None
36,3,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Determine if there exists a path between two nodes in an undirected graph using BFS.

    :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of adjacent nodes.
    :param start: The starting node for the path search.
    :param end: The ending node for the path search.
    :return: True if there is a path from start to end, False otherwise.
    """"""
    if start == end:
        return True

    visited = set()  # To keep track of visited nodes
    queue = deque([start])  # Initialize the queue with the start node

    while queue:
        current = queue.popleft()  # Dequeue a node from the front of the queue
        if current == end:
            return True  # Path found

        visited.add(current)  # Mark the current node as visited

        # Enqueue all adjacent nodes that haven't been visited
        for neighbor in graph.get(current, []):
            if neighbor not in visited:
                queue.append(neighbor)

    return False  # No path found

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with a direct path
    graph1 = {
        'A': ['B', 'C'],
        'B': ['A', 'D'],
        'C': ['A', 'D'],
        'D': ['B', 'C']
    }
    assert funcImp(graph1, 'A', 'D') == True, ""Test case 1 failed""

    # Test case 2: Graph with no path
    graph2 = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph2, 'A', 'D') == False, ""Test case 2 failed""

    # Test case 3: Graph with a single node
    graph3 = {
        'A': []
    }
    assert funcImp(graph3, 'A', 'A') == True, ""Test case 3 failed""

    # Test case 4: Graph with multiple paths
    graph4 = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }
    assert funcImp(graph4, 'A', 'F') == True, ""Test case 4 failed""

    # Test case 5: Graph with no nodes
    graph5 = {}
    assert funcImp(graph5, 'A', 'B') == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A', 'F')",TRUE,TRUE,PASS,TRUE,None
36,4,medium,"Graph traversal (depth-first search, breadth-first search)",Determine if there exists a path between two nodes in an undirected graph using breadth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determine if there exists a path between two nodes in an undirected graph using breadth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
from collections import deque

def funcImp(graph, start, end):
    """"""
    Determine if there exists a path between two nodes in an undirected graph using BFS.

    :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of adjacent nodes.
    :param start: The starting node for the path search.
    :param end: The ending node for the path search.
    :return: True if there is a path from start to end, False otherwise.
    """"""
    if start == end:
        return True

    visited = set()  # To keep track of visited nodes
    queue = deque([start])  # Initialize the queue with the start node

    while queue:
        current = queue.popleft()  # Dequeue a node from the front of the queue
        if current == end:
            return True  # Path found

        visited.add(current)  # Mark the current node as visited

        # Enqueue all adjacent nodes that haven't been visited
        for neighbor in graph.get(current, []):
            if neighbor not in visited:
                queue.append(neighbor)

    return False  # No path found

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with a direct path
    graph1 = {
        'A': ['B', 'C'],
        'B': ['A', 'D'],
        'C': ['A', 'D'],
        'D': ['B', 'C']
    }
    assert funcImp(graph1, 'A', 'D') == True, ""Test case 1 failed""

    # Test case 2: Graph with no path
    graph2 = {
        'A': ['B'],
        'B': ['A'],
        'C': ['D'],
        'D': ['C']
    }
    assert funcImp(graph2, 'A', 'D') == False, ""Test case 2 failed""

    # Test case 3: Graph with a single node
    graph3 = {
        'A': []
    }
    assert funcImp(graph3, 'A', 'A') == True, ""Test case 3 failed""

    # Test case 4: Graph with multiple paths
    graph4 = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }
    assert funcImp(graph4, 'A', 'F') == True, ""Test case 4 failed""

    # Test case 5: Graph with no nodes
    graph5 = {}
    assert funcImp(graph5, 'A', 'B') == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","({}, 'A', 'B')",FALSE,FALSE,PASS,TRUE,None
37,0,medium,"Graph traversal (depth-first search, breadth-first search)","Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.","## Problem Statement
- Develop a Python script to solve the problem: 'Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(edges, num_vertices):
    """"""
    Implements Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.
    
    :param edges: List of tuples (u, v, weight) representing the edges of the graph.
    :param num_vertices: Number of vertices in the graph.
    :return: List of edges that form the minimum spanning tree.
    """"""
    
    # Helper function to find the root of a vertex with path compression
    def find(parent, i):
        if parent[i] == i:
            return i
        else:
            parent[i] = find(parent, parent[i])
            return parent[i]

    # Helper function to union two subsets
    def union(parent, rank, x, y):
        root_x = find(parent, x)
        root_y = find(parent, y)
        
        if rank[root_x] < rank[root_y]:
            parent[root_x] = root_y
        elif rank[root_x] > rank[root_y]:
            parent[root_y] = root_x
        else:
            parent[root_y] = root_x
            rank[root_x] += 1

    # Sort all the edges in non-decreasing order of their weight
    edges = sorted(edges, key=lambda item: item[2])
    
    # Create a parent array and a rank array for union-find
    parent = []
    rank = []
    
    # Initialize parent and rank arrays
    for node in range(num_vertices):
        parent.append(node)
        rank.append(0)
    
    # Resulting MST
    mst = []
    
    # Number of edges in MST
    e = 0
    
    # Index variable for sorted edges
    i = 0
    
    # Number of edges to be taken is equal to V-1
    while e < num_vertices - 1:
        # Pick the smallest edge and increment the index for next iteration
        u, v, w = edges[i]
        i += 1
        x = find(parent, u)
        y = find(parent, v)
        
        # If including this edge does not cause a cycle, include it in the result
        if x != y:
            e += 1
            mst.append((u, v, w))
            union(parent, rank, x, y)
    
    return mst

# Test the function with a sample graph
edges = [
    (0, 1, 10),
    (0, 2, 6),
    (0, 3, 5),
    (1, 3, 15),
    (2, 3, 4)
]
num_vertices = 4

# Expected output: [(2, 3, 4), (0, 3, 5), (0, 1, 10)]
print(funcImp(edges, num_vertices))
```","([(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)], 4)","[(2, 3, 4), (0, 3, 5), (0, 1, 10)]","[(2, 3, 4), (0, 3, 5), (0, 1, 10)]",PASS,TRUE,
37,1,medium,"Graph traversal (depth-first search, breadth-first search)","Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.","## Problem Statement
- Develop a Python script to solve the problem: 'Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(edges, num_vertices):
    """"""
    Implements Kruskal's algorithm to find the minimum spanning tree of a weighted, connected graph.
    
    :param edges: List of tuples (u, v, weight) representing the edges of the graph.
    :param num_vertices: Number of vertices in the graph.
    :return: List of edges that form the minimum spanning tree.
    """"""
    
    # Helper function to find the root of a vertex with path compression
    def find(parent, i):
        if parent[i] == i:
            return i
        else:
            parent[i] = find(parent, parent[i])
            return parent[i]

    # Helper function to union two subsets
    def union(parent, rank, x, y):
        root_x = find(parent, x)
        root_y = find(parent, y)
        
        if rank[root_x] < rank[root_y]:
            parent[root_x] = root_y
        elif rank[root_x] > rank[root_y]:
            parent[root_y] = root_x
        else:
            parent[root_y] = root_x
            rank[root_x] += 1

    # Sort all the edges in non-decreasing order of their weight
    edges = sorted(edges, key=lambda item: item[2])
    
    # Create a parent array and a rank array for union-find
    parent = []
    rank = []
    
    # Initialize parent and rank arrays
    for node in range(num_vertices):
        parent.append(node)
        rank.append(0)
    
    # Resulting MST
    mst = []
    
    # Number of edges in MST
    e = 0
    
    # Index variable for sorted edges
    i = 0
    
    # Number of edges to be taken is equal to V-1
    while e < num_vertices - 1:
        # Pick the smallest edge and increment the index for next iteration
        u, v, w = edges[i]
        i += 1
        x = find(parent, u)
        y = find(parent, v)
        
        # If including this edge does not cause a cycle, include it in the result
        if x != y:
            e += 1
            mst.append((u, v, w))
            union(parent, rank, x, y)
    
    return mst

# Test the function with a sample graph
edges = [
    (0, 1, 10),
    (0, 2, 6),
    (0, 3, 5),
    (1, 3, 15),
    (2, 3, 4)
]
num_vertices = 4

# Expected output: [(2, 3, 4), (0, 3, 5), (0, 1, 10)]
print(funcImp(edges, num_vertices))
```","([(0, 1, 1), (1, 2, 2), (0, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (3, 5, 7)], 6)","[(0, 1, 1), (1, 2, 2), (2, 3, 4), (3, 4, 5), (4, 5, 6)]","[(0, 1, 1), (1, 2, 2), (2, 3, 4), (3, 4, 5), (4, 5, 6)]",PASS,TRUE,
38,0,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_nodes, edges):
    """"""
    Count the number of connected components in an undirected graph using DFS.

    :param num_nodes: Number of nodes in the graph.
    :param edges: List of edges where each edge is represented as a tuple (u, v).
    :return: Number of connected components in the graph.
    """"""
    # Create an adjacency list for the graph
    graph = {i: [] for i in range(num_nodes)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    # Helper function to perform DFS
    def dfs(node, visited):
        stack = [node]
        while stack:
            current = stack.pop()
            for neighbor in graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    stack.append(neighbor)

    visited = set()
    connected_components = 0

    # Iterate over all nodes to find connected components
    for node in range(num_nodes):
        if node not in visited:
            # Start a new DFS for each unvisited node
            visited.add(node)
            dfs(node, visited)
            connected_components += 1

    return connected_components

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with two components
    num_nodes1 = 5
    edges1 = [(0, 1), (1, 2), (3, 4)]
    assert funcImp(num_nodes1, edges1) == 2

    # Test case 2: Fully connected graph (one component)
    num_nodes2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3), (3, 0)]
    assert funcImp(num_nodes2, edges2) == 1

    # Test case 3: Disconnected nodes (each node is its own component)
    num_nodes3 = 3
    edges3 = []
    assert funcImp(num_nodes3, edges3) == 3

    # Test case 4: Single node graph
    num_nodes4 = 1
    edges4 = []
    assert funcImp(num_nodes4, edges4) == 1

    # Test case 5: Graph with a single edge
    num_nodes5 = 2
    edges5 = [(0, 1)]
    assert funcImp(num_nodes5, edges5) == 1

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","num_nodes=5, edges=[(0, 1), (1, 2), (3, 4)]",2,2,PASS,TRUE,
38,1,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_nodes, edges):
    """"""
    Count the number of connected components in an undirected graph using DFS.

    :param num_nodes: Number of nodes in the graph.
    :param edges: List of edges where each edge is represented as a tuple (u, v).
    :return: Number of connected components in the graph.
    """"""
    # Create an adjacency list for the graph
    graph = {i: [] for i in range(num_nodes)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    # Helper function to perform DFS
    def dfs(node, visited):
        stack = [node]
        while stack:
            current = stack.pop()
            for neighbor in graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    stack.append(neighbor)

    visited = set()
    connected_components = 0

    # Iterate over all nodes to find connected components
    for node in range(num_nodes):
        if node not in visited:
            # Start a new DFS for each unvisited node
            visited.add(node)
            dfs(node, visited)
            connected_components += 1

    return connected_components

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with two components
    num_nodes1 = 5
    edges1 = [(0, 1), (1, 2), (3, 4)]
    assert funcImp(num_nodes1, edges1) == 2

    # Test case 2: Fully connected graph (one component)
    num_nodes2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3), (3, 0)]
    assert funcImp(num_nodes2, edges2) == 1

    # Test case 3: Disconnected nodes (each node is its own component)
    num_nodes3 = 3
    edges3 = []
    assert funcImp(num_nodes3, edges3) == 3

    # Test case 4: Single node graph
    num_nodes4 = 1
    edges4 = []
    assert funcImp(num_nodes4, edges4) == 1

    # Test case 5: Graph with a single edge
    num_nodes5 = 2
    edges5 = [(0, 1)]
    assert funcImp(num_nodes5, edges5) == 1

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","num_nodes=4, edges=[(0, 1), (1, 2), (2, 3), (3, 0)]",1,1,PASS,TRUE,
38,2,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_nodes, edges):
    """"""
    Count the number of connected components in an undirected graph using DFS.

    :param num_nodes: Number of nodes in the graph.
    :param edges: List of edges where each edge is represented as a tuple (u, v).
    :return: Number of connected components in the graph.
    """"""
    # Create an adjacency list for the graph
    graph = {i: [] for i in range(num_nodes)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    # Helper function to perform DFS
    def dfs(node, visited):
        stack = [node]
        while stack:
            current = stack.pop()
            for neighbor in graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    stack.append(neighbor)

    visited = set()
    connected_components = 0

    # Iterate over all nodes to find connected components
    for node in range(num_nodes):
        if node not in visited:
            # Start a new DFS for each unvisited node
            visited.add(node)
            dfs(node, visited)
            connected_components += 1

    return connected_components

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with two components
    num_nodes1 = 5
    edges1 = [(0, 1), (1, 2), (3, 4)]
    assert funcImp(num_nodes1, edges1) == 2

    # Test case 2: Fully connected graph (one component)
    num_nodes2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3), (3, 0)]
    assert funcImp(num_nodes2, edges2) == 1

    # Test case 3: Disconnected nodes (each node is its own component)
    num_nodes3 = 3
    edges3 = []
    assert funcImp(num_nodes3, edges3) == 3

    # Test case 4: Single node graph
    num_nodes4 = 1
    edges4 = []
    assert funcImp(num_nodes4, edges4) == 1

    # Test case 5: Graph with a single edge
    num_nodes5 = 2
    edges5 = [(0, 1)]
    assert funcImp(num_nodes5, edges5) == 1

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","num_nodes=3, edges=[]",3,3,PASS,TRUE,
38,3,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_nodes, edges):
    """"""
    Count the number of connected components in an undirected graph using DFS.

    :param num_nodes: Number of nodes in the graph.
    :param edges: List of edges where each edge is represented as a tuple (u, v).
    :return: Number of connected components in the graph.
    """"""
    # Create an adjacency list for the graph
    graph = {i: [] for i in range(num_nodes)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    # Helper function to perform DFS
    def dfs(node, visited):
        stack = [node]
        while stack:
            current = stack.pop()
            for neighbor in graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    stack.append(neighbor)

    visited = set()
    connected_components = 0

    # Iterate over all nodes to find connected components
    for node in range(num_nodes):
        if node not in visited:
            # Start a new DFS for each unvisited node
            visited.add(node)
            dfs(node, visited)
            connected_components += 1

    return connected_components

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with two components
    num_nodes1 = 5
    edges1 = [(0, 1), (1, 2), (3, 4)]
    assert funcImp(num_nodes1, edges1) == 2

    # Test case 2: Fully connected graph (one component)
    num_nodes2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3), (3, 0)]
    assert funcImp(num_nodes2, edges2) == 1

    # Test case 3: Disconnected nodes (each node is its own component)
    num_nodes3 = 3
    edges3 = []
    assert funcImp(num_nodes3, edges3) == 3

    # Test case 4: Single node graph
    num_nodes4 = 1
    edges4 = []
    assert funcImp(num_nodes4, edges4) == 1

    # Test case 5: Graph with a single edge
    num_nodes5 = 2
    edges5 = [(0, 1)]
    assert funcImp(num_nodes5, edges5) == 1

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","num_nodes=1, edges=[]",1,1,PASS,TRUE,
38,4,medium,"Graph traversal (depth-first search, breadth-first search)",Count the number of connected components in an undirected graph using depth-first search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Count the number of connected components in an undirected graph using depth-first search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(num_nodes, edges):
    """"""
    Count the number of connected components in an undirected graph using DFS.

    :param num_nodes: Number of nodes in the graph.
    :param edges: List of edges where each edge is represented as a tuple (u, v).
    :return: Number of connected components in the graph.
    """"""
    # Create an adjacency list for the graph
    graph = {i: [] for i in range(num_nodes)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    # Helper function to perform DFS
    def dfs(node, visited):
        stack = [node]
        while stack:
            current = stack.pop()
            for neighbor in graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    stack.append(neighbor)

    visited = set()
    connected_components = 0

    # Iterate over all nodes to find connected components
    for node in range(num_nodes):
        if node not in visited:
            # Start a new DFS for each unvisited node
            visited.add(node)
            dfs(node, visited)
            connected_components += 1

    return connected_components

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Simple graph with two components
    num_nodes1 = 5
    edges1 = [(0, 1), (1, 2), (3, 4)]
    assert funcImp(num_nodes1, edges1) == 2

    # Test case 2: Fully connected graph (one component)
    num_nodes2 = 4
    edges2 = [(0, 1), (1, 2), (2, 3), (3, 0)]
    assert funcImp(num_nodes2, edges2) == 1

    # Test case 3: Disconnected nodes (each node is its own component)
    num_nodes3 = 3
    edges3 = []
    assert funcImp(num_nodes3, edges3) == 3

    # Test case 4: Single node graph
    num_nodes4 = 1
    edges4 = []
    assert funcImp(num_nodes4, edges4) == 1

    # Test case 5: Graph with a single edge
    num_nodes5 = 2
    edges5 = [(0, 1)]
    assert funcImp(num_nodes5, edges5) == 1

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","num_nodes=2, edges=[(0, 1)]",1,1,PASS,TRUE,
39,0,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 3)",2,2,PASS,TRUE,
39,1,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 1)",0,0,PASS,TRUE,
39,2,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 5)",4,4,PASS,TRUE,
39,3,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 6)",-1,-1,PASS,TRUE,
39,4,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([], 1)",-1,-1,PASS,TRUE,
39,5,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1], 1)",0,0,PASS,TRUE,
39,6,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1], 2)",-1,-1,PASS,TRUE,
39,7,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([-5, -3, -1, 0, 2, 4], -3)",1,1,PASS,TRUE,
39,8,hard,Binary Search,Implement a binary search algorithm to find the index of a specific element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement a binary search algorithm to find the index of a specific element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform a binary search on a sorted array to find the index of a target element.

    Parameters:
    arr (list): A sorted list of elements.
    target (int/float/str): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target absent
    assert funcImp([1], 2) == -1
    # Test case 8: Array with negative numbers
    assert funcImp([-5, -3, -1, 0, 2, 4], -3) == 1
    # Test case 9: Array with duplicate elements
    assert funcImp([1, 2, 2, 2, 3], 2) == 1  # Returns the first occurrence

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 2, 2, 3], 2)","[1, 2, 3]",2,FAIL,FALSE,
40,0,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find the first occurrence
    of a target element. If the target is found, it returns the index of the first occurrence.
    If the target is not found, it returns -1.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (int/float/str): The target element to find in the array.

    Returns:
    int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating target not found initially

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Move the right pointer to search in the left half
        elif arr[mid] < target:
            left = mid + 1  # Move the left pointer to search in the right half
        else:
            right = mid - 1  # Move the right pointer to search in the left half

    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present and has multiple occurrences
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 1, ""Test case 1 failed""
    
    # Test case 2: Target is present and is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 2 failed""
    
    # Test case 3: Target is present and is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 3 failed""
    
    # Test case 4: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 4 failed""
    
    # Test case 5: Empty array
    assert funcImp([], 1) == -1, ""Test case 5 failed""
    
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1, ""Test case 7 failed""
    
    # Test case 8: Target is present and is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 2, 2, 3, 4, 5], 2)",1,1,PASS,TRUE,
40,1,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find the first occurrence
    of a target element. If the target is found, it returns the index of the first occurrence.
    If the target is not found, it returns -1.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (int/float/str): The target element to find in the array.

    Returns:
    int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating target not found initially

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Move the right pointer to search in the left half
        elif arr[mid] < target:
            left = mid + 1  # Move the left pointer to search in the right half
        else:
            right = mid - 1  # Move the right pointer to search in the left half

    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present and has multiple occurrences
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 1, ""Test case 1 failed""
    
    # Test case 2: Target is present and is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 2 failed""
    
    # Test case 3: Target is present and is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 3 failed""
    
    # Test case 4: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 4 failed""
    
    # Test case 5: Empty array
    assert funcImp([], 1) == -1, ""Test case 5 failed""
    
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1, ""Test case 7 failed""
    
    # Test case 8: Target is present and is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 1)",0,0,PASS,TRUE,
40,2,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find the first occurrence
    of a target element. If the target is found, it returns the index of the first occurrence.
    If the target is not found, it returns -1.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (int/float/str): The target element to find in the array.

    Returns:
    int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating target not found initially

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Move the right pointer to search in the left half
        elif arr[mid] < target:
            left = mid + 1  # Move the left pointer to search in the right half
        else:
            right = mid - 1  # Move the right pointer to search in the left half

    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present and has multiple occurrences
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 1, ""Test case 1 failed""
    
    # Test case 2: Target is present and is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 2 failed""
    
    # Test case 3: Target is present and is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 3 failed""
    
    # Test case 4: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 4 failed""
    
    # Test case 5: Empty array
    assert funcImp([], 1) == -1, ""Test case 5 failed""
    
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1, ""Test case 7 failed""
    
    # Test case 8: Target is present and is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 5)",4,4,PASS,TRUE,
40,3,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find the first occurrence
    of a target element. If the target is found, it returns the index of the first occurrence.
    If the target is not found, it returns -1.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (int/float/str): The target element to find in the array.

    Returns:
    int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating target not found initially

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Move the right pointer to search in the left half
        elif arr[mid] < target:
            left = mid + 1  # Move the left pointer to search in the right half
        else:
            right = mid - 1  # Move the right pointer to search in the left half

    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present and has multiple occurrences
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 1, ""Test case 1 failed""
    
    # Test case 2: Target is present and is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 2 failed""
    
    # Test case 3: Target is present and is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 3 failed""
    
    # Test case 4: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 4 failed""
    
    # Test case 5: Empty array
    assert funcImp([], 1) == -1, ""Test case 5 failed""
    
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1, ""Test case 7 failed""
    
    # Test case 8: Target is present and is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 6)",-1,-1,PASS,TRUE,
40,4,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find the first occurrence
    of a target element. If the target is found, it returns the index of the first occurrence.
    If the target is not found, it returns -1.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (int/float/str): The target element to find in the array.

    Returns:
    int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating target not found initially

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Move the right pointer to search in the left half
        elif arr[mid] < target:
            left = mid + 1  # Move the left pointer to search in the right half
        else:
            right = mid - 1  # Move the right pointer to search in the left half

    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present and has multiple occurrences
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 1, ""Test case 1 failed""
    
    # Test case 2: Target is present and is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 2 failed""
    
    # Test case 3: Target is present and is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 3 failed""
    
    # Test case 4: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 4 failed""
    
    # Test case 5: Empty array
    assert funcImp([], 1) == -1, ""Test case 5 failed""
    
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1, ""Test case 7 failed""
    
    # Test case 8: Target is present and is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([], 1)",-1,-1,PASS,TRUE,
40,5,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find the first occurrence
    of a target element. If the target is found, it returns the index of the first occurrence.
    If the target is not found, it returns -1.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (int/float/str): The target element to find in the array.

    Returns:
    int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating target not found initially

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Move the right pointer to search in the left half
        elif arr[mid] < target:
            left = mid + 1  # Move the left pointer to search in the right half
        else:
            right = mid - 1  # Move the right pointer to search in the left half

    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present and has multiple occurrences
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 1, ""Test case 1 failed""
    
    # Test case 2: Target is present and is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 2 failed""
    
    # Test case 3: Target is present and is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 3 failed""
    
    # Test case 4: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 4 failed""
    
    # Test case 5: Empty array
    assert funcImp([], 1) == -1, ""Test case 5 failed""
    
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1, ""Test case 7 failed""
    
    # Test case 8: Target is present and is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1], 1)",0,0,PASS,TRUE,
40,6,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find the first occurrence
    of a target element. If the target is found, it returns the index of the first occurrence.
    If the target is not found, it returns -1.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (int/float/str): The target element to find in the array.

    Returns:
    int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating target not found initially

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Move the right pointer to search in the left half
        elif arr[mid] < target:
            left = mid + 1  # Move the left pointer to search in the right half
        else:
            right = mid - 1  # Move the right pointer to search in the left half

    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present and has multiple occurrences
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 1, ""Test case 1 failed""
    
    # Test case 2: Target is present and is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 2 failed""
    
    # Test case 3: Target is present and is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 3 failed""
    
    # Test case 4: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 4 failed""
    
    # Test case 5: Empty array
    assert funcImp([], 1) == -1, ""Test case 5 failed""
    
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1, ""Test case 7 failed""
    
    # Test case 8: Target is present and is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1], 2)",-1,-1,PASS,TRUE,
40,7,hard,Binary Search,"Given a sorted array, find the first occurrence of a target element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a sorted array, find the first occurrence of a target element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function performs a binary search on a sorted array to find the first occurrence
    of a target element. If the target is found, it returns the index of the first occurrence.
    If the target is not found, it returns -1.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (int/float/str): The target element to find in the array.

    Returns:
    int: The index of the first occurrence of the target element, or -1 if not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating target not found initially

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Move the right pointer to search in the left half
        elif arr[mid] < target:
            left = mid + 1  # Move the left pointer to search in the right half
        else:
            right = mid - 1  # Move the right pointer to search in the left half

    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present and has multiple occurrences
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 1, ""Test case 1 failed""
    
    # Test case 2: Target is present and is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 2 failed""
    
    # Test case 3: Target is present and is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 3 failed""
    
    # Test case 4: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 4 failed""
    
    # Test case 5: Empty array
    assert funcImp([], 1) == -1, ""Test case 5 failed""
    
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1, ""Test case 7 failed""
    
    # Test case 8: Target is present and is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 8 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 3)",2,2,PASS,TRUE,
41,0,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function finds the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A sorted list of elements where we need to find the target.
    target (int/float/str): The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array. 
         Returns -1 if the target is not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1 to indicate target not found by default
    
    while left <= right:
        mid = left + (right - left) // 2  # Calculate mid index
        
        if arr[mid] == target:
            result = mid  # Update result to current mid
            left = mid + 1  # Move left to mid + 1 to search in the right half
        elif arr[mid] < target:
            left = mid + 1  # Move left to mid + 1 to search in the right half
        else:
            right = mid - 1  # Move right to mid - 1 to search in the left half
    
    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present multiple times
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 3, ""Test case 1 failed""
    
    # Test case 2: Target is present once
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 2 failed""
    
    # Test case 3: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 3 failed""
    
    # Test case 4: Empty array
    assert funcImp([], 1) == -1, ""Test case 4 failed""
    
    # Test case 5: All elements are the target
    assert funcImp([2, 2, 2, 2, 2], 2) == 4, ""Test case 5 failed""
    
    # Test case 6: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 2, 2, 3, 4, 5], 2)",3,3,PASS,TRUE,
41,1,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function finds the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A sorted list of elements where we need to find the target.
    target (int/float/str): The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array. 
         Returns -1 if the target is not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1 to indicate target not found by default
    
    while left <= right:
        mid = left + (right - left) // 2  # Calculate mid index
        
        if arr[mid] == target:
            result = mid  # Update result to current mid
            left = mid + 1  # Move left to mid + 1 to search in the right half
        elif arr[mid] < target:
            left = mid + 1  # Move left to mid + 1 to search in the right half
        else:
            right = mid - 1  # Move right to mid - 1 to search in the left half
    
    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present multiple times
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 3, ""Test case 1 failed""
    
    # Test case 2: Target is present once
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 2 failed""
    
    # Test case 3: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 3 failed""
    
    # Test case 4: Empty array
    assert funcImp([], 1) == -1, ""Test case 4 failed""
    
    # Test case 5: All elements are the target
    assert funcImp([2, 2, 2, 2, 2], 2) == 4, ""Test case 5 failed""
    
    # Test case 6: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 3)",2,2,PASS,TRUE,
41,2,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function finds the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A sorted list of elements where we need to find the target.
    target (int/float/str): The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array. 
         Returns -1 if the target is not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1 to indicate target not found by default
    
    while left <= right:
        mid = left + (right - left) // 2  # Calculate mid index
        
        if arr[mid] == target:
            result = mid  # Update result to current mid
            left = mid + 1  # Move left to mid + 1 to search in the right half
        elif arr[mid] < target:
            left = mid + 1  # Move left to mid + 1 to search in the right half
        else:
            right = mid - 1  # Move right to mid - 1 to search in the left half
    
    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present multiple times
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 3, ""Test case 1 failed""
    
    # Test case 2: Target is present once
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 2 failed""
    
    # Test case 3: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 3 failed""
    
    # Test case 4: Empty array
    assert funcImp([], 1) == -1, ""Test case 4 failed""
    
    # Test case 5: All elements are the target
    assert funcImp([2, 2, 2, 2, 2], 2) == 4, ""Test case 5 failed""
    
    # Test case 6: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 6)",-1,-1,PASS,TRUE,
41,3,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function finds the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A sorted list of elements where we need to find the target.
    target (int/float/str): The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array. 
         Returns -1 if the target is not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1 to indicate target not found by default
    
    while left <= right:
        mid = left + (right - left) // 2  # Calculate mid index
        
        if arr[mid] == target:
            result = mid  # Update result to current mid
            left = mid + 1  # Move left to mid + 1 to search in the right half
        elif arr[mid] < target:
            left = mid + 1  # Move left to mid + 1 to search in the right half
        else:
            right = mid - 1  # Move right to mid - 1 to search in the left half
    
    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present multiple times
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 3, ""Test case 1 failed""
    
    # Test case 2: Target is present once
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 2 failed""
    
    # Test case 3: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 3 failed""
    
    # Test case 4: Empty array
    assert funcImp([], 1) == -1, ""Test case 4 failed""
    
    # Test case 5: All elements are the target
    assert funcImp([2, 2, 2, 2, 2], 2) == 4, ""Test case 5 failed""
    
    # Test case 6: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([], 1)",-1,-1,PASS,TRUE,
41,4,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function finds the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A sorted list of elements where we need to find the target.
    target (int/float/str): The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array. 
         Returns -1 if the target is not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1 to indicate target not found by default
    
    while left <= right:
        mid = left + (right - left) // 2  # Calculate mid index
        
        if arr[mid] == target:
            result = mid  # Update result to current mid
            left = mid + 1  # Move left to mid + 1 to search in the right half
        elif arr[mid] < target:
            left = mid + 1  # Move left to mid + 1 to search in the right half
        else:
            right = mid - 1  # Move right to mid - 1 to search in the left half
    
    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present multiple times
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 3, ""Test case 1 failed""
    
    # Test case 2: Target is present once
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 2 failed""
    
    # Test case 3: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 3 failed""
    
    # Test case 4: Empty array
    assert funcImp([], 1) == -1, ""Test case 4 failed""
    
    # Test case 5: All elements are the target
    assert funcImp([2, 2, 2, 2, 2], 2) == 4, ""Test case 5 failed""
    
    # Test case 6: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([2, 2, 2, 2, 2], 2)",4,4,PASS,TRUE,
41,5,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function finds the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A sorted list of elements where we need to find the target.
    target (int/float/str): The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array. 
         Returns -1 if the target is not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1 to indicate target not found by default
    
    while left <= right:
        mid = left + (right - left) // 2  # Calculate mid index
        
        if arr[mid] == target:
            result = mid  # Update result to current mid
            left = mid + 1  # Move left to mid + 1 to search in the right half
        elif arr[mid] < target:
            left = mid + 1  # Move left to mid + 1 to search in the right half
        else:
            right = mid - 1  # Move right to mid - 1 to search in the left half
    
    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present multiple times
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 3, ""Test case 1 failed""
    
    # Test case 2: Target is present once
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 2 failed""
    
    # Test case 3: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 3 failed""
    
    # Test case 4: Empty array
    assert funcImp([], 1) == -1, ""Test case 4 failed""
    
    # Test case 5: All elements are the target
    assert funcImp([2, 2, 2, 2, 2], 2) == 4, ""Test case 5 failed""
    
    # Test case 6: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 1)",0,0,PASS,TRUE,
41,6,hard,Binary Search,Find the last occurrence of a target element in a sorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the last occurrence of a target element in a sorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    This function finds the last occurrence of a target element in a sorted array using binary search.
    
    Parameters:
    arr (list): A sorted list of elements where we need to find the target.
    target (int/float/str): The element whose last occurrence needs to be found.
    
    Returns:
    int: The index of the last occurrence of the target element in the array. 
         Returns -1 if the target is not found.
    """"""
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1 to indicate target not found by default
    
    while left <= right:
        mid = left + (right - left) // 2  # Calculate mid index
        
        if arr[mid] == target:
            result = mid  # Update result to current mid
            left = mid + 1  # Move left to mid + 1 to search in the right half
        elif arr[mid] < target:
            left = mid + 1  # Move left to mid + 1 to search in the right half
        else:
            right = mid - 1  # Move right to mid - 1 to search in the left half
    
    return result

# Test cases to verify the correctness of the function
def test_funcImp():
    # Test case 1: Target is present multiple times
    assert funcImp([1, 2, 2, 2, 3, 4, 5], 2) == 3, ""Test case 1 failed""
    
    # Test case 2: Target is present once
    assert funcImp([1, 2, 3, 4, 5], 3) == 2, ""Test case 2 failed""
    
    # Test case 3: Target is not present
    assert funcImp([1, 2, 3, 4, 5], 6) == -1, ""Test case 3 failed""
    
    # Test case 4: Empty array
    assert funcImp([], 1) == -1, ""Test case 4 failed""
    
    # Test case 5: All elements are the target
    assert funcImp([2, 2, 2, 2, 2], 2) == 4, ""Test case 5 failed""
    
    # Test case 6: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0, ""Test case 6 failed""
    
    # Test case 7: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4, ""Test case 7 failed""
    
    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 5)",4,4,PASS,TRUE,
42,0,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of the target element.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (any): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the funcImp function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1
    # Test case 8: Large array
    assert funcImp(list(range(1000000)), 999999) == 999999

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 3)",2,2,PASS,TRUE,
42,1,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of the target element.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (any): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the funcImp function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1
    # Test case 8: Large array
    assert funcImp(list(range(1000000)), 999999) == 999999

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 1)",0,0,PASS,TRUE,
42,2,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of the target element.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (any): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the funcImp function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1
    # Test case 8: Large array
    assert funcImp(list(range(1000000)), 999999) == 999999

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 5)",4,4,PASS,TRUE,
42,3,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of the target element.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (any): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the funcImp function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1
    # Test case 8: Large array
    assert funcImp(list(range(1000000)), 999999) == 999999

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1, 2, 3, 4, 5], 6)",-1,-1,PASS,TRUE,
42,4,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of the target element.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (any): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the funcImp function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1
    # Test case 8: Large array
    assert funcImp(list(range(1000000)), 999999) == 999999

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([], 1)",-1,-1,PASS,TRUE,
42,5,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of the target element.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (any): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the funcImp function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1
    # Test case 8: Large array
    assert funcImp(list(range(1000000)), 999999) == 999999

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1], 1)",0,0,PASS,TRUE,
42,6,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of the target element.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (any): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the funcImp function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1
    # Test case 8: Large array
    assert funcImp(list(range(1000000)), 999999) == 999999

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([1], 2)",-1,-1,PASS,TRUE,
42,7,hard,Binary Search,Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement an iterative version of the binary search algorithm to find the index of an element in a sorted array.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr, target):
    """"""
    Perform an iterative binary search on a sorted array to find the index of the target element.

    Parameters:
    arr (list): A sorted list of elements where the search is to be performed.
    target (any): The element to search for in the array.

    Returns:
    int: The index of the target element if found, otherwise -1.
    """"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Calculate the middle index

        # Check if the target is present at mid
        if arr[mid] == target:
            return mid
        # If target is greater, ignore the left half
        elif arr[mid] < target:
            left = mid + 1
        # If target is smaller, ignore the right half
        else:
            right = mid - 1

    # Target is not present in the array
    return -1

# Test cases to verify the correctness of the funcImp function
def test_funcImp():
    # Test case 1: Target is in the middle
    assert funcImp([1, 2, 3, 4, 5], 3) == 2
    # Test case 2: Target is the first element
    assert funcImp([1, 2, 3, 4, 5], 1) == 0
    # Test case 3: Target is the last element
    assert funcImp([1, 2, 3, 4, 5], 5) == 4
    # Test case 4: Target is not in the array
    assert funcImp([1, 2, 3, 4, 5], 6) == -1
    # Test case 5: Empty array
    assert funcImp([], 1) == -1
    # Test case 6: Single element array, target present
    assert funcImp([1], 1) == 0
    # Test case 7: Single element array, target not present
    assert funcImp([1], 2) == -1
    # Test case 8: Large array
    assert funcImp(list(range(1000000)), 999999) == 999999

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277",,,FAIL,FALSE,
43,0,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A rotated sorted array
    :return: int - The minimum element in the array
    """"""
    if not nums:
        raise ValueError(""Input array is empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the array is not rotated (the smallest element is the first element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # If mid element is greater than the rightmost element, the minimum is in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            # Otherwise, the minimum is in the left half including mid
            right = mid
    
    # At the end of the loop, left == right and pointing to the smallest element
    return nums[left]

# Test cases to verify the solution
test_cases = [
    ([3, 4, 5, 1, 2], 1),  # Rotated, minimum is 1
    ([4, 5, 6, 7, 0, 1, 2], 0),  # Rotated, minimum is 0
    ([11, 13, 15, 17], 11),  # Not rotated, minimum is 11
    ([2, 1], 1),  # Rotated, minimum is 1
    ([1], 1),  # Single element, minimum is 1
]

# Execute test cases
for i, (nums, expected) in enumerate(test_cases):
    result = funcImp(nums)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} is the minimum element."")
```","[3, 4, 5, 1, 2]",1,1,PASS,TRUE,
43,1,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A rotated sorted array
    :return: int - The minimum element in the array
    """"""
    if not nums:
        raise ValueError(""Input array is empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the array is not rotated (the smallest element is the first element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # If mid element is greater than the rightmost element, the minimum is in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            # Otherwise, the minimum is in the left half including mid
            right = mid
    
    # At the end of the loop, left == right and pointing to the smallest element
    return nums[left]

# Test cases to verify the solution
test_cases = [
    ([3, 4, 5, 1, 2], 1),  # Rotated, minimum is 1
    ([4, 5, 6, 7, 0, 1, 2], 0),  # Rotated, minimum is 0
    ([11, 13, 15, 17], 11),  # Not rotated, minimum is 11
    ([2, 1], 1),  # Rotated, minimum is 1
    ([1], 1),  # Single element, minimum is 1
]

# Execute test cases
for i, (nums, expected) in enumerate(test_cases):
    result = funcImp(nums)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} is the minimum element."")
```","[4, 5, 6, 7, 0, 1, 2]",0,0,PASS,TRUE,
43,2,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A rotated sorted array
    :return: int - The minimum element in the array
    """"""
    if not nums:
        raise ValueError(""Input array is empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the array is not rotated (the smallest element is the first element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # If mid element is greater than the rightmost element, the minimum is in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            # Otherwise, the minimum is in the left half including mid
            right = mid
    
    # At the end of the loop, left == right and pointing to the smallest element
    return nums[left]

# Test cases to verify the solution
test_cases = [
    ([3, 4, 5, 1, 2], 1),  # Rotated, minimum is 1
    ([4, 5, 6, 7, 0, 1, 2], 0),  # Rotated, minimum is 0
    ([11, 13, 15, 17], 11),  # Not rotated, minimum is 11
    ([2, 1], 1),  # Rotated, minimum is 1
    ([1], 1),  # Single element, minimum is 1
]

# Execute test cases
for i, (nums, expected) in enumerate(test_cases):
    result = funcImp(nums)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} is the minimum element."")
```","[11, 13, 15, 17]",11,11,PASS,TRUE,
43,3,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A rotated sorted array
    :return: int - The minimum element in the array
    """"""
    if not nums:
        raise ValueError(""Input array is empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the array is not rotated (the smallest element is the first element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # If mid element is greater than the rightmost element, the minimum is in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            # Otherwise, the minimum is in the left half including mid
            right = mid
    
    # At the end of the loop, left == right and pointing to the smallest element
    return nums[left]

# Test cases to verify the solution
test_cases = [
    ([3, 4, 5, 1, 2], 1),  # Rotated, minimum is 1
    ([4, 5, 6, 7, 0, 1, 2], 0),  # Rotated, minimum is 0
    ([11, 13, 15, 17], 11),  # Not rotated, minimum is 11
    ([2, 1], 1),  # Rotated, minimum is 1
    ([1], 1),  # Single element, minimum is 1
]

# Execute test cases
for i, (nums, expected) in enumerate(test_cases):
    result = funcImp(nums)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} is the minimum element."")
```","[2, 1]",1,1,PASS,TRUE,
43,4,hard,Binary Search,"Given a rotated sorted array, find the minimum element using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Given a rotated sorted array, find the minimum element using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(nums):
    """"""
    This function finds the minimum element in a rotated sorted array using binary search.
    
    :param nums: List[int] - A rotated sorted array
    :return: int - The minimum element in the array
    """"""
    if not nums:
        raise ValueError(""Input array is empty"")
    
    left, right = 0, len(nums) - 1
    
    # If the array is not rotated (the smallest element is the first element)
    if nums[left] < nums[right]:
        return nums[left]
    
    while left < right:
        mid = (left + right) // 2
        
        # If mid element is greater than the rightmost element, the minimum is in the right half
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            # Otherwise, the minimum is in the left half including mid
            right = mid
    
    # At the end of the loop, left == right and pointing to the smallest element
    return nums[left]

# Test cases to verify the solution
test_cases = [
    ([3, 4, 5, 1, 2], 1),  # Rotated, minimum is 1
    ([4, 5, 6, 7, 0, 1, 2], 0),  # Rotated, minimum is 0
    ([11, 13, 15, 17], 11),  # Not rotated, minimum is 11
    ([2, 1], 1),  # Rotated, minimum is 1
    ([1], 1),  # Single element, minimum is 1
]

# Execute test cases
for i, (nums, expected) in enumerate(test_cases):
    result = funcImp(nums)
    assert result == expected, f""Test case {i+1} failed: expected {expected}, got {result}""
    print(f""Test case {i+1} passed: {result} is the minimum element."")
```",[1],1,1,PASS,TRUE,
44,0,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if the target element exists.
    
    :param matrix: List[List[int]] - A 2D matrix where each row is sorted and the first element
                   of each row is greater than the last element of the previous row.
    :param target: int - The target element to search for in the matrix.
    :return: bool - True if the target exists in the matrix, False otherwise.
    """"""
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Target is present in the matrix
    matrix1 = [
        [1, 3, 5, 7],
        [10, 11, 16, 20],
        [23, 30, 34, 50]
    ]
    target1 = 3
    assert funcImp(matrix1, target1) == True, ""Test case 1 failed""

    # Test case 2: Target is not present in the matrix
    target2 = 13
    assert funcImp(matrix1, target2) == False, ""Test case 2 failed""

    # Test case 3: Empty matrix
    matrix3 = []
    target3 = 1
    assert funcImp(matrix3, target3) == False, ""Test case 3 failed""

    # Test case 4: Single element matrix, target present
    matrix4 = [[5]]
    target4 = 5
    assert funcImp(matrix4, target4) == True, ""Test case 4 failed""

    # Test case 5: Single element matrix, target not present
    target5 = 3
    assert funcImp(matrix4, target5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 3)",TRUE,TRUE,PASS,TRUE,
44,1,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if the target element exists.
    
    :param matrix: List[List[int]] - A 2D matrix where each row is sorted and the first element
                   of each row is greater than the last element of the previous row.
    :param target: int - The target element to search for in the matrix.
    :return: bool - True if the target exists in the matrix, False otherwise.
    """"""
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Target is present in the matrix
    matrix1 = [
        [1, 3, 5, 7],
        [10, 11, 16, 20],
        [23, 30, 34, 50]
    ]
    target1 = 3
    assert funcImp(matrix1, target1) == True, ""Test case 1 failed""

    # Test case 2: Target is not present in the matrix
    target2 = 13
    assert funcImp(matrix1, target2) == False, ""Test case 2 failed""

    # Test case 3: Empty matrix
    matrix3 = []
    target3 = 1
    assert funcImp(matrix3, target3) == False, ""Test case 3 failed""

    # Test case 4: Single element matrix, target present
    matrix4 = [[5]]
    target4 = 5
    assert funcImp(matrix4, target4) == True, ""Test case 4 failed""

    # Test case 5: Single element matrix, target not present
    target5 = 3
    assert funcImp(matrix4, target5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 13)",FALSE,FALSE,PASS,TRUE,
44,2,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if the target element exists.
    
    :param matrix: List[List[int]] - A 2D matrix where each row is sorted and the first element
                   of each row is greater than the last element of the previous row.
    :param target: int - The target element to search for in the matrix.
    :return: bool - True if the target exists in the matrix, False otherwise.
    """"""
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Target is present in the matrix
    matrix1 = [
        [1, 3, 5, 7],
        [10, 11, 16, 20],
        [23, 30, 34, 50]
    ]
    target1 = 3
    assert funcImp(matrix1, target1) == True, ""Test case 1 failed""

    # Test case 2: Target is not present in the matrix
    target2 = 13
    assert funcImp(matrix1, target2) == False, ""Test case 2 failed""

    # Test case 3: Empty matrix
    matrix3 = []
    target3 = 1
    assert funcImp(matrix3, target3) == False, ""Test case 3 failed""

    # Test case 4: Single element matrix, target present
    matrix4 = [[5]]
    target4 = 5
    assert funcImp(matrix4, target4) == True, ""Test case 4 failed""

    # Test case 5: Single element matrix, target not present
    target5 = 3
    assert funcImp(matrix4, target5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([], 1)",FALSE,FALSE,PASS,TRUE,
44,3,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if the target element exists.
    
    :param matrix: List[List[int]] - A 2D matrix where each row is sorted and the first element
                   of each row is greater than the last element of the previous row.
    :param target: int - The target element to search for in the matrix.
    :return: bool - True if the target exists in the matrix, False otherwise.
    """"""
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Target is present in the matrix
    matrix1 = [
        [1, 3, 5, 7],
        [10, 11, 16, 20],
        [23, 30, 34, 50]
    ]
    target1 = 3
    assert funcImp(matrix1, target1) == True, ""Test case 1 failed""

    # Test case 2: Target is not present in the matrix
    target2 = 13
    assert funcImp(matrix1, target2) == False, ""Test case 2 failed""

    # Test case 3: Empty matrix
    matrix3 = []
    target3 = 1
    assert funcImp(matrix3, target3) == False, ""Test case 3 failed""

    # Test case 4: Single element matrix, target present
    matrix4 = [[5]]
    target4 = 5
    assert funcImp(matrix4, target4) == True, ""Test case 4 failed""

    # Test case 5: Single element matrix, target not present
    target5 = 3
    assert funcImp(matrix4, target5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([[5]], 5)",TRUE,TRUE,PASS,TRUE,
44,4,hard,Binary Search,Implement binary search on a two-dimensional matrix to find if a target element exists.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implement binary search on a two-dimensional matrix to find if a target element exists.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(matrix, target):
    """"""
    Perform binary search on a 2D matrix to find if the target element exists.
    
    :param matrix: List[List[int]] - A 2D matrix where each row is sorted and the first element
                   of each row is greater than the last element of the previous row.
    :param target: int - The target element to search for in the matrix.
    :return: bool - True if the target exists in the matrix, False otherwise.
    """"""
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test cases to verify the solution
def test_funcImp():
    # Test case 1: Target is present in the matrix
    matrix1 = [
        [1, 3, 5, 7],
        [10, 11, 16, 20],
        [23, 30, 34, 50]
    ]
    target1 = 3
    assert funcImp(matrix1, target1) == True, ""Test case 1 failed""

    # Test case 2: Target is not present in the matrix
    target2 = 13
    assert funcImp(matrix1, target2) == False, ""Test case 2 failed""

    # Test case 3: Empty matrix
    matrix3 = []
    target3 = 1
    assert funcImp(matrix3, target3) == False, ""Test case 3 failed""

    # Test case 4: Single element matrix, target present
    matrix4 = [[5]]
    target4 = 5
    assert funcImp(matrix4, target4) == True, ""Test case 4 failed""

    # Test case 5: Single element matrix, target not present
    target5 = 3
    assert funcImp(matrix4, target5) == False, ""Test case 5 failed""

    print(""All test cases passed!"")

# Run the test cases
test_funcImp()
```","([[5]], 3)",FALSE,FALSE,PASS,TRUE,
45,0,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is an element that is greater than its neighbors.
    
    :param arr: List[int] - The input array where we need to find the peak element.
    :return: int - The index of a peak element.
    """"""
    def find_peak(arr, low, high, n):
        mid = low + (high - low) // 2
        
        # Check if mid is a peak element
        if (mid == 0 or arr[mid - 1] <= arr[mid]) and (mid == n - 1 or arr[mid + 1] <= arr[mid]):
            return mid
        # If the left neighbor is greater, then the peak must be in the left half
        elif mid > 0 and arr[mid - 1] > arr[mid]:
            return find_peak(arr, low, mid - 1, n)
        # If the right neighbor is greater, then the peak must be in the right half
        else:
            return find_peak(arr, mid + 1, high, n)
    
    n = len(arr)
    if n == 0:
        return None  # No peak in an empty array
    return find_peak(arr, 0, n - 1, n)

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        ([1, 3, 20, 4, 1, 0], [2]),  # Peak at index 2 (20)
        ([10, 20, 15, 2, 23, 90, 67], [1, 5]),  # Peaks at index 1 (20) or 5 (90)
        ([1, 2, 3, 4, 5], [4]),  # Peak at index 4 (5)
        ([5, 4, 3, 2, 1], [0]),  # Peak at index 0 (5)
        ([1], [0]),  # Single element, peak at index 0
        ([], []),  # Empty array, no peak
    ]
    
    for i, (arr, expected) in enumerate(test_cases):
        result = funcImp(arr)
        assert result in expected, f""Test case {i+1} failed: expected {expected}, got {result}""
        print(f""Test case {i+1} passed: {arr} -> Peak at index {result}"")

# Run the test cases
test_funcImp()
```","[1, 3, 20, 4, 1, 0]",[2],2,FAIL,FALSE,
45,1,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is an element that is greater than its neighbors.
    
    :param arr: List[int] - The input array where we need to find the peak element.
    :return: int - The index of a peak element.
    """"""
    def find_peak(arr, low, high, n):
        mid = low + (high - low) // 2
        
        # Check if mid is a peak element
        if (mid == 0 or arr[mid - 1] <= arr[mid]) and (mid == n - 1 or arr[mid + 1] <= arr[mid]):
            return mid
        # If the left neighbor is greater, then the peak must be in the left half
        elif mid > 0 and arr[mid - 1] > arr[mid]:
            return find_peak(arr, low, mid - 1, n)
        # If the right neighbor is greater, then the peak must be in the right half
        else:
            return find_peak(arr, mid + 1, high, n)
    
    n = len(arr)
    if n == 0:
        return None  # No peak in an empty array
    return find_peak(arr, 0, n - 1, n)

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        ([1, 3, 20, 4, 1, 0], [2]),  # Peak at index 2 (20)
        ([10, 20, 15, 2, 23, 90, 67], [1, 5]),  # Peaks at index 1 (20) or 5 (90)
        ([1, 2, 3, 4, 5], [4]),  # Peak at index 4 (5)
        ([5, 4, 3, 2, 1], [0]),  # Peak at index 0 (5)
        ([1], [0]),  # Single element, peak at index 0
        ([], []),  # Empty array, no peak
    ]
    
    for i, (arr, expected) in enumerate(test_cases):
        result = funcImp(arr)
        assert result in expected, f""Test case {i+1} failed: expected {expected}, got {result}""
        print(f""Test case {i+1} passed: {arr} -> Peak at index {result}"")

# Run the test cases
test_funcImp()
```","[10, 20, 15, 2, 23, 90, 67]","[1, 5]",1,FAIL,FALSE,
45,2,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is an element that is greater than its neighbors.
    
    :param arr: List[int] - The input array where we need to find the peak element.
    :return: int - The index of a peak element.
    """"""
    def find_peak(arr, low, high, n):
        mid = low + (high - low) // 2
        
        # Check if mid is a peak element
        if (mid == 0 or arr[mid - 1] <= arr[mid]) and (mid == n - 1 or arr[mid + 1] <= arr[mid]):
            return mid
        # If the left neighbor is greater, then the peak must be in the left half
        elif mid > 0 and arr[mid - 1] > arr[mid]:
            return find_peak(arr, low, mid - 1, n)
        # If the right neighbor is greater, then the peak must be in the right half
        else:
            return find_peak(arr, mid + 1, high, n)
    
    n = len(arr)
    if n == 0:
        return None  # No peak in an empty array
    return find_peak(arr, 0, n - 1, n)

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        ([1, 3, 20, 4, 1, 0], [2]),  # Peak at index 2 (20)
        ([10, 20, 15, 2, 23, 90, 67], [1, 5]),  # Peaks at index 1 (20) or 5 (90)
        ([1, 2, 3, 4, 5], [4]),  # Peak at index 4 (5)
        ([5, 4, 3, 2, 1], [0]),  # Peak at index 0 (5)
        ([1], [0]),  # Single element, peak at index 0
        ([], []),  # Empty array, no peak
    ]
    
    for i, (arr, expected) in enumerate(test_cases):
        result = funcImp(arr)
        assert result in expected, f""Test case {i+1} failed: expected {expected}, got {result}""
        print(f""Test case {i+1} passed: {arr} -> Peak at index {result}"")

# Run the test cases
test_funcImp()
```","[1, 2, 3, 4, 5]",[4],4,FAIL,FALSE,
45,3,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is an element that is greater than its neighbors.
    
    :param arr: List[int] - The input array where we need to find the peak element.
    :return: int - The index of a peak element.
    """"""
    def find_peak(arr, low, high, n):
        mid = low + (high - low) // 2
        
        # Check if mid is a peak element
        if (mid == 0 or arr[mid - 1] <= arr[mid]) and (mid == n - 1 or arr[mid + 1] <= arr[mid]):
            return mid
        # If the left neighbor is greater, then the peak must be in the left half
        elif mid > 0 and arr[mid - 1] > arr[mid]:
            return find_peak(arr, low, mid - 1, n)
        # If the right neighbor is greater, then the peak must be in the right half
        else:
            return find_peak(arr, mid + 1, high, n)
    
    n = len(arr)
    if n == 0:
        return None  # No peak in an empty array
    return find_peak(arr, 0, n - 1, n)

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        ([1, 3, 20, 4, 1, 0], [2]),  # Peak at index 2 (20)
        ([10, 20, 15, 2, 23, 90, 67], [1, 5]),  # Peaks at index 1 (20) or 5 (90)
        ([1, 2, 3, 4, 5], [4]),  # Peak at index 4 (5)
        ([5, 4, 3, 2, 1], [0]),  # Peak at index 0 (5)
        ([1], [0]),  # Single element, peak at index 0
        ([], []),  # Empty array, no peak
    ]
    
    for i, (arr, expected) in enumerate(test_cases):
        result = funcImp(arr)
        assert result in expected, f""Test case {i+1} failed: expected {expected}, got {result}""
        print(f""Test case {i+1} passed: {arr} -> Peak at index {result}"")

# Run the test cases
test_funcImp()
```","[5, 4, 3, 2, 1]",[0],0,FAIL,FALSE,
45,4,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is an element that is greater than its neighbors.
    
    :param arr: List[int] - The input array where we need to find the peak element.
    :return: int - The index of a peak element.
    """"""
    def find_peak(arr, low, high, n):
        mid = low + (high - low) // 2
        
        # Check if mid is a peak element
        if (mid == 0 or arr[mid - 1] <= arr[mid]) and (mid == n - 1 or arr[mid + 1] <= arr[mid]):
            return mid
        # If the left neighbor is greater, then the peak must be in the left half
        elif mid > 0 and arr[mid - 1] > arr[mid]:
            return find_peak(arr, low, mid - 1, n)
        # If the right neighbor is greater, then the peak must be in the right half
        else:
            return find_peak(arr, mid + 1, high, n)
    
    n = len(arr)
    if n == 0:
        return None  # No peak in an empty array
    return find_peak(arr, 0, n - 1, n)

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        ([1, 3, 20, 4, 1, 0], [2]),  # Peak at index 2 (20)
        ([10, 20, 15, 2, 23, 90, 67], [1, 5]),  # Peaks at index 1 (20) or 5 (90)
        ([1, 2, 3, 4, 5], [4]),  # Peak at index 4 (5)
        ([5, 4, 3, 2, 1], [0]),  # Peak at index 0 (5)
        ([1], [0]),  # Single element, peak at index 0
        ([], []),  # Empty array, no peak
    ]
    
    for i, (arr, expected) in enumerate(test_cases):
        result = funcImp(arr)
        assert result in expected, f""Test case {i+1} failed: expected {expected}, got {result}""
        print(f""Test case {i+1} passed: {arr} -> Peak at index {result}"")

# Run the test cases
test_funcImp()
```",[1],[0],0,FAIL,FALSE,
45,5,hard,Binary Search,Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the peak element (an element greater than its neighbors) in an unsorted array using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    This function finds a peak element in an unsorted array using binary search.
    A peak element is an element that is greater than its neighbors.
    
    :param arr: List[int] - The input array where we need to find the peak element.
    :return: int - The index of a peak element.
    """"""
    def find_peak(arr, low, high, n):
        mid = low + (high - low) // 2
        
        # Check if mid is a peak element
        if (mid == 0 or arr[mid - 1] <= arr[mid]) and (mid == n - 1 or arr[mid + 1] <= arr[mid]):
            return mid
        # If the left neighbor is greater, then the peak must be in the left half
        elif mid > 0 and arr[mid - 1] > arr[mid]:
            return find_peak(arr, low, mid - 1, n)
        # If the right neighbor is greater, then the peak must be in the right half
        else:
            return find_peak(arr, mid + 1, high, n)
    
    n = len(arr)
    if n == 0:
        return None  # No peak in an empty array
    return find_peak(arr, 0, n - 1, n)

# Test cases to verify the solution
def test_funcImp():
    test_cases = [
        ([1, 3, 20, 4, 1, 0], [2]),  # Peak at index 2 (20)
        ([10, 20, 15, 2, 23, 90, 67], [1, 5]),  # Peaks at index 1 (20) or 5 (90)
        ([1, 2, 3, 4, 5], [4]),  # Peak at index 4 (5)
        ([5, 4, 3, 2, 1], [0]),  # Peak at index 0 (5)
        ([1], [0]),  # Single element, peak at index 0
        ([], []),  # Empty array, no peak
    ]
    
    for i, (arr, expected) in enumerate(test_cases):
        result = funcImp(arr)
        assert result in expected, f""Test case {i+1} failed: expected {expected}, got {result}""
        print(f""Test case {i+1} passed: {arr} -> Peak at index {result}"")

# Run the test cases
test_funcImp()
```",[],[None],,FAIL,FALSE,
46,0,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic (first increasing, then decreasing).
    
    Parameters:
    arr (list): A list of integers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    n = len(arr)
    
    # An array with less than 3 elements cannot be bitonic
    if n < 3:
        return False
    
    # Find the peak element using binary search
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    peak = left
    
    # Check if the part before the peak is strictly increasing
    for i in range(1, peak):
        if arr[i] <= arr[i - 1]:
            return False
    
    # Check if the part after the peak is strictly decreasing
    for i in range(peak + 1, n):
        if arr[i] >= arr[i - 1]:
            return False
    
    return True

# Test cases to verify the solution
test_cases = [
    ([1, 3, 8, 12, 4, 2], True),  # Bitonic
    ([1, 3, 8, 12, 14, 2], False), # Not bitonic, no decrease after peak
    ([12, 4, 2], True),            # Bitonic, simple case
    ([1, 2, 3, 4, 5], False),      # Only increasing
    ([5, 4, 3, 2, 1], False),      # Only decreasing
    ([1, 3, 8, 12, 12, 4, 2], False), # Not bitonic, peak not unique
    ([1, 2], False),               # Too short to be bitonic
    ([1, 3, 2, 4, 5], False),      # Not bitonic, increases after decrease
]

# Execute test cases
for i, (arr, expected) in enumerate(test_cases):
    result = funcImp(arr)
    print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[1, 3, 8, 12, 4, 2]",TRUE,TRUE,PASS,TRUE,
46,1,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic (first increasing, then decreasing).
    
    Parameters:
    arr (list): A list of integers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    n = len(arr)
    
    # An array with less than 3 elements cannot be bitonic
    if n < 3:
        return False
    
    # Find the peak element using binary search
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    peak = left
    
    # Check if the part before the peak is strictly increasing
    for i in range(1, peak):
        if arr[i] <= arr[i - 1]:
            return False
    
    # Check if the part after the peak is strictly decreasing
    for i in range(peak + 1, n):
        if arr[i] >= arr[i - 1]:
            return False
    
    return True

# Test cases to verify the solution
test_cases = [
    ([1, 3, 8, 12, 4, 2], True),  # Bitonic
    ([1, 3, 8, 12, 14, 2], False), # Not bitonic, no decrease after peak
    ([12, 4, 2], True),            # Bitonic, simple case
    ([1, 2, 3, 4, 5], False),      # Only increasing
    ([5, 4, 3, 2, 1], False),      # Only decreasing
    ([1, 3, 8, 12, 12, 4, 2], False), # Not bitonic, peak not unique
    ([1, 2], False),               # Too short to be bitonic
    ([1, 3, 2, 4, 5], False),      # Not bitonic, increases after decrease
]

# Execute test cases
for i, (arr, expected) in enumerate(test_cases):
    result = funcImp(arr)
    print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[1, 3, 8, 12, 14, 2]",FALSE,TRUE,FAIL,FALSE,
46,2,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic (first increasing, then decreasing).
    
    Parameters:
    arr (list): A list of integers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    n = len(arr)
    
    # An array with less than 3 elements cannot be bitonic
    if n < 3:
        return False
    
    # Find the peak element using binary search
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    peak = left
    
    # Check if the part before the peak is strictly increasing
    for i in range(1, peak):
        if arr[i] <= arr[i - 1]:
            return False
    
    # Check if the part after the peak is strictly decreasing
    for i in range(peak + 1, n):
        if arr[i] >= arr[i - 1]:
            return False
    
    return True

# Test cases to verify the solution
test_cases = [
    ([1, 3, 8, 12, 4, 2], True),  # Bitonic
    ([1, 3, 8, 12, 14, 2], False), # Not bitonic, no decrease after peak
    ([12, 4, 2], True),            # Bitonic, simple case
    ([1, 2, 3, 4, 5], False),      # Only increasing
    ([5, 4, 3, 2, 1], False),      # Only decreasing
    ([1, 3, 8, 12, 12, 4, 2], False), # Not bitonic, peak not unique
    ([1, 2], False),               # Too short to be bitonic
    ([1, 3, 2, 4, 5], False),      # Not bitonic, increases after decrease
]

# Execute test cases
for i, (arr, expected) in enumerate(test_cases):
    result = funcImp(arr)
    print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[12, 4, 2]",TRUE,FALSE,FAIL,FALSE,
46,3,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic (first increasing, then decreasing).
    
    Parameters:
    arr (list): A list of integers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    n = len(arr)
    
    # An array with less than 3 elements cannot be bitonic
    if n < 3:
        return False
    
    # Find the peak element using binary search
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    peak = left
    
    # Check if the part before the peak is strictly increasing
    for i in range(1, peak):
        if arr[i] <= arr[i - 1]:
            return False
    
    # Check if the part after the peak is strictly decreasing
    for i in range(peak + 1, n):
        if arr[i] >= arr[i - 1]:
            return False
    
    return True

# Test cases to verify the solution
test_cases = [
    ([1, 3, 8, 12, 4, 2], True),  # Bitonic
    ([1, 3, 8, 12, 14, 2], False), # Not bitonic, no decrease after peak
    ([12, 4, 2], True),            # Bitonic, simple case
    ([1, 2, 3, 4, 5], False),      # Only increasing
    ([5, 4, 3, 2, 1], False),      # Only decreasing
    ([1, 3, 8, 12, 12, 4, 2], False), # Not bitonic, peak not unique
    ([1, 2], False),               # Too short to be bitonic
    ([1, 3, 2, 4, 5], False),      # Not bitonic, increases after decrease
]

# Execute test cases
for i, (arr, expected) in enumerate(test_cases):
    result = funcImp(arr)
    print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[1, 2, 3, 4, 5]",FALSE,FALSE,PASS,TRUE,
46,4,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic (first increasing, then decreasing).
    
    Parameters:
    arr (list): A list of integers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    n = len(arr)
    
    # An array with less than 3 elements cannot be bitonic
    if n < 3:
        return False
    
    # Find the peak element using binary search
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    peak = left
    
    # Check if the part before the peak is strictly increasing
    for i in range(1, peak):
        if arr[i] <= arr[i - 1]:
            return False
    
    # Check if the part after the peak is strictly decreasing
    for i in range(peak + 1, n):
        if arr[i] >= arr[i - 1]:
            return False
    
    return True

# Test cases to verify the solution
test_cases = [
    ([1, 3, 8, 12, 4, 2], True),  # Bitonic
    ([1, 3, 8, 12, 14, 2], False), # Not bitonic, no decrease after peak
    ([12, 4, 2], True),            # Bitonic, simple case
    ([1, 2, 3, 4, 5], False),      # Only increasing
    ([5, 4, 3, 2, 1], False),      # Only decreasing
    ([1, 3, 8, 12, 12, 4, 2], False), # Not bitonic, peak not unique
    ([1, 2], False),               # Too short to be bitonic
    ([1, 3, 2, 4, 5], False),      # Not bitonic, increases after decrease
]

# Execute test cases
for i, (arr, expected) in enumerate(test_cases):
    result = funcImp(arr)
    print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[5, 4, 3, 2, 1]",FALSE,FALSE,PASS,TRUE,
46,5,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic (first increasing, then decreasing).
    
    Parameters:
    arr (list): A list of integers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    n = len(arr)
    
    # An array with less than 3 elements cannot be bitonic
    if n < 3:
        return False
    
    # Find the peak element using binary search
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    peak = left
    
    # Check if the part before the peak is strictly increasing
    for i in range(1, peak):
        if arr[i] <= arr[i - 1]:
            return False
    
    # Check if the part after the peak is strictly decreasing
    for i in range(peak + 1, n):
        if arr[i] >= arr[i - 1]:
            return False
    
    return True

# Test cases to verify the solution
test_cases = [
    ([1, 3, 8, 12, 4, 2], True),  # Bitonic
    ([1, 3, 8, 12, 14, 2], False), # Not bitonic, no decrease after peak
    ([12, 4, 2], True),            # Bitonic, simple case
    ([1, 2, 3, 4, 5], False),      # Only increasing
    ([5, 4, 3, 2, 1], False),      # Only decreasing
    ([1, 3, 8, 12, 12, 4, 2], False), # Not bitonic, peak not unique
    ([1, 2], False),               # Too short to be bitonic
    ([1, 3, 2, 4, 5], False),      # Not bitonic, increases after decrease
]

# Execute test cases
for i, (arr, expected) in enumerate(test_cases):
    result = funcImp(arr)
    print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[1, 3, 8, 12, 12, 4, 2]",FALSE,FALSE,PASS,TRUE,
46,6,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic (first increasing, then decreasing).
    
    Parameters:
    arr (list): A list of integers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    n = len(arr)
    
    # An array with less than 3 elements cannot be bitonic
    if n < 3:
        return False
    
    # Find the peak element using binary search
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    peak = left
    
    # Check if the part before the peak is strictly increasing
    for i in range(1, peak):
        if arr[i] <= arr[i - 1]:
            return False
    
    # Check if the part after the peak is strictly decreasing
    for i in range(peak + 1, n):
        if arr[i] >= arr[i - 1]:
            return False
    
    return True

# Test cases to verify the solution
test_cases = [
    ([1, 3, 8, 12, 4, 2], True),  # Bitonic
    ([1, 3, 8, 12, 14, 2], False), # Not bitonic, no decrease after peak
    ([12, 4, 2], True),            # Bitonic, simple case
    ([1, 2, 3, 4, 5], False),      # Only increasing
    ([5, 4, 3, 2, 1], False),      # Only decreasing
    ([1, 3, 8, 12, 12, 4, 2], False), # Not bitonic, peak not unique
    ([1, 2], False),               # Too short to be bitonic
    ([1, 3, 2, 4, 5], False),      # Not bitonic, increases after decrease
]

# Execute test cases
for i, (arr, expected) in enumerate(test_cases):
    result = funcImp(arr)
    print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[1, 2]",FALSE,FALSE,PASS,TRUE,
46,7,hard,Binary Search,"Determine if an array is bitonic (first increasing, then decreasing) using binary search.","## Problem Statement
- Develop a Python script to solve the problem: 'Determine if an array is bitonic (first increasing, then decreasing) using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(arr):
    """"""
    Determine if an array is bitonic (first increasing, then decreasing).
    
    Parameters:
    arr (list): A list of integers.
    
    Returns:
    bool: True if the array is bitonic, False otherwise.
    """"""
    n = len(arr)
    
    # An array with less than 3 elements cannot be bitonic
    if n < 3:
        return False
    
    # Find the peak element using binary search
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    peak = left
    
    # Check if the part before the peak is strictly increasing
    for i in range(1, peak):
        if arr[i] <= arr[i - 1]:
            return False
    
    # Check if the part after the peak is strictly decreasing
    for i in range(peak + 1, n):
        if arr[i] >= arr[i - 1]:
            return False
    
    return True

# Test cases to verify the solution
test_cases = [
    ([1, 3, 8, 12, 4, 2], True),  # Bitonic
    ([1, 3, 8, 12, 14, 2], False), # Not bitonic, no decrease after peak
    ([12, 4, 2], True),            # Bitonic, simple case
    ([1, 2, 3, 4, 5], False),      # Only increasing
    ([5, 4, 3, 2, 1], False),      # Only decreasing
    ([1, 3, 8, 12, 12, 4, 2], False), # Not bitonic, peak not unique
    ([1, 2], False),               # Too short to be bitonic
    ([1, 3, 2, 4, 5], False),      # Not bitonic, increases after decrease
]

# Execute test cases
for i, (arr, expected) in enumerate(test_cases):
    result = funcImp(arr)
    print(f""Test case {i+1}: {'Passed' if result == expected else 'Failed'}"")
```","[1, 3, 2, 4, 5]",FALSE,FALSE,PASS,TRUE,
47,0,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",4,2,1.99999997,FAIL,FALSE,
47,1,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",9,3,2.999999989,FAIL,FALSE,
47,2,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",0,0,0,PASS,TRUE,
47,3,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",1,1,1,PASS,TRUE,
47,4,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",2,1.4142135,1.414213568,FAIL,FALSE,
47,5,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",0.25,0.5,0.49999997,FAIL,FALSE,
47,6,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",0.01,0.1,0.099999994,FAIL,FALSE,
47,7,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",100,10,10.00000001,FAIL,FALSE,
47,8,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",0.0001,0.01,0.01000002,FAIL,FALSE,
47,9,hard,Binary Search,Find the square root of a given number using binary search.,"## Problem Statement
- Develop a Python script to solve the problem: 'Find the square root of a given number using binary search.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(x, precision=1e-7):
    """"""
    Find the square root of a given non-negative number using binary search.
    
    Parameters:
    x (float): The number to find the square root of. Must be non-negative.
    precision (float): The precision of the result. Default is 1e-7.
    
    Returns:
    float: The square root of the number x.
    """"""
    if x < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    if x == 0 or x == 1:
        return x
    
    # Initialize the binary search bounds
    low, high = 0, x
    if x < 1:
        high = 1  # Adjust high for numbers between 0 and 1
    
    # Perform binary search
    while high - low > precision:
        mid = (low + high) / 2
        if mid * mid < x:
            low = mid
        else:
            high = mid
    
    return (low + high) / 2

# Test cases to verify the correctness of the function
def test_funcImp():
    test_cases = [
        (4, 2),
        (9, 3),
        (0, 0),
        (1, 1),
        (2, 1.4142135),  # Approximate value
        (0.25, 0.5),
        (0.01, 0.1),
        (100, 10),
        (1e-4, 0.01),
        (1e6, 1000)
    ]
    
    for i, (input_val, expected) in enumerate(test_cases):
        result = funcImp(input_val)
        assert abs(result - expected) < 1e-6, f""Test case {i+1} failed: input({input_val}) => output({result}), expected({expected})""
        print(f""Test case {i+1} passed: input({input_val}) => output({result}), expected({expected})"")

# Run the test cases
test_funcImp()
```",1000000,1000,1000,FAIL,FALSE,
48,0,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Finds all connected components in an undirected graph using DFS.

    Parameters:
    graph (dict): A dictionary representing an adjacency list of the graph.
                  The keys are node identifiers and the values are lists of adjacent nodes.

    Returns:
    list: A list of connected components, where each component is a list of nodes.
    """"""
    def dfs(node, visited, component):
        """"""
        Helper function to perform DFS and find all nodes in the current component.

        Parameters:
        node (int/str): The current node being visited.
        visited (set): A set of already visited nodes.
        component (list): The current component being constructed.
        """"""
        visited.add(node)
        component.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, visited, component)

    visited = set()  # Set to keep track of visited nodes
    components = []  # List to store all connected components

    # Iterate over each node in the graph
    for node in graph:
        if node not in visited:
            component = []  # List to store the current component
            dfs(node, visited, component)
            components.append(component)

    return components

# Test cases to verify the correctness of the function
if __name__ == ""__main__"":
    # Test case 1: A simple graph with two connected components
    graph1 = {
        0: [1],
        1: [0, 2],
        2: [1],
        3: [4],
        4: [3]
    }
    print(funcImp(graph1))  # Expected output: [[0, 1, 2], [3, 4]]

    # Test case 2: A graph with a single connected component
    graph2 = {
        0: [1, 2],
        1: [0, 2],
        2: [0, 1]
    }
    print(funcImp(graph2))  # Expected output: [[0, 1, 2]]

    # Test case 3: A graph with no edges (each node is its own component)
    graph3 = {
        0: [],
        1: [],
        2: []
    }
    print(funcImp(graph3))  # Expected output: [[0], [1], [2]]

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []

    # Test case 5: A graph with multiple disconnected nodes
    graph5 = {
        0: [],
        1: [],
        2: [],
        3: [],
        4: []
    }
    print(funcImp(graph5))  # Expected output: [[0], [1], [2], [3], [4]]
```","{0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3]}","[[0, 1, 2], [3, 4]]","[[0, 1, 2], [3, 4]]",PASS,TRUE,None
48,1,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Finds all connected components in an undirected graph using DFS.

    Parameters:
    graph (dict): A dictionary representing an adjacency list of the graph.
                  The keys are node identifiers and the values are lists of adjacent nodes.

    Returns:
    list: A list of connected components, where each component is a list of nodes.
    """"""
    def dfs(node, visited, component):
        """"""
        Helper function to perform DFS and find all nodes in the current component.

        Parameters:
        node (int/str): The current node being visited.
        visited (set): A set of already visited nodes.
        component (list): The current component being constructed.
        """"""
        visited.add(node)
        component.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, visited, component)

    visited = set()  # Set to keep track of visited nodes
    components = []  # List to store all connected components

    # Iterate over each node in the graph
    for node in graph:
        if node not in visited:
            component = []  # List to store the current component
            dfs(node, visited, component)
            components.append(component)

    return components

# Test cases to verify the correctness of the function
if __name__ == ""__main__"":
    # Test case 1: A simple graph with two connected components
    graph1 = {
        0: [1],
        1: [0, 2],
        2: [1],
        3: [4],
        4: [3]
    }
    print(funcImp(graph1))  # Expected output: [[0, 1, 2], [3, 4]]

    # Test case 2: A graph with a single connected component
    graph2 = {
        0: [1, 2],
        1: [0, 2],
        2: [0, 1]
    }
    print(funcImp(graph2))  # Expected output: [[0, 1, 2]]

    # Test case 3: A graph with no edges (each node is its own component)
    graph3 = {
        0: [],
        1: [],
        2: []
    }
    print(funcImp(graph3))  # Expected output: [[0], [1], [2]]

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []

    # Test case 5: A graph with multiple disconnected nodes
    graph5 = {
        0: [],
        1: [],
        2: [],
        3: [],
        4: []
    }
    print(funcImp(graph5))  # Expected output: [[0], [1], [2], [3], [4]]
```","{0: [1, 2], 1: [0, 2], 2: [0, 1]}","[[0, 1, 2]]","[[0, 1, 2]]",PASS,TRUE,None
48,2,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Finds all connected components in an undirected graph using DFS.

    Parameters:
    graph (dict): A dictionary representing an adjacency list of the graph.
                  The keys are node identifiers and the values are lists of adjacent nodes.

    Returns:
    list: A list of connected components, where each component is a list of nodes.
    """"""
    def dfs(node, visited, component):
        """"""
        Helper function to perform DFS and find all nodes in the current component.

        Parameters:
        node (int/str): The current node being visited.
        visited (set): A set of already visited nodes.
        component (list): The current component being constructed.
        """"""
        visited.add(node)
        component.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, visited, component)

    visited = set()  # Set to keep track of visited nodes
    components = []  # List to store all connected components

    # Iterate over each node in the graph
    for node in graph:
        if node not in visited:
            component = []  # List to store the current component
            dfs(node, visited, component)
            components.append(component)

    return components

# Test cases to verify the correctness of the function
if __name__ == ""__main__"":
    # Test case 1: A simple graph with two connected components
    graph1 = {
        0: [1],
        1: [0, 2],
        2: [1],
        3: [4],
        4: [3]
    }
    print(funcImp(graph1))  # Expected output: [[0, 1, 2], [3, 4]]

    # Test case 2: A graph with a single connected component
    graph2 = {
        0: [1, 2],
        1: [0, 2],
        2: [0, 1]
    }
    print(funcImp(graph2))  # Expected output: [[0, 1, 2]]

    # Test case 3: A graph with no edges (each node is its own component)
    graph3 = {
        0: [],
        1: [],
        2: []
    }
    print(funcImp(graph3))  # Expected output: [[0], [1], [2]]

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []

    # Test case 5: A graph with multiple disconnected nodes
    graph5 = {
        0: [],
        1: [],
        2: [],
        3: [],
        4: []
    }
    print(funcImp(graph5))  # Expected output: [[0], [1], [2], [3], [4]]
```","{0: [], 1: [], 2: []}","[[0], [1], [2]]","[[0], [1], [2]]",PASS,TRUE,None
48,3,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Finds all connected components in an undirected graph using DFS.

    Parameters:
    graph (dict): A dictionary representing an adjacency list of the graph.
                  The keys are node identifiers and the values are lists of adjacent nodes.

    Returns:
    list: A list of connected components, where each component is a list of nodes.
    """"""
    def dfs(node, visited, component):
        """"""
        Helper function to perform DFS and find all nodes in the current component.

        Parameters:
        node (int/str): The current node being visited.
        visited (set): A set of already visited nodes.
        component (list): The current component being constructed.
        """"""
        visited.add(node)
        component.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, visited, component)

    visited = set()  # Set to keep track of visited nodes
    components = []  # List to store all connected components

    # Iterate over each node in the graph
    for node in graph:
        if node not in visited:
            component = []  # List to store the current component
            dfs(node, visited, component)
            components.append(component)

    return components

# Test cases to verify the correctness of the function
if __name__ == ""__main__"":
    # Test case 1: A simple graph with two connected components
    graph1 = {
        0: [1],
        1: [0, 2],
        2: [1],
        3: [4],
        4: [3]
    }
    print(funcImp(graph1))  # Expected output: [[0, 1, 2], [3, 4]]

    # Test case 2: A graph with a single connected component
    graph2 = {
        0: [1, 2],
        1: [0, 2],
        2: [0, 1]
    }
    print(funcImp(graph2))  # Expected output: [[0, 1, 2]]

    # Test case 3: A graph with no edges (each node is its own component)
    graph3 = {
        0: [],
        1: [],
        2: []
    }
    print(funcImp(graph3))  # Expected output: [[0], [1], [2]]

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []

    # Test case 5: A graph with multiple disconnected nodes
    graph5 = {
        0: [],
        1: [],
        2: [],
        3: [],
        4: []
    }
    print(funcImp(graph5))  # Expected output: [[0], [1], [2], [3], [4]]
```",{},[],[],PASS,TRUE,None
48,4,hard,Depth-First Search (DFS),Finding connected components in an undirected graph using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Finding connected components in an undirected graph using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Finds all connected components in an undirected graph using DFS.

    Parameters:
    graph (dict): A dictionary representing an adjacency list of the graph.
                  The keys are node identifiers and the values are lists of adjacent nodes.

    Returns:
    list: A list of connected components, where each component is a list of nodes.
    """"""
    def dfs(node, visited, component):
        """"""
        Helper function to perform DFS and find all nodes in the current component.

        Parameters:
        node (int/str): The current node being visited.
        visited (set): A set of already visited nodes.
        component (list): The current component being constructed.
        """"""
        visited.add(node)
        component.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, visited, component)

    visited = set()  # Set to keep track of visited nodes
    components = []  # List to store all connected components

    # Iterate over each node in the graph
    for node in graph:
        if node not in visited:
            component = []  # List to store the current component
            dfs(node, visited, component)
            components.append(component)

    return components

# Test cases to verify the correctness of the function
if __name__ == ""__main__"":
    # Test case 1: A simple graph with two connected components
    graph1 = {
        0: [1],
        1: [0, 2],
        2: [1],
        3: [4],
        4: [3]
    }
    print(funcImp(graph1))  # Expected output: [[0, 1, 2], [3, 4]]

    # Test case 2: A graph with a single connected component
    graph2 = {
        0: [1, 2],
        1: [0, 2],
        2: [0, 1]
    }
    print(funcImp(graph2))  # Expected output: [[0, 1, 2]]

    # Test case 3: A graph with no edges (each node is its own component)
    graph3 = {
        0: [],
        1: [],
        2: []
    }
    print(funcImp(graph3))  # Expected output: [[0], [1], [2]]

    # Test case 4: An empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: []

    # Test case 5: A graph with multiple disconnected nodes
    graph5 = {
        0: [],
        1: [],
        2: [],
        3: [],
        4: []
    }
    print(funcImp(graph5))  # Expected output: [[0], [1], [2], [3], [4]]
```","{0: [], 1: [], 2: [], 3: [], 4: []}","[[0], [1], [2], [3], [4]]","[[0], [1], [2], [3], [4]]",PASS,TRUE,None
49,0,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def funcImp(root):
    """"""
    Perform a recursive Depth-First Search (DFS) traversal on a binary tree.
    
    Args:
    root (TreeNode): The root node of the binary tree.
    
    Returns:
    List[int]: A list of node values in the order they are visited during DFS.
    """"""
    def dfs(node, result):
        if node is None:
            return
        # Pre-order traversal: Visit the root, then left subtree, then right subtree
        result.append(node.val)
        dfs(node.left, result)
        dfs(node.right, result)
    
    result = []
    dfs(root, result)
    return result

# Test cases to verify the correctness of the funcImp function

# Test Case 1: A simple binary tree
#       1
#      / \
#     2   3
#    / \
#   4   5
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
root1.left.left = TreeNode(4)
root1.left.right = TreeNode(5)

# Expected output: [1, 2, 4, 5, 3]
print(funcImp(root1))

# Test Case 2: A binary tree with only left children
#       1
#      /
#     2
#    /
#   3
root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.left.left = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root2))

# Test Case 3: A binary tree with only right children
#   1
#    \
#     2
#      \
#       3
root3 = TreeNode(1)
root3.right = TreeNode(2)
root3.right.right = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root3))

# Test Case 4: An empty tree
root4 = None

# Expected output: []
print(funcImp(root4))

# Test Case 5: A single node tree
root5 = TreeNode(1)

# Expected output: [1]
print(funcImp(root5))
```",<__main__.TreeNode object at 0x00000223321C3F10>,"[1, 2, 4, 5, 3]","[1, 2, 4, 5, 3]",PASS,TRUE,
49,1,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def funcImp(root):
    """"""
    Perform a recursive Depth-First Search (DFS) traversal on a binary tree.
    
    Args:
    root (TreeNode): The root node of the binary tree.
    
    Returns:
    List[int]: A list of node values in the order they are visited during DFS.
    """"""
    def dfs(node, result):
        if node is None:
            return
        # Pre-order traversal: Visit the root, then left subtree, then right subtree
        result.append(node.val)
        dfs(node.left, result)
        dfs(node.right, result)
    
    result = []
    dfs(root, result)
    return result

# Test cases to verify the correctness of the funcImp function

# Test Case 1: A simple binary tree
#       1
#      / \
#     2   3
#    / \
#   4   5
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
root1.left.left = TreeNode(4)
root1.left.right = TreeNode(5)

# Expected output: [1, 2, 4, 5, 3]
print(funcImp(root1))

# Test Case 2: A binary tree with only left children
#       1
#      /
#     2
#    /
#   3
root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.left.left = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root2))

# Test Case 3: A binary tree with only right children
#   1
#    \
#     2
#      \
#       3
root3 = TreeNode(1)
root3.right = TreeNode(2)
root3.right.right = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root3))

# Test Case 4: An empty tree
root4 = None

# Expected output: []
print(funcImp(root4))

# Test Case 5: A single node tree
root5 = TreeNode(1)

# Expected output: [1]
print(funcImp(root5))
```",<__main__.TreeNode object at 0x0000022332215D90>,"[1, 2, 3]","[1, 2, 3]",PASS,TRUE,
49,2,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def funcImp(root):
    """"""
    Perform a recursive Depth-First Search (DFS) traversal on a binary tree.
    
    Args:
    root (TreeNode): The root node of the binary tree.
    
    Returns:
    List[int]: A list of node values in the order they are visited during DFS.
    """"""
    def dfs(node, result):
        if node is None:
            return
        # Pre-order traversal: Visit the root, then left subtree, then right subtree
        result.append(node.val)
        dfs(node.left, result)
        dfs(node.right, result)
    
    result = []
    dfs(root, result)
    return result

# Test cases to verify the correctness of the funcImp function

# Test Case 1: A simple binary tree
#       1
#      / \
#     2   3
#    / \
#   4   5
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
root1.left.left = TreeNode(4)
root1.left.right = TreeNode(5)

# Expected output: [1, 2, 4, 5, 3]
print(funcImp(root1))

# Test Case 2: A binary tree with only left children
#       1
#      /
#     2
#    /
#   3
root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.left.left = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root2))

# Test Case 3: A binary tree with only right children
#   1
#    \
#     2
#      \
#       3
root3 = TreeNode(1)
root3.right = TreeNode(2)
root3.right.right = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root3))

# Test Case 4: An empty tree
root4 = None

# Expected output: []
print(funcImp(root4))

# Test Case 5: A single node tree
root5 = TreeNode(1)

# Expected output: [1]
print(funcImp(root5))
```",<__main__.TreeNode object at 0x0000022332215E90>,"[1, 2, 3]","[1, 2, 3]",PASS,TRUE,
49,3,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def funcImp(root):
    """"""
    Perform a recursive Depth-First Search (DFS) traversal on a binary tree.
    
    Args:
    root (TreeNode): The root node of the binary tree.
    
    Returns:
    List[int]: A list of node values in the order they are visited during DFS.
    """"""
    def dfs(node, result):
        if node is None:
            return
        # Pre-order traversal: Visit the root, then left subtree, then right subtree
        result.append(node.val)
        dfs(node.left, result)
        dfs(node.right, result)
    
    result = []
    dfs(root, result)
    return result

# Test cases to verify the correctness of the funcImp function

# Test Case 1: A simple binary tree
#       1
#      / \
#     2   3
#    / \
#   4   5
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
root1.left.left = TreeNode(4)
root1.left.right = TreeNode(5)

# Expected output: [1, 2, 4, 5, 3]
print(funcImp(root1))

# Test Case 2: A binary tree with only left children
#       1
#      /
#     2
#    /
#   3
root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.left.left = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root2))

# Test Case 3: A binary tree with only right children
#   1
#    \
#     2
#      \
#       3
root3 = TreeNode(1)
root3.right = TreeNode(2)
root3.right.right = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root3))

# Test Case 4: An empty tree
root4 = None

# Expected output: []
print(funcImp(root4))

# Test Case 5: A single node tree
root5 = TreeNode(1)

# Expected output: [1]
print(funcImp(root5))
```",None,[],[],PASS,TRUE,
49,4,hard,Depth-First Search (DFS),Implementing a recursive DFS algorithm to traverse a binary tree.,"## Problem Statement
- Develop a Python script to solve the problem: 'Implementing a recursive DFS algorithm to traverse a binary tree.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def funcImp(root):
    """"""
    Perform a recursive Depth-First Search (DFS) traversal on a binary tree.
    
    Args:
    root (TreeNode): The root node of the binary tree.
    
    Returns:
    List[int]: A list of node values in the order they are visited during DFS.
    """"""
    def dfs(node, result):
        if node is None:
            return
        # Pre-order traversal: Visit the root, then left subtree, then right subtree
        result.append(node.val)
        dfs(node.left, result)
        dfs(node.right, result)
    
    result = []
    dfs(root, result)
    return result

# Test cases to verify the correctness of the funcImp function

# Test Case 1: A simple binary tree
#       1
#      / \
#     2   3
#    / \
#   4   5
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
root1.left.left = TreeNode(4)
root1.left.right = TreeNode(5)

# Expected output: [1, 2, 4, 5, 3]
print(funcImp(root1))

# Test Case 2: A binary tree with only left children
#       1
#      /
#     2
#    /
#   3
root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.left.left = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root2))

# Test Case 3: A binary tree with only right children
#   1
#    \
#     2
#      \
#       3
root3 = TreeNode(1)
root3.right = TreeNode(2)
root3.right.right = TreeNode(3)

# Expected output: [1, 2, 3]
print(funcImp(root3))

# Test Case 4: An empty tree
root4 = None

# Expected output: []
print(funcImp(root4))

# Test Case 5: A single node tree
root5 = TreeNode(1)

# Expected output: [1]
print(funcImp(root5))
```",<__main__.TreeNode object at 0x0000022332215FD0>,[1],[1],PASS,TRUE,
50,0,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if a directed graph contains a cycle using DFS.
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    def dfs(node):
        # Mark the current node as visited and add it to the recursion stack
        visited.add(node)
        recStack.add(node)
        
        # Recur for all neighbors
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in recStack:
                return True
        
        # Remove the node from the recursion stack
        recStack.remove(node)
        return False
    
    visited = set()
    recStack = set()
    
    # Call the recursive helper function to detect cycle in different DFS trees
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    return False

# Test cases
if __name__ == ""__main__"":
    # Test case 1: Graph with a cycle
    graph1 = {
        0: [1],
        1: [2],
        2: [0]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: Graph without a cycle
    graph2 = {
        0: [1],
        1: [2],
        2: []
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: Graph with a self-loop
    graph3 = {
        0: [0]
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: False

    # Test case 5: Graph with multiple components, one with a cycle
    graph5 = {
        0: [1],
        1: [2],
        2: [0],
        3: [4],
        4: []
    }
    print(funcImp(graph5))  # Expected output: True
```","{0: [1], 1: [2], 2: [0]}",TRUE,TRUE,PASS,TRUE,
50,1,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if a directed graph contains a cycle using DFS.
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    def dfs(node):
        # Mark the current node as visited and add it to the recursion stack
        visited.add(node)
        recStack.add(node)
        
        # Recur for all neighbors
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in recStack:
                return True
        
        # Remove the node from the recursion stack
        recStack.remove(node)
        return False
    
    visited = set()
    recStack = set()
    
    # Call the recursive helper function to detect cycle in different DFS trees
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    return False

# Test cases
if __name__ == ""__main__"":
    # Test case 1: Graph with a cycle
    graph1 = {
        0: [1],
        1: [2],
        2: [0]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: Graph without a cycle
    graph2 = {
        0: [1],
        1: [2],
        2: []
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: Graph with a self-loop
    graph3 = {
        0: [0]
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: False

    # Test case 5: Graph with multiple components, one with a cycle
    graph5 = {
        0: [1],
        1: [2],
        2: [0],
        3: [4],
        4: []
    }
    print(funcImp(graph5))  # Expected output: True
```","{0: [1], 1: [2], 2: []}",FALSE,FALSE,PASS,TRUE,
50,2,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if a directed graph contains a cycle using DFS.
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    def dfs(node):
        # Mark the current node as visited and add it to the recursion stack
        visited.add(node)
        recStack.add(node)
        
        # Recur for all neighbors
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in recStack:
                return True
        
        # Remove the node from the recursion stack
        recStack.remove(node)
        return False
    
    visited = set()
    recStack = set()
    
    # Call the recursive helper function to detect cycle in different DFS trees
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    return False

# Test cases
if __name__ == ""__main__"":
    # Test case 1: Graph with a cycle
    graph1 = {
        0: [1],
        1: [2],
        2: [0]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: Graph without a cycle
    graph2 = {
        0: [1],
        1: [2],
        2: []
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: Graph with a self-loop
    graph3 = {
        0: [0]
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: False

    # Test case 5: Graph with multiple components, one with a cycle
    graph5 = {
        0: [1],
        1: [2],
        2: [0],
        3: [4],
        4: []
    }
    print(funcImp(graph5))  # Expected output: True
```",{0: [0]},TRUE,TRUE,PASS,TRUE,
50,3,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if a directed graph contains a cycle using DFS.
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    def dfs(node):
        # Mark the current node as visited and add it to the recursion stack
        visited.add(node)
        recStack.add(node)
        
        # Recur for all neighbors
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in recStack:
                return True
        
        # Remove the node from the recursion stack
        recStack.remove(node)
        return False
    
    visited = set()
    recStack = set()
    
    # Call the recursive helper function to detect cycle in different DFS trees
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    return False

# Test cases
if __name__ == ""__main__"":
    # Test case 1: Graph with a cycle
    graph1 = {
        0: [1],
        1: [2],
        2: [0]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: Graph without a cycle
    graph2 = {
        0: [1],
        1: [2],
        2: []
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: Graph with a self-loop
    graph3 = {
        0: [0]
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: False

    # Test case 5: Graph with multiple components, one with a cycle
    graph5 = {
        0: [1],
        1: [2],
        2: [0],
        3: [4],
        4: []
    }
    print(funcImp(graph5))  # Expected output: True
```",{},FALSE,FALSE,PASS,TRUE,
50,4,hard,Depth-First Search (DFS),Determining if a directed graph contains a cycle using DFS.,"## Problem Statement
- Develop a Python script to solve the problem: 'Determining if a directed graph contains a cycle using DFS.'

## Solution Development
- Create a Python function named 'funcImp' that implements the solution.
- Ensure that the function is defined at the beginning of your script and is accessible throughout the script.

## Script Requirements
- The script should define the 'funcImp' function at the root level, not inside any class or other function.
- Include comments in the script to explain the logic and functionality of the 'funcImp' function.
- Test the function within the script to ensure it's correctly defined and functioning as expected.

## Test Case Execution
- Execute the 'funcImp' function with various test cases to verify its correctness.
- Ensure that the function 'funcImp' is defined and accessible in the scope where the test cases are executed.

## Test Case Preparation
- Prepare a set of test cases, including edge cases, to thoroughly test the function.
- Test cases should cover different types of input strings, such as alphabetic, numeric, special characters, and empty strings.

## Execution Process
- Run each test case through the 'funcImp' function.
- Capture the output of each test case to compare it with the expected result.","```python
def funcImp(graph):
    """"""
    Determines if a directed graph contains a cycle using DFS.
    
    :param graph: A dictionary representing the adjacency list of the graph.
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    def dfs(node):
        # Mark the current node as visited and add it to the recursion stack
        visited.add(node)
        recStack.add(node)
        
        # Recur for all neighbors
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in recStack:
                return True
        
        # Remove the node from the recursion stack
        recStack.remove(node)
        return False
    
    visited = set()
    recStack = set()
    
    # Call the recursive helper function to detect cycle in different DFS trees
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    return False

# Test cases
if __name__ == ""__main__"":
    # Test case 1: Graph with a cycle
    graph1 = {
        0: [1],
        1: [2],
        2: [0]
    }
    print(funcImp(graph1))  # Expected output: True

    # Test case 2: Graph without a cycle
    graph2 = {
        0: [1],
        1: [2],
        2: []
    }
    print(funcImp(graph2))  # Expected output: False

    # Test case 3: Graph with a self-loop
    graph3 = {
        0: [0]
    }
    print(funcImp(graph3))  # Expected output: True

    # Test case 4: Empty graph
    graph4 = {}
    print(funcImp(graph4))  # Expected output: False

    # Test case 5: Graph with multiple components, one with a cycle
    graph5 = {
        0: [1],
        1: [2],
        2: [0],
        3: [4],
        4: []
    }
    print(funcImp(graph5))  # Expected output: True
```","{0: [1], 1: [2], 2: [0], 3: [4], 4: []}",TRUE,TRUE,PASS,TRUE,
